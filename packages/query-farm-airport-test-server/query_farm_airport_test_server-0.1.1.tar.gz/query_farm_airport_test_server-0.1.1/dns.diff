diff --git a/pyproject.toml b/pyproject.toml
index c1f60f7..644fc97 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -9,7 +9,8 @@ dependencies = [
     "pyarrow>=20.0.0",
     "query-farm-flight-server",
     "duckdb>=1.3.1",
-    "query-farm-duckdb-json-serialization>=0.1.1"
+    "query-farm-duckdb-json-serialization>=0.1.1",
+    "dnspython[asyncio]>=2.7.0",
 ]
 readme = "README.md"
 requires-python = ">= 3.12"
diff --git a/requirements-dev.lock b/requirements-dev.lock
index d7f4bee..ccb6d9e 100644
--- a/requirements-dev.lock
+++ b/requirements-dev.lock
@@ -25,6 +25,8 @@ click==8.2.1
     # via query-farm-flight-server
 coverage==7.9.2
     # via pytest-cov
+dnspython==2.7.0
+    # via query-farm-airport-test-server
 duckdb==1.3.2
     # via query-farm-airport-test-server
 execnet==2.1.1
diff --git a/requirements.lock b/requirements.lock
index b9d8fbb..0bb5d38 100644
--- a/requirements.lock
+++ b/requirements.lock
@@ -23,6 +23,8 @@ certifi==2025.7.14
     # via sentry-sdk
 click==8.2.1
     # via query-farm-flight-server
+dnspython==2.7.0
+    # via query-farm-airport-test-server
 duckdb==1.3.2
     # via query-farm-airport-test-server
 fuzzywuzzy==0.18.0
diff --git a/src/query_farm_airport_test_server/database_impl.py b/src/query_farm_airport_test_server/database_impl.py
index e330cae..d30a295 100644
--- a/src/query_farm_airport_test_server/database_impl.py
+++ b/src/query_farm_airport_test_server/database_impl.py
@@ -7,6 +7,7 @@ from dataclasses import dataclass, field
 from decimal import Decimal
 from typing import Any, Literal, overload
 
+from duckdb import struct_type
 import pyarrow as pa
 import pyarrow.compute as pc
 import pyarrow.flight as flight
@@ -810,9 +811,76 @@ def collatz_steps(n: int) -> list[int]:
     return results
 
 
+import asyncio
+import dns.asyncresolver
+import dns.reversename
+import dns.rdatatype
+import pyarrow as pa
+
+
+async def get_soa_for_ip(resolver: dns.asyncresolver.Resolver, ip: str) -> dict[str, str | None]:
+    assert isinstance(ip, str)
+    print("doing reverse lookup for", ip)
+    try:
+        rev_name = dns.reversename.from_add
+
+        ress(ip)
+        labels = rev_name.labels
+
+        for i in range(len(labels) - 2):  # Skip root
+            zone = dns.name.Name(labels[i:])
+            try:
+                response = await resolver.resolve(zone, dns.rdatatype.SOA)
+                for rdata in response:
+                    return {"zone": str(zone), "soa_mname": str(rdata.mname)}
+            except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, dns.resolver.LifetimeTimeout):
+                continue
+            except Exception as e:
+                return {"zone": None, "soa_mname": f"Error: {e}"}
+    except Exception as e:
+        return {"zone": None, "soa_mname": f"Error: {e}"}
+
+    return {"zone": None, "soa_mname": "No SOA found"}
+
+
+async def _get_reverse_soa(inputs: pa.Array) -> pa.Table:
+    resolver = dns.asyncresolver.Resolver()
+    tasks = [get_soa_for_ip(resolver, v["ip"]) for v in inputs.to_pylist()]
+    results = await asyncio.gather(*tasks)
+    struct_type = pa.struct([("zone", pa.string()), ("soa_mname", pa.string())])
+    return pa.array(results, type=struct_type)
+
+
+def get_reverse_soa(ip_array: pa.Array) -> pa.Array:
+    try:
+        results = asyncio.run(_get_reverse_soa(ip_array))
+        return results
+    except RuntimeError:
+        raise flight.FlightServerError(
+            "Failed to run async function get_reverse_soa. This may be due to running in a non-async context."
+        )
+
+
 util_schema = SchemaCollection(
     scalar_functions_by_name=CaseInsensitiveDict(
         {
+            "soa_for_ip": ScalarFunction(
+                input_schema=pa.schema([pa.field("ip", pa.string())]),
+                output_schema=pa.schema(
+                    [
+                        pa.field(
+                            "result",
+                            pa.struct(
+                                [
+                                    pa.field("zone", pa.string()),
+                                    pa.field("soa_mname", pa.string()),
+                                ]
+                            ),
+                        ),
+                    ]
+                ),
+                handler=get_reverse_soa,
+            ),
             "test_uppercase": ScalarFunction(
                 input_schema=pa.schema([pa.field("a", pa.string())]),
                 output_schema=pa.schema([pa.field("result", pa.string())]),
