Metadata-Version: 2.4
Name: ThermoSim
Version: 2.3.1
Summary: A simulation package for thermodynamic systems
Author: Md. Waheduzzaman Nouman
Description-Content-Type: text/markdown
Requires-Dist: numpy
Requires-Dist: scipy
Requires-Dist: matplotlib
Requires-Dist: CoolProp
Requires-Dist: pandas
Requires-Dist: CoolProp
Requires-Dist: pymoo
Dynamic: author
Dynamic: description
Dynamic: description-content-type
Dynamic: requires-dist
Dynamic: summary

Chapter List for Documentation

1. Introduction

   * Overview of the Thermodynamic Model

   * Target Audience

   * Real-World Applications

2. Installation and Setup

   * Installation via PyPI

   * Installing from Source

   * Dependencies

   * Quick Start

3. Basic Usage

   * Example Setup

   * Creating and Connecting Components (Pumps, Heat Exchangers, etc.)

   * Solving the Model and Viewing Results

4. Model Components

   * Detailed Explanation of Each Component (Pump, Turbine, Heat Exchanger, etc.)

   * How Each Component Works

   * Key Methods for Each Component

5. Advanced Features

   * Optimization Capabilities (e.g., Genetic Algorithms, Differential Evolution)

   * Graphing and Visualization

   * Customizing Component Behavior

6. API Reference

   * Class and Method References

   * Parameters, Inputs, and Outputs for Each Function

   * Example Code Snippets

7. Performance and Efficiency Considerations

   * How to Optimize Your Model

   * Computational Complexity and Memory Usage

   * Best Practices for Large-Scale Simulations

8. Contributing

   * How to Contribute to the Development

   * Reporting Issues

   * Submitting Pull Requests

9. License

   * Licensing Information

   * Copyright and Usage Terms

# 

# **Chapter 1: Introduction**

## **Overview of the Thermodynamic Model**

This Python module, **ThermoSim**, is designed to simulate and analyze various thermodynamic systems and components. It can model complex systems involving fluids such as water, air, and refrigerants like isobutane. The module supports a range of thermodynamic processes, including pumps, turbines, heat exchangers, and other essential components commonly found in energy systems, refrigeration cycles, and heat transfer applications.

### **Key Features:**

* **State Point Management:** The module allows you to define and track state points, representing the thermodynamic properties of fluids (e.g., temperature, pressure, enthalpy) at various points in the system.

* **Component Modeling:** It models different components like pumps, turbines, heat exchangers, and expansion valves, each with specific methods for energy calculations and performance evaluation.

This model serves as a powerful tool for engineers and researchers working on thermodynamic cycle design, optimization, and analysis, including heat pumps, refrigeration systems, and other energy conversion systems.

## **Target Audience**

This documentation is intended for:

* **Engineering Students**: Those studying thermodynamics, energy systems, and heat transfer. The module provides a practical tool to simulate real-world energy systems and understand thermodynamic concepts.

* **Researchers**: Professionals and researchers working in the field of thermodynamics and energy efficiency can use this module for modeling, optimization, and analysis of complex systems.

* **Energy System Designers**: Engineers involved in designing and optimizing thermodynamic systems such as power plants, heat exchangers, refrigeration cycles, and renewable energy systems.

## **Real-World Applications**

1. **Heat Exchanger Design and Optimization**: The module simulates various types of heat exchangers (e.g., double-pipe, evaporator, condenser), helping engineers optimize thermal efficiency and energy usage in industrial applications.

2. **Pumps and Turbines**: It can model pumps and turbines used in power generation, refrigeration, and HVAC systems, providing insights into performance metrics like work output, efficiency, and energy transfer  
     
3. **Energy Efficiency Analysis**: By integrating components like expansion valves and PCM (Phase Change Materials), the model supports the design of energy-efficient systems in heating, cooling, and refrigeration sectors.  
     
4. **Simulation of Thermodynamic Cycles**: The module supports the simulation of thermodynamic cycles, including Rankine and refrigeration cycles, helping in the evaluation of system performance, energy conservation, and operational optimization.

# **Chapter 2: Installation and Setup**

## **Installation**

To install the **ThermoSim** module, follow the steps below. This module is compatible with Python 3.6+.

### **Installing via PyPI**

You can install the module directly from PyPI using `pip`:

`pip install ThermoSim`

## **Quick Start**

Once installed, you can start using the module by importing it into your Python script.

### **Example Usage**

`import ThermoSim`

`# Initialize the thermodynamic model`

`model = ThermoSim.ThermodynamicModel()`

`# Define fluid state points`

`model.add_point('water', StatePointName='1', P=6.09e5, T=158+273.15, Mass_flowrate=555.9)`

`model.add_point('water', StatePointName='2', P=6.09e5, T=None, Mass_flowrate=555.9)`

`# Add components (e.g., pump, heat exchanger)`

`pump = model.Pump(model, 'Pump', In_state='1', Out_state='2', n_isen=0.75, Calculate=True)`

`print(Model)`

# **Chapter 3: Basic Usage**

## **Creating and Setting Up the Model**

This chapter explains how to create the thermodynamic model, define state points, and add components like pumps, turbines, and heat exchangers to simulate thermodynamic systems.

### **1\. The `Prop()` Function**

Before defining state points, let’s understand the **`Prop()`** function, as it is used to calculate and create the thermodynamic state for fluids.  **`Prop()`** is using coolprop for calculating the thermodynamic properties. The **`Prop()`** function returns an object (called `State`) that holds the thermodynamic properties of the fluid at a specific state point.

Here’s how the **`Prop()`** function works:

`State = model.Prop(fluid, StatePointName, Mass_flowrate=None, **properties)`

### **Arguments for the `Prop()` function:**

* **fluid**: The fluid type (e.g., 'water', 'isobutane').

* **StatePointName**: A unique identifier for the state point (e.g., '1', '2').

* **Mass\_flowrate** (optional): The mass flow rate of the fluid at the state point (in kg/s).

* **\*\*properties**: These are the thermodynamic properties to define the state point, such as:

  * **P**: Pressure at the state point (in Pascals).  
  * **T**: Temperature at the state point (in Kelvin).  
  * **H**: Enthalpy at the state point (in J/kg).  
  * **S**: Entropy at the state point (in J/kg·K).  
  * **Q**: Quality of the fluid (used in two-phase fluids)  
  * **State.D**: Density (in kg/m³)

#### **State Object**

The **`Prop()`** function creates a **State** object that holds the thermodynamic properties of the fluid. You can access or update the properties of this object directly.

* **State.T**: Temperature (in Kelvin)

* **State.P**: Pressure (in Pascals)

* **State.H**: Enthalpy (in J/kg)

* **State.S**: Entropy (in J/kg·K)

* **State.D**: Density (in kg/m³)

* **State.Cp**: Specific heat at constant pressure (in J/kg·K)

### **Example Usage of `Prop()` and Accessing Properties:**

`# Define a state point for water`

`State = model.Prop('water', 'Demo', P=6.09e5, T=158 + 273.15)`

`# Print all properties of the State object`

`print(State)  # This will display the State object's properties like T, P, H, etc.`

`# Update the pressure directly`

`State.P = 7e5  # New pressure in Pascals`

`# Print updated State object to check changes`

`print(State)  # The updated properties will be displayed`

In this example:

* **State** is an object that stores all the thermodynamic properties for the fluid at state point 'Demp’'.

* We can access the temperature, pressure, enthalpy, entropy, density, and specific heat directly using `State.T`, `State.P`, `State.H`, `State.S`, `State.D`, and `State.Cp`, respectively.

* We update the pressure of the state point using **`State.P = 7e5`**.

### **2\. Adding State Point to the Model**

State points represent the thermodynamic conditions (like pressure, temperature, and mass flow rate) at different points in the system. These points are added using the **`add_point()`** method, which internally calls the **`Prop()`** function to calculate and store the properties of the fluid.

#### **Adding State Points**

When adding a state point, you can define only the known parameters (e.g., pressure, temperature) and set the rest to `None`. The missing properties will be calculated by the model based on the provided values.

`# Adding a state point for water with a known pressure and temperature, but unknown properties`

`model.add_point('water', StatePointName='1', P=6.09e5, T=None, Mass_flowrate=None)`

In this example:

* **'water'** is the fluid.

* **StatePointName='1'** is the unique identifier for the state point.

* **P=6.09e5** sets the pressure.

* **T=None** indicates that the temperature is unknown and will be calculated.

* **Mass\_flowrate=None** indicates that the mass flow rate is not specified and can be calculated.

You can also set other parameters like enthalpy (**H**), entropy (**S**), quality (**Q**), and density (**D**) to `None`:

`# Adding a state point with more parameters set to None`

`model.add_point('water', StatePointName='2', P=10e5, T=None, Mass_flowrate=None)`

Here:

* **H=None**, **S=None**, **Q=None**, **D=None**, and **Cp=None** are set to `None` and will be calculated based on the provided properties (e.g., pressure, temperature, and mass flow rate).

#### **State Points in the Model**

All the state points you add are stored in **`model.Point`**. You can access each state point by its **StatePointName** and view or update its properties.

`# Access a state point by its name (e.g., '1')`

`State = model.Point['1']`

`# Print the properties of the state point`

`print(State)`

#### **`Updating State Points`**

You can also update the properties of any state point after it has been created. For example, to update the pressure of state point '1', you can do:

`python`

`Copy`

`# Update the pressure of state point '1'`

`model.Point['1'].P = 7e5  # Update pressure to 7e5 Pascals`

`# Print the updated state point to verify the change`

`print(model.Point['1'])`

Displaying All State Points

To view all state points and their properties, you can use the model.Point\_print() method:

`# Print all state points in the model`

`model.Point_print()`

`This will display all the state points and their corresponding properties (e.g., temperature, pressure, enthalpy, density, etc.).`

---

### **3\. Example: Adding and Updating State Points**

Let’s start by adding a state point for water with an initial pressure and temperature. Then, we’ll update the pressure and see how the thermodynamic properties (like enthalpy, temperature, etc.) are recalculated after the update.

#### **Step 1: Define Initial State Point**

We start by defining a state point for water at a specific pressure and temperature. We will also leave some properties like **H**, **S**, **Q**, **D**, and **Cp** as None so that they are calculated by the model.

`# Add a state point for water with a known pressure and temperature, but unknown properties`

`model.add_point('water', StatePointName='1', P=6.09e5, T=158 + 273.15, Mass_flowrate=555.9)`

`# Access and print the properties of state point '1'`

`State = model.Point['1']`

`print("Initial State Point:")`

`print(State)  # Print all properties of the state point`

#### **Step 2: Update the Inlet Pressure**

Next, we update the pressure of the state point and see how it affects the properties.

`# Update the pressure of state point '1' to a new value`

`model.Point['1'].P = 7e5  # Update the pressure to 7e5 Pascals`

`# Print the updated state point`

`print("\nUpdated State Point (with new pressure):")`

`print(model.Point['1'])  # Print all properties after the update`

Here, we:

* Update the pressure of **StatePointName='1'** to **P=7e5 Pascals**.

* After updating the pressure, we print the updated properties, including the recalculated values for **T**, **H**, **S**, **Q**, **D**, and **Cp**.

# **Chapter 4: Model Components**

In this chapter, we will explore the key components of the thermodynamic model, such as pumps, turbines, heat exchangers,pipe, expansion Valve and other elements that modify the properties of fluids as they flow through the system. Each component plays a significant role in simulating the energy transfers and thermodynamic processes of the system.

# **Turbine Component Documentation**

## **Overview**

The **Turbine** component in the **ThermoSimV3\_2** module models the process of energy extraction from a fluid as it flows through the turbine. A turbine reduces the pressure of the fluid and extracts work, which is useful in power generation, refrigeration, and other thermodynamic cycles.

### **Functionality**

* The **Turbine** takes fluid from an **inlet state** and delivers it to an **outlet state**.

* The turbine performs work on the fluid and reduces its pressure.

* The **isentropic efficiency** (`n_isen`) and **mechanical efficiency** are used to simulate real-world behavior of the turbine, considering energy losses.

* The turbine calculates missing state properties (like temperature, enthalpy) based on the known inlet/outlet conditions.

---

## **Constructor and Arguments**

The **Turbine** class is initialized using the following constructor:

python

CopyEdit

`def __init__(self, Model, ID, In_state, Out_state, n_isen=1, mechanical_efficiency=1, Calculate=False):`

### **Arguments:**

* **Model**: The thermodynamic model instance that holds state points and components.

* **ID**: The unique identifier for the turbine (e.g., `'Turbine1'`).

* **In\_state**: The state point ID for the fluid entering the turbine (must already exist in `Model.Point`).

* **Out\_state**: The state point ID for the fluid leaving the turbine (can be created or pre-defined).

* **n\_isen** (default \= 1): The isentropic efficiency of the turbine, which indicates how closely the turbine behaves to an ideal (isentropic) expansion. Values range from 0 (no efficiency) to 1 (perfect efficiency).

* **mechanical\_efficiency** (default \= 1): The mechanical efficiency of the turbine, accounting for losses in converting fluid energy to mechanical work. Values range from 0 to 1\.

* **Calculate** (default \= False): A boolean flag to specify whether to immediately calculate turbine properties upon initialization (set to `True` for automatic calculation).

## **Attributes**

* **self.Type**: A string indicating the component type (`'Turbine'`).

* **self.ID**: The unique identifier for the turbine instance.

* **self.Inlet**: The inlet state object, referring to `Model.Point[In_state]`.

* **self.Outlet**: The outlet state object, referring to `Model.Point[Out_state]`.

* **self.n\_isen**: The isentropic efficiency, representing the turbine's ideal behavior.

* **self.mechanical\_efficiency**: The mechanical efficiency, representing how much work is effectively converted from fluid energy.

**self.w**: The work extracted by the turbine (in Joules per second or Watts). This is calculated as:

 python  
CopyEdit  
`self.w = self.Inlet.Mass_flowrate * (self.Inlet.H - self.Outlet.H) * self.mechanical_efficiency`

*   
* **self.Calc()**: If `Calculate=True`, this method is invoked to perform the property update and calculation.

---

## **The `Calc()` Method**

The **`Calc()`** method calculates the outlet properties based on the known inlet state and the turbine's efficiencies.

**Calculate the isentropic outlet enthalpy (H\_isen):**

 python  
CopyEdit  
`H_isen = PropsSI('H', 'P', self.Outlet.P, 'S', self.Inlet.S, self.Inlet.Fluid)`

1. 

**Calculate the real outlet enthalpy based on efficiency:**

 python  
CopyEdit  
`self.Outlet.H = self.Inlet.H - self.n_isen * (self.Inlet.H - H_isen)`

2. 

**Update the outlet state using pressure and new enthalpy:**

 python  
CopyEdit  
`self.Outlet.update('PH')`

3. 

**Calculate work output:**

 python  
CopyEdit  
`self.w = self.Inlet.Mass_flowrate * (self.Inlet.H - self.Outlet.H) * self.mechanical_efficiency`

4. 

The work extracted by the turbine is calculated based on the **mass flow rate**, **enthalpy difference**, and the **mechanical efficiency**.

## **Example Usage:**

### **Scenario 1: Known Inlet, Unknown Outlet**

In this scenario, we know the inlet properties (pressure, temperature) and want to calculate the outlet properties.

python

CopyEdit

`# Define inlet state point '1' with known properties (P, T, Mass_flowrate)`

`model.add_point('water', StatePointName='1', P=6.09e5, T=158 + 273.15, Mass_flowrate=500)`

`# Define a turbine with known inlet (state point '1') and unknown outlet (state point '2')`

`turbine = model.Turbine(model, 'Turbine1', In_state='1', Out_state='2', n_isen=0.85, mechanical_efficiency=0.9, Calculate=True)`

`# Access and print the properties of the outlet state (calculated by the turbine)`

`print("Turbine ID:", turbine.ID)`

`print("Work Extracted:", turbine.w)`

`print("Inlet State Properties:", model.Point['1'])`

`print("Outlet State Properties:", model.Point['2'])`

### **Scenario 2: Known Outlet, Unknown Inlet**

In this scenario, we know the outlet properties and want to calculate the inlet properties.

python

CopyEdit

`# Define outlet state point '2' with known properties (P, T)`

`model.add_point('water', StatePointName='2', P=3.5e5, T=120 + 273.15, Mass_flowrate=500)`

`# Define a turbine with unknown inlet (state point '1') and known outlet (state point '2')`

`turbine = model.Turbine(model, 'Turbine2', In_state='1', Out_state='2', n_isen=0.8, mechanical_efficiency=0.85, Calculate=True)`

`# Access and print the properties of the inlet state (calculated by the turbine)`

`print("Turbine ID:", turbine.ID)`

`print("Work Extracted:", turbine.w)`

`print("Inlet State Properties (calculated):", model.Point['1'])`

`print("Outlet State Properties (known):", model.Point['2'])`

---

## **Summary of Key Attributes:**

| Attribute | Description |
| :---- | :---- |
| **Type** | Component type (`'Turbine'`) |
| **ID** | Unique identifier for the turbine |
| **Inlet** | Inlet state object (`Model.Point[In_state]`) |
| **Outlet** | Outlet state object (`Model.Point[Out_state]`) |
| **n\_isen** | Isentropic efficiency (ideal behavior) |
| **mechanical\_efficiency** | Mechanical efficiency (real-world performance) |
| **w** | Work extracted by the turbine (J/s or Watts) |

# **Pump Component Documentation**

## **Overview**

The **Pump** component in the **ThermoSimV3\_2** module models the process of increasing the pressure of a fluid. Pumps are widely used in fluid circulation systems to ensure that fluids flow through various parts of a thermodynamic system, such as heat exchangers, turbines, or other components. The pump performs work on the fluid, increasing its pressure and potentially its temperature.

### **Functionality**

* The **Pump** takes fluid from an **inlet state** and delivers it to an **outlet state**.

* The pump increases the pressure of the fluid and may increase its temperature depending on the energy transfer.

* The **isentropic efficiency** (`n_isen`) and **mechanical efficiency** are used to simulate real-world pump behavior, considering energy losses.

---

## **Constructor and Arguments**

The **Pump** class is initialized using the following constructor:

python

CopyEdit

`def __init__(self, Model, ID, In_state, Out_state, n_isen=1, mechanical_efficiency=1, Calculate=False):`

### **Arguments:**

* **Model**: The thermodynamic model instance that holds state points and components.

* **ID**: The unique identifier for the pump (e.g., `'Pump1'`).

* **In\_state**: The state point ID for the fluid entering the pump (must already exist in `Model.Point`).

* **Out\_state**: The state point ID for the fluid leaving the pump (can be created or pre-defined).

* **n\_isen** (default \= 1): The isentropic efficiency of the pump, indicating how closely the pump behaves to an ideal (isentropic) compression. Values range from 0 (no efficiency) to 1 (perfect efficiency).

* **mechanical\_efficiency** (default \= 1): The mechanical efficiency of the pump, which accounts for losses in converting mechanical energy to fluid pressure increase. Values range from 0 to 1\.

* **Calculate** (default \= False): A boolean flag to specify whether to immediately perform calculations upon initialization (set to `True` for automatic calculation).

## **Attributes**

* **self.Type**: A string indicating the component type (`'Pump'`).

* **self.ID**: The unique identifier for the pump instance.

* **self.Inlet**: The inlet state object, referring to `Model.Point[In_state]`.

* **self.Outlet**: The outlet state object, referring to `Model.Point[Out_state]`.

* **self.n\_isen**: The isentropic efficiency of the pump, representing ideal behavior.

* **self.mechanical\_efficiency**: The mechanical efficiency of the pump, representing real-world energy conversion efficiency.

**self.w**: The work done by the pump (in Joules per second or Watts). This is calculated as:

 python  
CopyEdit  
`self.w = self.Inlet.Mass_flowrate * (self.Outlet.H - self.Inlet.H) * self.mechanical_efficiency`

*   
* **self.Calc()**: If `Calculate=True`, this method is invoked to perform the property update and calculation.

---

## **The `Calc()` Method**

The **`Calc()`** method calculates the outlet properties based on the known inlet state and the pump’s efficiencies.

**Calculate the isentropic outlet enthalpy (H\_isen):**

 python  
CopyEdit  
`H_isen = PropsSI('H', 'P', self.Outlet.P, 'S', self.Inlet.S, self.Inlet.Fluid)`

1. 

**Calculate the real outlet enthalpy based on efficiency:**

 python  
CopyEdit  
`self.Outlet.H = self.Inlet.H + self.n_isen * (H_isen - self.Inlet.H)`

2. 

**Update the outlet state using pressure and new enthalpy:**

 python  
CopyEdit  
`self.Outlet.update('PH')`

3. 

**Calculate work input:**

 python  
CopyEdit  
`self.w = self.Inlet.Mass_flowrate * (self.Outlet.H - self.Inlet.H) * self.mechanical_efficiency`

4. 

The work done by the pump is calculated based on the **mass flow rate**, **enthalpy difference**, and the **mechanical efficiency**.

---

## **Example Usage:**

### **Scenario 1: Known Inlet, Unknown Outlet**

In this scenario, we know the properties of the **inlet** state (e.g., pressure, temperature, enthalpy), and we want to calculate the properties of the **outlet** state based on the pump's performance.

#### **Code:**

python

CopyEdit

`# Define inlet state point '1' with known properties (P, T, Mass_flowrate)`

`model.add_point('water', StatePointName='1', P=6.09e5, T=158 + 273.15, Mass_flowrate=500)`

`# Define a pump with known inlet (state point '1') and unknown outlet (state point '2')`

`pump = model.Pump(model, 'Pump1', In_state='1', Out_state='2', n_isen=0.85, mechanical_efficiency=0.9, Calculate=True)`

`# Access and print the properties of the outlet state (calculated by the pump)`

`print("Pump ID:", pump.ID)`

`print("Work Done by the Pump:", pump.w)`

`print("Inlet State Properties:", model.Point['1'])`

`print("Outlet State Properties:", model.Point['2'])`

### **Scenario 2: Known Outlet, Unknown Inlet**

In this scenario, we know the properties of the **outlet** state (e.g., pressure, temperature), and we want to calculate the properties of the **inlet** state based on the pump's performance.

#### **Code:**

python

CopyEdit

`# Define outlet state point '2' with known properties (P, T)`

`model.add_point('water', StatePointName='2', P=7.5e5, T=180 + 273.15, Mass_flowrate=500)`

`# Define a pump with unknown inlet (state point '1') and known outlet (state point '2')`

`pump = model.Pump(model, 'Pump2', In_state='1', Out_state='2', n_isen=0.75, mechanical_efficiency=0.85, Calculate=True)`

`# Access and print the properties of the inlet state (calculated by the pump)`

`print("Pump ID:", pump.ID)`

`print("Work Done by the Pump:", pump.w)`

`print("Inlet State Properties (calculated):", model.Point['1'])`

`print("Outlet State Properties (known):", model.Point['2'])`

---

## **Summary of Key Attributes:**

| Attribute | Description |
| :---- | :---- |
| **Type** | Component type (`'Pump'`) |
| **ID** | Unique identifier for the pump |
| **Inlet** | Inlet state object (`Model.Point[In_state]`) |
| **Outlet** | Outlet state object (`Model.Point[Out_state]`) |
| **n\_isen** | Isentropic efficiency (ideal behavior) |
| **mechanical\_efficiency** | Mechanical efficiency (real-world performance) |
| **w** | Work done by the pump (J/s or Watts) |

# **Pipe Component Documentation**

## **Overview**

The **Pipe** component in the **ThermoSimV3\_2** module models the flow of a fluid through a pipe. Pipes are essential elements in fluid systems, influencing the fluid’s pressure and temperature changes as it flows through. The **Pipe** component calculates the **pressure drop** and **temperature drop** across the pipe based on the fluid’s flow properties.

### **Functionality**

* The **Pipe** models the energy losses due to friction as fluid flows through the pipe, as well as any associated pressure and temperature drops.

* It ensures that the **mass flow rate** is conserved between the inlet and outlet of the pipe.

* The **Pipe** can calculate unknown pressure and temperature values based on the known properties, and the provided **pressure drop** and **temperature drop**.

---

## **Constructor and Arguments**

The **Pipe** class is initialized using the following constructor:

python

CopyEdit

`def __init__(self, Model, ID, In_state, Out_state, Pressure_drop=0, Temperature_drop=0, Calculate=False):`

### **Arguments:**

* **Model**: The thermodynamic model instance that holds state points and components.

* **ID**: The unique identifier for the pipe (e.g., `'Pipe1'`).

* **In\_state**: The state point ID for the fluid entering the pipe (must already exist in `Model.Point`).

* **Out\_state**: The state point ID for the fluid leaving the pipe (can be created or pre-defined).

* **Pressure\_drop** (default \= 0): The pressure drop across the pipe (in Pascals). This is the difference between the inlet and outlet pressures.

* **Temperature\_drop** (default \= 0): The temperature drop across the pipe (in Kelvin). This is the difference between the inlet and outlet temperatures.

* **Calculate** (default \= False): A boolean flag to specify whether to immediately perform calculations upon initialization (set to `True` for automatic calculation).

## **Attribute	s**

* **self.Type**: A string indicating the component type (`'Pipe'`).

* **self.ID**: The unique identifier for the pipe instance.

* **self.In\_state**: The ID of the inlet state point (e.g., `'1'`).

* **self.Out\_state**: The ID of the outlet state point (e.g., `'2'`).

* **self.Pressure\_drop**: The pressure drop across the pipe (in Pascals).

* **self.Temperature\_drop**: The temperature drop across the pipe (in Kelvin).

* **self.Solution\_Status**: A boolean indicating whether the solution has been successfully calculated (`True` or `False`).

* **self.In**: The inlet state object, referring to `Model.Point[In_state]`.

* **self.Out**: The outlet state object, referring to `Model.Point[Out_state]`.

---

## **The `Cal()` Method**

The **`Cal()`** method performs the necessary calculations for the **Pipe** component, including the **mass flow rate**, **pressure drop**, and **temperature drop** across the pipe.

1. **Mass Flow Rate Check**:

   * If the mass flow rate is not specified at either the inlet or outlet, it is inferred from the known state. If both are provided, they must match.

2. **Pressure Drop**:

   * If the inlet pressure is not specified, it is calculated by adding the **pressure drop** to the outlet pressure.

   * If the outlet pressure is not specified, it is calculated by subtracting the **pressure drop** from the inlet pressure.

3. **Temperature Drop**:

   * Similar to the pressure drop, if the temperature at either the inlet or outlet is unknown, it is calculated based on the **temperature drop**.

4. **Solution Status**:

   * After the calculations, the solution status is updated, and the model’s state points are updated.

## **Example Usage:**

### **Scenario 1: Known Inlet, Unknown Outlet**

In this scenario, we know the properties of the **inlet** state (e.g., pressure, temperature) and want to calculate the properties of the **outlet** state based on the pipe’s performance.

#### **Code:**

python

CopyEdit

`# Define inlet state point '1' with known properties (P, T, Mass_flowrate)`

`model.add_point('water', StatePointName='1', P=6.09e5, T=158 + 273.15, Mass_flowrate=500)`

`# Define a pipe with known inlet (state point '1') and unknown outlet (state point '2')`

`pipe = model.Pipe(model, 'Pipe1', In_state='1', Out_state='2', Pressure_drop=1e5, Temperature_drop=5, Calculate=True)`

`# Access and print the properties of the outlet state (calculated by the pipe)`

`print("Pipe ID:", pipe.ID)`

`print("Pressure Drop in the Pipe:", pipe.Pressure_drop)`

`print("Temperature Drop in the Pipe:", pipe.Temperature_drop)`

`print("Inlet State Properties:", model.Point['1'])`

`print("Outlet State Properties:", model.Point['2'])`

### **Scenario 2: Known Outlet, Unknown Inlet**

In this scenario, we know the properties of the **outlet** state (e.g., pressure, temperature) and want to calculate the properties of the **inlet** state based on the pipe’s performance.

#### **Code:**

python

CopyEdit

`# Define outlet state point '2' with known properties (P, T)`

`model.add_point('water', StatePointName='2', P=5.5e5, T=180 + 273.15, Mass_flowrate=500)`

`# Define a pipe with unknown inlet (state point '1') and known outlet (state point '2')`

`pipe = model.Pipe(model, 'Pipe2', In_state='1', Out_state='2', Pressure_drop=1e5, Temperature_drop=5, Calculate=True)`

`# Access and print the properties of the inlet state (calculated by the pipe)`

`print("Pipe ID:", pipe.ID)`

`print("Pressure Drop in the Pipe:", pipe.Pressure_drop)`

`print("Temperature Drop in the Pipe:", pipe.Temperature_drop)`

`print("Inlet State Properties (calculated):", model.Point['1'])`

`print("Outlet State Properties (known):", model.Point['2'])`

---

## **Summary of Key Attributes:**

| Attribute | Description |
| :---- | :---- |
| **Type** | Component type (`'Pipe'`) |
| **ID** | Unique identifier for the pipe |
| **In\_state** | The ID of the inlet state point |
| **Out\_state** | The ID of the outlet state point |
| **Pressure\_drop** | The pressure drop across the pipe (Pa) |
| **Temperature\_drop** | The temperature drop across the pipe (K) |
| **Solution\_Status** | Boolean indicating if the solution was successfully calculated |
| **In** | Inlet state object (`Model.Point[In_state]`) |
| **Out** | Outlet state object (`Model.Point[Out_state]`) |

# **Heat Exchanger Component Documentation**

## **Overview**

The HeatExchanger class in the ThermoSimV3\_2 module simulates the thermal exchange between two fluid streams—hot and cold—within a heat exchanger. It computes the heat transfer from the hot fluid to the cold fluid, adjusting the outlet conditions based on the type of heat exchanger (e.g., evaporator, condenser, or double-pipe). The class also calculates the overall heat transfer coefficient (UA), effectiveness, and ensures proper energy balance.

---

## **Constructor and Arguments**

The HeatExchanger class is initialized using the following constructor:

`def __init__(self, Model, ID, PPT, HEX_type, Hot_In_state, Hot_Out_state, Cold_In_state, Cold_Out_state, UA=None, effectiveness=None, Q=None, div_N=200, PPT_graph=False, Calculate=False):`

### **Arguments:**

* Model: The thermodynamic model instance containing all state points and components.  
* ID: Unique identifier for the heat exchanger (e.g., `"HE1"`).  
* PPT: Pinch point temperature (PPT), which is the minimum temperature difference between the hot and cold fluids.  
* HEX\_type: The type of heat exchanger (e.g., `'Evaporator'`, `'Condenser'`, `'double_pipe'`, `'SimpleHEX'`).  
* Hot\_In\_state: The state point ID for the hot fluid entering the heat exchanger.  
* Hot\_Out\_state: The state point ID for the hot fluid exiting the heat exchanger.  
* Cold\_In\_state: The state point ID for the cold fluid entering the heat exchanger.  
* Cold\_Out\_state: The state point ID for the cold fluid exiting the heat exchanger.  
* UA (default \= None): The overall heat transfer coefficient times the heat transfer area.  
* effectiveness (default \= None): The effectiveness of the heat exchanger (used for energy balance calculations).  
* Q (default \= None): The amount of heat transferred, calculated during the energy balance.  
* div\_N (default \= 200): The number of discrete temperature divisions used for the calculation.  
* PPT\_graph (default \= False): Boolean flag to plot the temperature profiles of the hot and cold fluids.  
* Calculate (default \= False): If set to `True`, the calculations are immediately performed upon initialization using the `Cal()` method.

## **Attributes**

* self.ID: The unique identifier for the heat exchanger component.  
* self.Type: Always set to `"HeatExchanger"`.  
* self.Hot\_In\_state, self.Hot\_Out\_state, self.Cold\_In\_state, self.Cold\_Out\_state: State point objects for the hot and cold fluids.  
* self.HEX\_type: The type of heat exchanger (e.g., `'Evaporator'`, `'Condenser'`).  
* self.PPT: Pinch point temperature.  
* self.Q: Heat transferred (in Watts).  
* self.Hot\_Mass\_flowrate: Mass flow rate of the hot fluid.  
* self.Cold\_Mass\_flowrate: Mass flow rate of the cold fluid.  
* self.effectiveness: Effectiveness of the heat exchanger (if applicable).  
* self.Solution\_Status: Boolean indicating whether the solution has been successfully computed (`True` or `False`).  
* self.UA: Overall heat transfer coefficient times area (if applicable).  
* self.Model.Component: The dictionary of components in the model, where the heat exchanger is stored by its ID.

---

## **The** `Cal()` **Method**

The `Cal()` method performs the heat exchange calculations based on the provided state points and energy balance.

### **Steps:**

1. Mass Flow Rate Synchronization:  
   * Ensures that the mass flow rates for both the hot and cold fluids are consistent.  
   * If mass flow rate is not provided at one state point, it is inferred from the other.  
2. Heat Transfer Calculation:  
   * If both the hot and cold fluid outlet temperatures are unknown, the method calculates the heat transfer (`Q`) based on the enthalpy differences and mass flow rates.  
   * If one of the outlet temperatures is known, it calculates the missing outlet temperature based on the heat exchange.  
3. Temperature Profile:  
   * Discretizes the temperature profiles along the heat exchanger for better accuracy.  
   * Uses the logarithmic mean temperature difference (LMTD) to calculate the heat transfer rate if both hot and cold fluid temperatures are provided.  
4. Effectiveness Calculation (if applicable):  
   * Computes the heat exchanger effectiveness if the `effectiveness` argument is provided.  
5. Pinch Point Detection:  
   * Checks whether the minimum temperature difference (pinch point) is violated during the heat exchange.  
6. Plotting (Optional):  
   * If `PPT_graph=True`, plots the temperature profiles for both hot and cold fluids.  
7. Solution Status Update:  
   * Marks the solution as completed and updates the state points in the model.

## **Example Usage**

### **Scenario: Known Hot Fluid Conditions, Calculate Cold Fluid**

*`# Define state points with known temperatures and mass flow rates`* `model.add_point('water', StatePointName='1', P=5e5, T=180 + 273.15, Mass_flowrate=2) # Hot Inlet model.add_point('water', StatePointName='2', P=4.9e5, T=140 + 273.15) # Hot Outlet model.add_point('water', StatePointName='3', P=2e5, T=80 + 273.15, Mass_flowrate=2) # Cold Inlet model.add_point('water', StatePointName='4', P=2.1e5, T=130 + 273.15) # Cold Outlet # Create heat exchanger component hx = model.HeatExchanger(model, 'HE1', PPT=5, HEX_type='Evaporator', Hot_In_state='1', Hot_Out_state='2', Cold_In_state='3', Cold_Out_state='4', Calculate=True) # Access and print the heat transfer and solution status print("Heat Exchanger ID:", hx.ID) print("Heat Transferred (Q):", hx.Q, "W") print("Hot Mass Flowrate:", hx.Hot_Mass_flowrate, "kg/s") print("Cold Mass Flowrate:", hx.Cold_Mass_flowrate, "kg/s") print("Solution Status:", hx.Solution_Status)`

---

## **Key Notes**

* Mass flow rates must be provided for either the hot or cold fluids. If one is missing, it will be inferred from the other.  
* The PPT (Pinch Point Temperature) is critical for determining the minimum temperature difference between the hot and cold fluids.  
* The effectiveness of the heat exchanger should be provided if the energy balance requires it (e.g., for counter-flow heat exchangers).  
* Plotting can be enabled by setting `PPT_graph=True`, which will display the temperature profiles for both the hot and cold fluids.

---

## **Summary of Key Attributes**

| Attribute | Description |
| :---- | :---- |
| ID | Unique identifier for the heat exchanger |
| Type | Always set to `'HeatExchanger'` |
| PPT | Pinch point temperature (minimum temperature difference) |
| Q | Heat transferred (W) |
| Hot\_Mass\_flowrate | Mass flow rate of the hot fluid |
| Cold\_Mass\_flowrate | Mass flow rate of the cold fluid |
| effectiveness | Effectiveness of the heat exchanger (if provided) |
| UA | Overall heat transfer coefficient times area (if applicable) |
| Solution\_Status | Whether the calculations were successfully performed |

The `HEX_type` argument defines the type of heat exchanger being modeled. It plays a crucial role in determining the heat transfer characteristics and the method used to calculate the heat exchange between the hot and cold fluids.

### **Available Types of Heat Exchanger**

The `HEX_type` argument can take various values, including common configurations like `'double_pipe'`, `'Evaporator'`, `'Condenser'`, and others. Each type represents a specific kind of heat exchanger, and the calculation methods and assumptions may vary based on the selected type.

### **1\.** `'double_pipe'` **Heat Exchanger**

* Description: A double-pipe heat exchanger consists of two concentric pipes, with one fluid flowing through the inner pipe and the other fluid flowing through the outer pipe. This type is used for small heat exchange applications, especially when space is limited.  
* Heat Transfer Mechanism: Heat is transferred between the two fluids through the pipe walls, relying on a temperature gradient between the fluids.  
* Calculation: The model uses a simple approach for calculating the heat transfer between the two streams based on the temperature difference and flow rates.  
* Example Usage:  
* *`# Define a double-pipe heat exchanger`* `hx_double_pipe = model.HeatExchanger(model, 'HE1', PPT=5, HEX_type='double_pipe', Hot_In_state='1', Hot_Out_state='2', Cold_In_state='3', Cold_Out_state='4', Calculate=True) print("Heat transferred in Double-Pipe Heat Exchanger:", hx_double_pipe.Q)`

---

### **2\.** `'Evaporator'` **Heat Exchanger**

* Description: An evaporator heat exchanger is typically used in refrigeration systems, where the hot fluid (e.g., refrigerant) evaporates by absorbing heat from the surrounding fluid. The refrigerant changes phase from liquid to gas in the process.  
* Heat Transfer Mechanism: Heat is transferred from the hot fluid to the refrigerant, causing it to evaporate. The refrigerant absorbs energy, which results in a cooling effect.  
* Calculation: The calculation accounts for the latent heat of evaporation and the associated temperature changes in the fluids.  
* Example Usage:  
* *`# Define an evaporator heat exchanger`* `hx_evaporator = model.HeatExchanger(model, 'HE2', PPT=5, HEX_type='Evaporator', Hot_In_state='1', Hot_Out_state='2', Cold_In_state='3', Cold_Out_state='4', Calculate=True) print("Heat transferred in Evaporator:", hx_evaporator.Q)`

---

### **3\.** `'Condenser'` **Heat Exchanger**

* Description: A condenser heat exchanger is used to reject heat from a vapor (e.g., steam) to a cooling medium (e.g., water or air), causing the vapor to condense into a liquid.  
* Heat Transfer Mechanism: In a condenser, the hot vapor loses its heat to the cooling fluid, which causes the vapor to condense. This type of heat exchanger is used in power plants, refrigeration systems, and air conditioning.  
* Calculation: Similar to the evaporator, the calculation for a condenser involves accounting for the heat rejection from the vapor to the cold fluid, as well as the phase change from gas to liquid.  
* Example Usage:  
* *`# Define a condenser heat exchanger`* `hx_condenser = model.HeatExchanger(model, 'HE3', PPT=5, HEX_type='Condenser', Hot_In_state='1', Hot_Out_state='2', Cold_In_state='3', Cold_Out_state='4', Calculate=True) print("Heat transferred in Condenser:", hx_condenser.Q)`

---

### **4\.** `'SimpleHEX'` **Heat Exchanger**

* Description: A simple heat exchanger can represent a variety of heat exchangers that do not fall into more specific categories. It's often used as a generic heat exchanger model for educational or testing purposes.  
* Heat Transfer Mechanism: This model uses a simplified approach to calculate heat transfer based on temperature differences and flow rates.  
* Calculation: The method uses basic heat exchanger equations without advanced phase change or complex configurations.  
* Example Usage:  
* *`# Define a simple heat exchanger`* `hx_simple = model.HeatExchanger(model, 'HE4', PPT=5, HEX_type='SimpleHEX', Hot_In_state='1', Hot_Out_state='2', Cold_In_state='3', Cold_Out_state='4', Calculate=True) print("Heat transferred in Simple Heat Exchanger:", hx_simple.Q)`

## **Summary of HEX\_type Values:**

| HEX\_type | Description | Use Case |
| :---- | :---- | :---- |
| 'double\_pipe' | Two concentric pipes transferring heat between two fluids. | Small-scale applications or where space is limited. |
| 'Evaporator' | Used to absorb heat and evaporate a fluid (e.g., refrigerant). | Common in refrigeration and air conditioning systems. |
| 'Condenser' | Used to reject heat and condense a vapor into a liquid. | Found in power plants and cooling systems. |
| 'SimpleHEX' | Generic heat exchanger used for basic heat transfer calculations. | Suitable for educational purposes or simple simulations. |

