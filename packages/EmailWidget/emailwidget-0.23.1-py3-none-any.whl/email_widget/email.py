"""
This module provides the core functionality of the EmailWidget library, responsible for managing and rendering email content.
"""

import datetime
from pathlib import Path
from typing import TYPE_CHECKING

from email_widget.core.base import BaseWidget
from email_widget.core.config import EmailConfig
from email_widget.core.logger import get_project_logger
from email_widget.core.template_engine import TemplateEngine

if TYPE_CHECKING:
    from email_widget.core.enums import (
        AlertType,
        LayoutType,
        LogLevel,
        ProgressTheme,
        StatusType,
        TextAlign,
        TextType,
    )


class Email:
    """Main email class responsible for managing and rendering email content.

    This class is the core of the EmailWidget library, used to create and manage HTML email reports.
    It serves as a powerful container that can add, manage, and orchestrate various "widgets",
    ultimately rendering them into a beautiful, professional HTML email.

    Core features:
        - **Widget Management**: Easily add, remove, find, and iterate through various content components (text, tables, charts, etc.).
        - **Email Property Configuration**: Customize email title, subtitle, and footer.
        - **Convenience Methods**: Provides a series of `add_*` methods for quickly creating and adding common widgets, simplifying code.
        - **Content Export**: Supports exporting emails as standalone HTML files or getting HTML string content.
        - **Style Configuration**: Through `EmailConfig` object, customize email theme colors, fonts, and layout width.

    Attributes:
        title (str): The main title of the email.
        subtitle (Optional[str]): The subtitle of the email, displayed below the main title.
        footer_text (Optional[str]): The footer text of the email.
        widgets (List[BaseWidget]): List storing all added widgets.
        config (EmailConfig): The email configuration object for controlling styles and behavior.

    Examples:
        A basic email creation and export workflow:

        ```python
        from email_widget import Email
        from email_widget.core.enums import TextType, AlertType

        # 1. Create an email object
        email = Email("Quarterly Sales Report")

        # 2. Set email metadata
        email.set_subtitle("Q1 2024")
        email.set_footer("This report is generated by the sales analysis team")

        # 3. Use convenience methods to add content
        email.add_text("Executive Summary", text_type=TextType.TITLE_LARGE)
        email.add_text("Total sales this quarter reached 1,234,567 yuan, a year-over-year growth of 15%.")
        email.add_alert("Note: Data is still under preliminary verification.", alert_type=AlertType.WARNING)
        email.add_progress(85, label="Quarterly KPI Completion Rate", theme="success")

        # 4. Export as HTML file
        # Will generate "quarterly_report.html" in the default output directory (usually ./output)
        file_path = email.export_html("quarterly_report.html")

        print(f"Report successfully generated at: {file_path}")

        # You can also directly get the HTML string
        html_content = email.export_str()
        # print(html_content)
        ```
    """

    # Email template
    TEMPLATE = """<!DOCTYPE html>
<html lang="{{ lang }}">
<head>
    <meta charset="{{ charset }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    {{ styles|safe }}
</head>
<body>
    <div class="email-container">
        <div class="email-header">
            <h1>{{ title }}</h1>
            {{ subtitle|safe }}
        </div>
        
        <div class="email-body">
            {{ widget_content|safe }}
        </div>
        
        <div class="email-footer">
            {{ footer_text|safe }}
        </div>
    </div>
</body>
</html>"""

    def __init__(self, title: str = "Email Report") -> None:
        """Initialize Email object.

        Args:
            title: Email title, defaults to "Email Report"
        """
        self.title = title
        self.subtitle: str | None = None
        self.footer_text: str | None = None
        self.widgets: list[BaseWidget] = []
        self.config = EmailConfig()
        self._created_at = datetime.datetime.now()
        self._template_engine = TemplateEngine()
        self._logger = get_project_logger()

    def add_widget(self, widget: BaseWidget) -> "Email":
        """Add a single widget to the email.

        Args:
            widget: The widget object to add

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> text_widget = TextWidget().set_content("Hello")
            >>> email.add_widget(text_widget)
        """
        widget._set_parent(self)
        self.widgets.append(widget)
        return self

    def add_widgets(self, widgets: list[BaseWidget]) -> "Email":
        """Batch add multiple widgets to the email.

        Args:
            widgets: List of widget objects

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> widgets = [TextWidget(), TableWidget(), ChartWidget()]
            >>> email.add_widgets(widgets)
        """
        for widget in widgets:
            widget._set_parent(self)
            self.widgets.append(widget)
        return self

    def clear_widgets(self) -> "Email":
        """Clear all widgets.

        Returns:
            Returns self to support method chaining
        """
        self.widgets.clear()
        return self

    def remove_widget(self, widget_id: str) -> "Email":
        """Remove a specific widget by ID.

        Args:
            widget_id: The ID of the widget to remove

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> widget = TextWidget().set_widget_id("my_text")
            >>> email.add_widget(widget)
            >>> email.remove_widget("my_text")
        """
        self.widgets = [w for w in self.widgets if w.widget_id != widget_id]
        return self

    def get_widget(self, widget_id: str) -> BaseWidget | None:
        """Get a specific widget by ID.

        Args:
            widget_id: The widget's ID

        Returns:
            The found widget object, or None if it doesn't exist

        Examples:
            >>> email = Email()
            >>> widget = TextWidget().set_widget_id("my_text")
            >>> email.add_widget(widget)
            >>> found_widget = email.get_widget("my_text")
        """
        for widget in self.widgets:
            if widget.widget_id == widget_id:
                return widget
        return None

    def set_title(self, title: str) -> "Email":
        """Set the email title.

        Args:
            title: New email title

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.set_title("Daily Data Report - 2024-01-01")
        """
        self.title = title
        return self

    def set_subtitle(self, subtitle: str | None) -> "Email":
        """Set the email subtitle.

        Args:
            subtitle: Subtitle text, if None uses default timestamp

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.set_subtitle("Data Statistics Report")
        """
        self.subtitle = subtitle
        return self

    def set_footer(self, footer_text: str | None) -> "Email":
        """Set the email footer.

        Args:
            footer_text: Footer text, if None uses default text

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.set_footer("This report is automatically generated by the data team")
        """
        self.footer_text = footer_text
        return self

    # ===== Convenience constructor methods =====

    def add_text(
        self,
        content: str,
        text_type: "TextType" = None,
        color: str | None = None,
        font_size: str | None = None,
        align: "TextAlign" = None,
        font_weight: str | None = None,
    ) -> "Email":
        """Quickly add a text widget.

        Args:
            content: Text content
            text_type: Text type, defaults to TextType.BODY
            color: Text color, e.g., "#ff0000"
            font_size: Font size, e.g., "18px"
            align: Text alignment
            font_weight: Font weight, e.g., "bold"

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Regular body text
            >>> email.add_text("This is regular text")
            >>> # Large title
            >>> email.add_text("Important Title", TextType.TITLE_LARGE)
            >>> # Styled text
            >>> email.add_text("Important Notice", color="#ff0000", font_size="18px")
        """
        from email_widget.core.enums import TextType
        from email_widget.widgets.text_widget import TextWidget

        if text_type is None:
            text_type = TextType.BODY

        widget = TextWidget().set_content(content).set_type(text_type)

        if color is not None:
            widget.set_color(color)
        if font_size is not None:
            widget.set_font_size(font_size)
        if align is not None:
            widget.set_align(align)
        if font_weight is not None:
            widget.set_font_weight(font_weight)

        return self.add_widget(widget)

    def add_table_from_data(
        self,
        data: list[list[str]],
        headers: list[str] | None = None,
        title: str | None = None,
        show_index: bool = False,
        striped: bool = True,
        bordered: bool = True,
        hoverable: bool = True,
    ) -> "Email":
        """Quickly add a table widget.

        Args:
            data: Table data, two-dimensional list
            headers: Header list, optional
            title: Table title, optional
            show_index: Whether to show row index
            striped: Whether to use striped style
            bordered: Whether to show borders
            hoverable: Whether to support hover effects

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> data = [["Alice", "100", "Excellent"], ["Bob", "95", "Good"]]
            >>> headers = ["Name", "Score", "Grade"]
            >>> email.add_table_from_data(data, headers, "Grade Report")
        """
        from email_widget.widgets.table_widget import TableWidget

        widget = TableWidget()

        if title:
            widget.set_title(title)
        if headers:
            widget.set_headers(headers)

        for row in data:
            widget.add_row(row)

        widget.show_index(show_index)
        widget.set_striped(striped)
        widget.set_bordered(bordered)
        widget.set_hover_effect(hoverable)

        return self.add_widget(widget)

    def add_table_from_df(
        self,
        df: "pd.DataFrame",
        title: str | None = None,
        show_index: bool = False,
        striped: bool = True,
        bordered: bool = True,
        hoverable: bool = True,
    ) -> "Email":
        """Quickly add a table widget from DataFrame.

        Args:
            df: pandas DataFrame object
            title: Table title, optional
            show_index: Whether to show row index
            striped: Whether to use striped style
            bordered: Whether to show borders
            hoverable: Whether to support hover effects

        Returns:
            Returns self to support method chaining

        Examples:
            >>> import pandas as pd
            >>> df = pd.DataFrame({"Name": ["Alice", "Bob"], "Score": [100, 95]})
            >>> email = Email()
            >>> email.add_table_from_df(df, "Grade Statistics")
        """
        from email_widget.utils.optional_deps import check_optional_dependency
        from email_widget.widgets.table_widget import TableWidget

        # Check pandas dependency
        check_optional_dependency("pandas", "pandas")

        widget = TableWidget()

        if title:
            widget.set_title(title)

        widget.set_dataframe(df)
        widget.show_index(show_index)
        widget.set_striped(striped)
        widget.set_bordered(bordered)
        widget.set_hover_effect(hoverable)

        return self.add_widget(widget)

    def add_alert(
        self, content: str, alert_type: "AlertType" = None, title: str | None = None
    ) -> "Email":
        """Quickly add an alert widget.

        Args:
            content: Alert content
            alert_type: Alert type, defaults to NOTE
            title: Custom title, optional

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.add_alert("Task executed successfully!", AlertType.TIP)
            >>> email.add_alert("Please check the data", AlertType.WARNING, "Important Notice")
        """
        from email_widget.core.enums import AlertType
        from email_widget.widgets.alert_widget import AlertWidget

        if alert_type is None:
            alert_type = AlertType.NOTE

        widget = AlertWidget().set_content(content).set_alert_type(alert_type)

        if title:
            widget.set_title(title)

        return self.add_widget(widget)

    def add_progress(
        self,
        value: float,
        label: str | None = None,
        max_value: float = 100.0,
        theme: "ProgressTheme" = None,
        show_percentage: bool = True,
    ) -> "Email":
        """Quickly add a progress bar widget.

        Args:
            value: Current progress value
            label: Progress bar label, optional
            max_value: Maximum value, defaults to 100
            theme: Theme, defaults to PRIMARY
            show_percentage: Whether to show percentage

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.add_progress(75, "Task Completion")
            >>> email.add_progress(100, "Download Progress", theme=ProgressTheme.SUCCESS)
        """
        from email_widget.core.enums import ProgressTheme
        from email_widget.widgets.progress_widget import ProgressWidget

        if theme is None:
            theme = ProgressTheme.PRIMARY

        widget = (
            ProgressWidget()
            .set_value(value)
            .set_max_value(max_value)
            .set_theme(theme)
            .show_percentage(show_percentage)
        )

        if label:
            widget.set_label(label)

        return self.add_widget(widget)

    def add_card(
        self,
        title: str,
        content: str,
        icon: str | None = None,
        metadata: dict[str, str] | None = None,
    ) -> "Email":
        """Quickly add a card widget.

        Args:
            title: Card title
            content: Card content
            icon: Icon, optional
            metadata: Metadata dictionary, optional

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.add_card("System Status", "All services running normally", "âœ…")
            >>> # Card with metadata
            >>> metadata = {"CPU": "15%", "Memory": "60%"}
            >>> email.add_card("Server Monitoring", "Resource usage status", "ðŸ–¥ï¸", metadata)
        """
        from email_widget.widgets.card_widget import CardWidget

        widget = CardWidget().set_title(title).set_content(content)

        if icon:
            widget.set_icon(icon)

        if metadata:
            for key, value in metadata.items():
                widget.add_metadata(key, value)

        return self.add_widget(widget)

    def add_chart_from_plt(
        self,
        title: str | None = None,
        description: str | None = None,
        data_summary: str | None = None,
    ) -> "Email":
        """Quickly add a matplotlib chart widget.

        Args:
            title: Chart title, optional
            description: Chart description, optional
            data_summary: Data summary, optional

        Returns:
            Returns self to support method chaining

        Examples:
            >>> import matplotlib.pyplot as plt
            >>> plt.plot([1, 2, 3, 4], [1, 4, 2, 3])
            >>> plt.title("Sales Trend")
            >>>
            >>> email = Email()
            >>> email.add_chart_from_plt("Monthly Sales", "Shows sales trend changes")
        """
        from email_widget.utils.optional_deps import check_optional_dependency

        check_optional_dependency("matplotlib", "matplotlib")

        import matplotlib.pyplot as plt

        from email_widget.widgets.chart_widget import ChartWidget

        widget = ChartWidget().set_chart(plt)

        if title:
            widget.set_title(title)
        if description:
            widget.set_description(description)
        if data_summary:
            widget.set_data_summary(data_summary)

        return self.add_widget(widget)

    def add_status_items(
        self,
        items: list[dict[str, str]],
        title: str | None = None,
        layout: "LayoutType" = None,
    ) -> "Email":
        """Quickly add a status information widget.

        Args:
            items: Status item list, each item contains label, value, status (optional)
            title: Status group title, optional
            layout: Layout type, defaults to VERTICAL

        Returns:
            Returns self to support method chaining

        Examples:
            >>> items = [
            ...     {"label": "CPU Usage", "value": "15%"},
            ...     {"label": "Memory Usage", "value": "60%"},
            ...     {"label": "Disk Space", "value": "80%"}
            ... ]
            >>> email = Email()
            >>> email.add_status_items(items, "System Monitoring")
        """
        from email_widget.core.enums import LayoutType, StatusType
        from email_widget.widgets.status_widget import StatusWidget

        if layout is None:
            layout = LayoutType.VERTICAL

        widget = StatusWidget().set_layout(layout)

        if title:
            widget.set_title(title)

        for item in items:
            status = None
            if "status" in item:
                # Try to convert string to StatusType
                status_str = item["status"].upper()
                if hasattr(StatusType, status_str):
                    status = getattr(StatusType, status_str)

            widget.add_status_item(item["label"], item["value"], status)

        return self.add_widget(widget)

    def add_quote(
        self,
        content: str,
        author: str | None = None,
        source: str | None = None,
        quote_type: "StatusType" = None,
    ) -> "Email":
        """Quickly add a quote widget.

        Args:
            content: Quote content
            author: Author, optional
            source: Source, optional
            quote_type: Quote type, defaults to INFO

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.add_quote("Success is not final, failure is not fatal", "Churchill")
            >>> email.add_quote("Data is the new oil", source="The Economist")
        """
        from email_widget.core.enums import StatusType
        from email_widget.widgets.quote_widget import QuoteWidget

        if quote_type is None:
            quote_type = StatusType.INFO

        widget = QuoteWidget().set_content(content).set_quote_type(quote_type)

        if author:
            widget.set_author(author)
        if source:
            widget.set_source(source)

        return self.add_widget(widget)

    def add_circular_progress(
        self,
        value: float,
        max_value: float = 100.0,
        label: str | None = None,
        theme: "ProgressTheme" = None,
        size: str = "100px",
    ) -> "Email":
        """Quickly add circular progress bar widget.

        Args:
            value: Current progress value
            max_value: Maximum value, defaults to 100
            label: Progress bar label, optional
            theme: Theme, defaults to PRIMARY
            size: Circle size, defaults to "100px"

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> email.add_circular_progress(85, label="Overall Completion")
            >>> email.add_circular_progress(100, theme=ProgressTheme.SUCCESS, size="120px")
        """
        from email_widget.core.enums import ProgressTheme
        from email_widget.widgets.circular_progress_widget import CircularProgressWidget

        if theme is None:
            theme = ProgressTheme.PRIMARY

        widget = (
            CircularProgressWidget()
            .set_value(value)
            .set_max_value(max_value)
            .set_theme(theme)
            .set_size(size)
        )

        if label:
            widget.set_label(label)

        return self.add_widget(widget)

    def add_log(
        self,
        logs: list[str],
        title: str | None = None,
        show_timestamp: bool = True,
        show_level: bool = True,
        filter_level: "LogLevel" = None,
        max_height: str = "400px",
    ) -> "Email":
        """Quickly add log widget.

        Args:
            logs: Log list
            title: Log title, optional
            show_timestamp: Whether to show timestamps
            show_level: Whether to show log levels
            filter_level: Filter level, optional
            max_height: Maximum height, defaults to "400px"

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> logs = [
            ...     "2024-01-01 10:00:00.000 | INFO | main:process:10 - Task started",
            ...     "2024-01-01 10:00:01.000 | WARNING | main:check:20 - Found abnormal data",
            ...     "2024-01-01 10:00:02.000 | INFO | main:finish:30 - Task completed"
            ... ]
            >>> email.add_log(logs, "Execution Log")
        """
        from email_widget.widgets.log_widget import LogWidget

        widget = (
            LogWidget()
            .set_logs(logs)
            .show_timestamp(show_timestamp)
            .show_level(show_level)
            .set_max_height(max_height)
        )

        if title:
            widget.set_title(title)
        if filter_level:
            widget.filter_by_level(filter_level)

        return self.add_widget(widget)

    def add_button(
        self,
        text: str,
        href: str,
        background_color: str | None = None,
        text_color: str | None = None,
        width: str | None = None,
        align: str = "left",
    ) -> "Email":
        """Quickly add button widget.

        Args:
            text: Button display text
            href: Link address to jump to after clicking the button
            background_color: Button background color, optional
            text_color: Button text color, optional
            width: Button width, optional
            align: Button alignment, defaults to "left"

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Basic button
            >>> email.add_button("View Details", "https://example.com/details")
            >>> # Custom styled button
            >>> email.add_button("Buy Now", "https://shop.example.com",
            ...                  background_color="#22c55e", text_color="#ffffff",
            ...                  width="200px", align="center")
        """
        from email_widget.widgets.button_widget import ButtonWidget

        widget = ButtonWidget().set_text(text).set_href(href).set_align(align)

        if background_color is not None:
            widget.set_background_color(background_color)
        if text_color is not None:
            widget.set_text_color(text_color)
        if width is not None:
            widget.set_width(width)

        return self.add_widget(widget)

    def add_separator(
        self,
        separator_type: "SeparatorType" = None,
        color: str | None = None,
        thickness: str | None = None,
        width: str | None = None,
        margin: str | None = None,
    ) -> "Email":
        """Quickly add separator widget.

        Args:
            separator_type: Separator type, defaults to SOLID
            color: Separator color, optional
            thickness: Separator thickness, optional
            width: Separator width, optional
            margin: Top and bottom margin, optional

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Basic separator
            >>> email.add_separator()
            >>> # Custom styled separator
            >>> email.add_separator(
            ...     separator_type=SeparatorType.DASHED,
            ...     color="#0078d4",
            ...     thickness="2px",
            ...     width="80%"
            ... )
        """
        from email_widget.core.enums import SeparatorType
        from email_widget.widgets.separator_widget import SeparatorWidget

        if separator_type is None:
            separator_type = SeparatorType.SOLID

        widget = SeparatorWidget().set_type(separator_type)

        if color is not None:
            widget.set_color(color)
        if thickness is not None:
            widget.set_thickness(thickness)
        if width is not None:
            widget.set_width(width)
        if margin is not None:
            widget.set_margin(margin)

        return self.add_widget(widget)

    def add_checklist(
        self,
        title: str = "",
        items: list[tuple[str, bool]] | None = None,
        show_progress: bool = False,
        compact_mode: bool = False,
    ) -> "Email":
        """Quickly add checklist widget.

        Args:
            title: Checklist title, optional
            items: Checklist items list, format: [(text, completed), ...], optional
            show_progress: Whether to show progress statistics, defaults to False
            compact_mode: Whether to use compact mode, defaults to False

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Basic checklist
            >>> email.add_checklist("Task List", [
            ...     ("Complete Design", True),
            ...     ("Code Review", False),
            ...     ("Deploy Testing", False)
            ... ])
            >>> # Checklist with progress statistics
            >>> email.add_checklist("Project Progress", [
            ...     ("Requirements Analysis", True),
            ...     ("Development Implementation", True),
            ...     ("Testing Verification", False)
            ... ], show_progress=True)
        """
        from email_widget.widgets.checklist_widget import ChecklistWidget

        widget = ChecklistWidget()

        if title:
            widget.set_title(title)

        if items:
            for item in items:
                if len(item) >= 2:
                    text, completed = item[0], item[1]
                    widget.add_item(text, completed)

        if show_progress:
            widget.show_progress_stats(True)

        if compact_mode:
            widget.set_compact_mode(True)

        return self.add_widget(widget)

    def add_timeline(
        self,
        title: str = "",
        events: list[tuple] | None = None,
        show_time: bool = False,
        reverse_order: bool = False,
    ) -> "Email":
        """Quickly add timeline widget.

        Args:
            title: Timeline title, optional
            events: Events list, format: [(title, time, description, status_type), ...], optional
            show_time: Whether to show timestamps, defaults to False
            reverse_order: Whether to reverse order, defaults to False

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Basic timeline
            >>> email.add_timeline("Project Progress", [
            ...     ("Project Launch", "2024-01-01", "Project officially started"),
            ...     ("Requirements Confirmed", "2024-01-15", "Requirements analysis completed"),
            ...     ("Development Complete", "2024-02-28", "Code development completed")
            ... ])
            >>> # Timeline with timestamps
            >>> email.add_timeline("System Log", [
            ...     ("System Startup", "2024-01-01 09:00", "Service started", "success"),
            ...     ("Issue Found", "2024-01-01 10:30", "Bug discovered", "error"),
            ...     ("Issue Fixed", "2024-01-01 11:00", "Fix completed", "success")
            ... ], show_time=True, reverse_order=True)
        """
        from email_widget.widgets.timeline_widget import TimelineWidget

        widget = TimelineWidget()

        if title:
            widget.set_title(title)

        if events:
            for event in events:
                if len(event) >= 1:
                    title_text = event[0]
                    time = event[1] if len(event) > 1 else None
                    description = event[2] if len(event) > 2 else ""
                    status_type = event[3] if len(event) > 3 else None
                    widget.add_event(title_text, time, description, status_type)

        if show_time:
            widget.show_timestamps(True)

        if reverse_order:
            widget.set_reverse_order(True)

        return self.add_widget(widget)

    def add_metric(
        self,
        title: str = "",
        metrics: list[tuple] | None = None,
        layout: str = "horizontal",
        show_trends: bool = True,
    ) -> "Email":
        """Quickly add metric widget.

        Args:
            title: Metric group title, optional
            metrics: Metric list, format: [(label, value, unit, trend, trend_type, description), ...], optional
            layout: Layout method, 'horizontal' or 'vertical', defaults to 'horizontal'
            show_trends: Whether to show trend information, defaults to True

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Basic metrics
            >>> email.add_metric("Core Metrics", [
            ...     ("Users", 12345, "people"),
            ...     ("Growth Rate", "15.6", "%", "+2.3%", "success"),
            ...     ("Revenue", "$1,250,000", "", "+12.3%", "success")
            ... ])
            >>> # Metrics with complete options
            >>> email.add_metric(
            ...     title="System Performance",
            ...     metrics=[
            ...         ("CPU Usage", "45.2", "%", "+2.1%", "warning", "Needs attention"),
            ...         ("Memory Usage", "78.5", "%", "-1.3%", "success", "Performing well"),
            ...         ("Disk Space", "23.8", "GB", "+5.2GB", "info", "Normal range")
            ...     ],
            ...     layout="vertical",
            ...     show_trends=True
            ... )
        """
        from email_widget.widgets.metric_widget import MetricWidget

        widget = MetricWidget()

        if title:
            widget.set_title(title)

        if metrics:
            for metric in metrics:
                if len(metric) >= 2:
                    label = metric[0]
                    value = metric[1]
                    unit = metric[2] if len(metric) > 2 else ""
                    trend = metric[3] if len(metric) > 3 else ""
                    trend_type = metric[4] if len(metric) > 4 else None
                    description = metric[5] if len(metric) > 5 else ""
                    widget.add_metric(
                        label, value, unit, trend, trend_type, description
                    )

        widget.set_layout(layout)
        widget.show_trends(show_trends)

        return self.add_widget(widget)

    def add_image(
        self,
        image_url: str | Path,
        title: str | None = None,
        description: str | None = None,
        alt_text: str | None = None,
        width: str | None = None,
        height: str | None = None,
        max_width: str | None = None,
        border_radius: str | None = None,
        cache: bool = True,
        embed: bool = True,
        show_caption: bool = True,
    ) -> "Email":
        """Quickly add image widget.

        Args:
            image_url: Image URL string or local file Path object
            title: Image title, optional
            description: Image description, optional
            alt_text: Image alt text, optional
            width: Image width, like \"300px\", \"100%\"
            height: Image height, like \"200px\", \"auto\"
            max_width: Image maximum width, like \"600px\"
            border_radius: Border radius, like \"8px\", \"50%\"
            cache: Whether to cache network images, defaults to True
            embed: Whether to embed images, defaults to True
            show_caption: Whether to show title and description, defaults to True

        Returns:
            Returns self to support method chaining

        Examples:
            >>> email = Email()
            >>> # Basic usage
            >>> email.add_image("https://example.com/image.png")
            >>> # Local image
            >>> from pathlib import Path
            >>> email.add_image(Path("./assets/logo.png"), title="Company Logo")
            >>> # Complete options
            >>> email.add_image(
            ...     "https://example.com/product.jpg",
            ...     title="Product Showcase",
            ...     description="Latest product showcase image",
            ...     alt_text="Product Image",
            ...     width="100%",
            ...     max_width="600px",
            ...     border_radius="8px"
            ... )
        """
        from pathlib import Path

        from email_widget.widgets.image_widget import ImageWidget

        widget = ImageWidget().set_image_url(image_url, cache=cache, embed=embed)

        if title is not None:
            widget.set_title(title)
        if description is not None:
            widget.set_description(description)
        if alt_text is not None:
            widget.set_alt_text(alt_text)
        if width is not None or height is not None:
            widget.set_size(width=width, height=height)
        if max_width is not None:
            widget.set_max_width(max_width)
        if border_radius is not None:
            widget.set_border_radius(border_radius)

        widget.show_caption(show_caption)

        return self.add_widget(widget)

    def _generate_css_styles(self) -> str:
        """Generate inline CSS styles.

        Generate email CSS styles based on configuration, including layout, colors, fonts, etc.

        Returns:
            HTML string containing CSS styles
        """
        primary_color = self.config.get_primary_color()
        font_family = self.config.get_font_family()
        max_width = self.config.get_max_width()

        # Main CSS styles
        main_styles = f"""
        <style>
            body {{
                margin: 0;
                padding: 20px;
                font-family: {font_family};
                line-height: 1.6;
                color: #323130;
                background-color: #faf9f8;
            }}

            .email-container {{
                max-width: {max_width};
                margin: 0 auto;
                background: #ffffff;
                border: 1px solid #e1dfdd;
                border-radius: 8px;
                overflow: hidden;
            }}

            .email-header {{
                background: {primary_color};
                color: #ffffff;
                padding: 24px;
                text-align: center;
            }}

            .email-header h1 {{
                margin: 0;
                font-size: 24px;
                font-weight: 600;
            }}

            .email-header .timestamp {{
                margin-top: 8px;
                font-size: 14px;
                opacity: 0.9;
            }}

            .email-header .subtitle {{
                margin-top: 8px;
                font-size: 16px;
                opacity: 0.95;
                font-weight: 400;
            }}

            .email-body {{
                padding: 24px;
            }}

            .email-footer {{
                background: #f3f2f1;
                padding: 16px 24px;
                text-align: center;
                font-size: 12px;
                color: #605e5c;
                border-top: 1px solid #e1dfdd;
            }}

            /* Common styles */
            .fluent-card {{
                background: #ffffff;
                border: 1px solid #e1dfdd;
                border-radius: 4px;
                margin: 16px 0;
                overflow: hidden;
            }}

            .fluent-card-elevated {{
                border: 1px solid #d2d0ce;
                box-shadow: 0 1.6px 3.6px 0 rgba(0,0,0,0.132), 0 0.3px 0.9px 0 rgba(0,0,0,0.108);
            }}

            /* Responsive design - using email client compatible approach */

            /* Common responsive styles */
            .email-container {{
                width: 100%;
                max-width: {max_width};
                min-width: 320px;
            }}

            /* Table responsive styles */
            .responsive-table {{
                width: 100%;
                max-width: 100%;
                overflow-x: auto;
                display: block;
                white-space: nowrap;
            }}

            .responsive-table table {{
                width: 100%;
                min-width: 400px;
                border-collapse: collapse;
            }}

            /* Image responsive styles */
            .responsive-image {{
                width: 100%;
                max-width: 100%;
                height: auto;
                display: block;
            }}

            /* Content area responsive */
            .responsive-content {{
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                padding: 16px;
            }}

            /* Mobile optimized text size */
            .mobile-text {{
                font-size: 14px;
                line-height: 1.4;
            }}
        </style>"""

        # MSO conditional comment styles - separate handling
        mso_styles = """
        <!-- MSO conditional comment styles - for Outlook -->
        <!--[if mso]>
        <style type="text/css">
            .email-container {
                width: 600px !important;
            }
            .responsive-table {
                display: table !important;
            }
        </style>
        <![endif]-->
        """

        return main_styles + mso_styles

    def _render_email(self) -> str:
        """Render complete email HTML content.

        Render all widgets into complete HTML email, including header, body and footer.

        Returns:
            Complete HTML email string
        """
        try:
            # Generate widget content
            widget_content = ""
            for widget in self.widgets:
                try:
                    widget_html = widget.render_html()
                    if widget_html:
                        widget_content += widget_html + "\n"
                except Exception as e:
                    self._logger.error(f"Widget rendering failed: {e}")
                    continue

            # Prepare template data
            context = self._get_template_context(widget_content)

            # Use template engine to render
            return self._template_engine.render_safe(self.TEMPLATE, context)

        except Exception as e:
            self._logger.error(f"Email rendering failed: {e}")
            return f"<html><body><h1>Rendering Error</h1><p>{str(e)}</p></body></html>"

    def _get_template_context(self, widget_content: str) -> dict[str, str]:
        """Get template context data.

        Args:
            widget_content: Rendered widget content

        Returns:
            Template context dictionary
        """
        timestamp = self._created_at.strftime("%Y-%m-%d %H:%M:%S")

        # Generate subtitle HTML
        if self.subtitle:
            subtitle_html = f'<div class="subtitle">{self.subtitle}</div>'
        else:
            subtitle_html = f'<div class="timestamp">Generated at: {timestamp}</div>'

        # Generate footer HTML
        if self.footer_text:
            footer_html = f"<p>{self.footer_text}</p>"
        else:
            footer_html = "<p>This email is automatically generated by EmailWidget</p>"

        return {
            "title": self.title,
            "subtitle": subtitle_html,
            "footer_text": footer_html,
            "widget_content": widget_content,
            "styles": self._generate_css_styles(),
            "charset": self.config.get_email_charset(),
            "lang": self.config.get_email_lang(),
        }

    def export_html(
        self, filename: str | None = None, output_dir: str | None = None
    ) -> Path:
        """Export email as HTML file.

        Args:
            filename: Optional filename, auto-generated if not provided
            output_dir: Optional output directory, uses default directory from config if not provided

        Returns:
            Complete path of exported file

        Examples:
            >>> email = Email("Report")
            >>> # Use default filename
            >>> path = email.export_html()
            >>>
            >>> # Specify filename and directory
            >>> path = email.export_html("my_report.html", "./reports")
        """
        try:
            output_dir = output_dir or self.config.get_output_dir()

            if filename is None:
                timestamp = self._created_at.strftime("%Y%m%d_%H%M%S")
                filename = f"{self.title}_{timestamp}.html"

            # Ensure filename ends with .html
            if not filename.endswith(".html"):
                filename += ".html"

            output_path = Path(output_dir) / filename
            output_path.parent.mkdir(parents=True, exist_ok=True)

            html_content = self.export_str()

            with open(output_path, "w", encoding="utf-8") as f:
                f.write(html_content)

            self._logger.info(f"Email exported to: {output_path}")
            return output_path

        except Exception as e:
            self._logger.error(f"Failed to export HTML file: {e}")
            raise

    def export_str(self) -> str:
        """Export email as HTML text.

        Returns:
            Complete HTML email string

        Examples:
            >>> email = Email("Preview Test")
            >>> html = email.export_str()
            >>> print(html[:100])  # Print first 100 characters
        """
        return self._render_email()

    def get_widget_count(self) -> int:
        """Get the number of widgets in the current email.

        Returns:
            Number of widgets

        Examples:
            >>> email = Email()
            >>> email.add_widget(TextWidget())
            >>> email.add_widget(TableWidget())
            >>> print(email.get_widget_count())  # Output: 2
        """
        return len(self.widgets)

    def __len__(self) -> int:
        """Support len() function to get widget count.

        Returns:
            Number of widgets

        Examples:
            >>> email = Email()
            >>> email.add_widget(TextWidget())
            >>> print(len(email))  # Output: 1
        """
        return len(self.widgets)

    def __str__(self) -> str:
        """Return string representation of email object.

        Returns:
            String containing title and widget count

        Examples:
            >>> email = Email("Test Email")
            >>> print(str(email))  # Output: Email(title='Test Email', widgets=0)
        """
        return f"Email(title='{self.title}', widgets={len(self.widgets)})"
