from sqlalchemy import Column, Integer, String, Table, bindparam, select, testing
from sqlalchemy.testing import config, eq_, fixtures
from sqlalchemy.testing.suite.test_dialect import (
    EscapingTest,  # noqa: F401
    ExceptionTest,  # noqa: F401
    PingTest,  # noqa: F401
    ReturningGuardsTest,  # noqa: F401
)


class DifficultParametersDisableAutoIncrementTest(fixtures.TestBase):
    """
    modified from https://github.com/sqlalchemy/sqlalchemy/blob/rel_2_0_41/lib/sqlalchemy/testing/suite/test_dialect.py

    This test replaces DifficultParametersTest which has the following
    - serial as the primary key
    - mixed dml and ddl are not supported
    """

    __backend__ = True

    tough_parameters = testing.combinations(
        ("boring",),
        ("per cent",),
        ("per % cent",),
        ("%percent",),
        ("par(ens)",),
        ("percent%(ens)yah",),
        ("col:ons",),
        ("_starts_with_underscore",),
        ("dot.s",),
        ("more :: %colons%",),
        ("_name",),
        ("___name",),
        ("[BracketsAndCase]",),
        ("42numbers",),
        ("percent%signs",),
        ("has spaces",),
        ("/slashes/",),
        ("more/slashes",),
        ("q?marks",),
        ("1param",),
        ("1col:on",),
        argnames="paramname",
    )

    @tough_parameters
    @config.requirements.unusual_column_name_characters
    def test_round_trip_same_named_column(self, paramname, connection, metadata):
        name = paramname

        t = Table(
            "t",
            metadata,
            Column("id", Integer, primary_key=True, autoincrement=False),
            Column(name, String(50), nullable=False),
        )

        # table is created
        t.create(connection)
        connection.commit()
        connection.begin()
        # automatic param generated by insert
        connection.execute(t.insert().values({"id": 1, name: "some name"}))
        connection.commit()
        # automatic param generated by criteria, plus selecting the column
        stmt = select(t.c[name]).where(t.c[name] == "some name")

        eq_(connection.scalar(stmt), "some name")

        # use the name in a param explicitly
        stmt = select(t.c[name]).where(t.c[name] == bindparam(name))

        row = connection.execute(stmt, {name: "some name"}).first()

        # name works as the key from cursor.description
        eq_(row._mapping[name], "some name")

        # use expanding IN
        stmt = select(t.c[name]).where(t.c[name].in_(["some name", "some other_name"]))

        connection.execute(stmt).first()

    @testing.fixture
    def multirow_fixture(self, metadata, connection):
        mytable = Table(
            "mytable",
            metadata,
            Column("myid", Integer),
            Column("name", String(50)),
            Column("desc", String(50)),
        )

        mytable.create(connection)
        connection.commit()
        connection.begin()

        connection.execute(
            mytable.insert(),
            [
                {"myid": 1, "name": "a", "desc": "a_desc"},
                {"myid": 2, "name": "b", "desc": "b_desc"},
                {"myid": 3, "name": "c", "desc": "c_desc"},
                {"myid": 4, "name": "d", "desc": "d_desc"},
            ],
        )
        connection.commit()
        yield mytable

    @tough_parameters
    def test_standalone_bindparam_escape(self, paramname, connection, multirow_fixture):
        tbl1 = multirow_fixture
        stmt = select(tbl1.c.myid).where(tbl1.c.name == bindparam(paramname, value="x"))
        res = connection.scalar(stmt, {paramname: "c"})
        eq_(res, 3)

    @tough_parameters
    def test_standalone_bindparam_escape_expanding(
        self, paramname, connection, multirow_fixture
    ):
        tbl1 = multirow_fixture
        stmt = (
            select(tbl1.c.myid)
            .where(tbl1.c.name.in_(bindparam(paramname, value=["a", "b"])))
            .order_by(tbl1.c.myid)
        )

        res = connection.scalars(stmt, {paramname: ["d", "a"]}).all()
        eq_(res, [1, 4])
