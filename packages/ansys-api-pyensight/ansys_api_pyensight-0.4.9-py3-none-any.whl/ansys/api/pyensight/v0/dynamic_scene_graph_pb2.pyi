"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class VersionRequest(google.protobuf.message.Message):
    """@brief Request for the server API version
    
    Dummy argument for the GetAPIVersion rpc
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___VersionRequest = VersionRequest

class VersionReply(google.protobuf.message.Message):
    """@brief The server API version
    
    This command returns the version number of the DynamicSceneGraphService that the server
    supports.  The number is defined in this .proto file as VersionEnumType::CURRENT_VERSION.
    The protocol passes this value as an int32 so that the client can receive the value
    properly and then compare it to its own value of the VersionEnumType::CURRENT_VERSION enum
    generated by the version of the proto file it had compiled.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _VersionEnumType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VersionEnumTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_VersionEnumType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNDEFINED: VersionReply.VersionEnumType.ValueType = ...  # 0
        """No version number specified"""

        CURRENT_VERSION: VersionReply.VersionEnumType.ValueType = ...  # 101
        """Current version of the .proto file/protocol"""

    class VersionEnumType(_VersionEnumType, metaclass=_VersionEnumTypeEnumTypeWrapper):
        """@brief version number
        
        The version type is used to determine the version number the protocol corresponds to.
        """
        pass

    UNDEFINED: VersionReply.VersionEnumType.ValueType = ...  # 0
    """No version number specified"""

    CURRENT_VERSION: VersionReply.VersionEnumType.ValueType = ...  # 101
    """Current version of the .proto file/protocol"""


    VERSION_FIELD_NUMBER: builtins.int
    version: builtins.int = ...
    """The API version number as an integer.  It should be the value VersionEnumType::CURRENT_VERSION."""

    def __init__(self,
        *,
        version : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["version",b"version"]) -> None: ...
global___VersionReply = VersionReply

class SceneClientInit(google.protobuf.message.Message):
    """@brief Request by the client for an EnSight scene update
    
    This SceneClientCommand sub message is sent by the client at startup or whenever the client 
    would like a scene update.  The server will respond by starting a scene update command sequence, 
    beginning  with a SceneUpdateCommand message, UpdateSceneBegin sub command.  The update sequence
    will end with a SceneUpdateCommand message, UpdateSceneEnd sub command.
    
    This message also informs the server what the maximum size of a block of data should be (in bytes). 
    It also can be used to enable "spontaneous" scene updates that can be started by the EnSight server
    at any time. If the client would like the server to rebroadcast the entire scene, it should
    set the allow_incremental_updates flag to false, suppressing state cache tracking by the server.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ALLOW_SPONTANEOUS_FIELD_NUMBER: builtins.int
    ALLOW_INCREMENTAL_UPDATES_FIELD_NUMBER: builtins.int
    MAXIMUM_CHUNK_SIZE_FIELD_NUMBER: builtins.int
    INCLUDE_TEMPORAL_GEOMETRY_FIELD_NUMBER: builtins.int
    allow_spontaneous: builtins.bool = ...
    """If true, EnSight is allowed to spontaneously start a scene update. If false, updates can only be initiated by the client via this message."""

    allow_incremental_updates: builtins.bool = ...
    """If true, EnSight is allowed/encouraged to send the minimal number of update packets. If false, the client must re-send the entire scene."""

    maximum_chunk_size: builtins.int = ...
    """Sets the maximum payload blocksize in bytes in a single UpdateGeom message (0=unrestricted payload size)."""

    include_temporal_geometry: builtins.bool = ...
    """If true, request that the current temporal geometry be sent.  If false, the current static view is sent"""

    def __init__(self,
        *,
        allow_spontaneous : builtins.bool = ...,
        allow_incremental_updates : builtins.bool = ...,
        maximum_chunk_size : builtins.int = ...,
        include_temporal_geometry : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["allow_incremental_updates",b"allow_incremental_updates","allow_spontaneous",b"allow_spontaneous","include_temporal_geometry",b"include_temporal_geometry","maximum_chunk_size",b"maximum_chunk_size"]) -> None: ...
global___SceneClientInit = SceneClientInit

class SceneClientUpdate(google.protobuf.message.Message):
    """@brief Update a parameter in the EnSight session
    
    Message from client to change some EnSight session state.  This command is currently unimplemented.  The
    intent is that this message would be sent from the VR environment to interact with the EnSight session (e.g. load data, clip plane motion)
    To be defined
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___SceneClientUpdate = SceneClientUpdate

class SceneClientCommand(google.protobuf.message.Message):
    """@brief Aggregate command sent by a dynamic scene graph client
    
    This command represents a union of two different base commands: SceneClientInit and SceneClientUpdate.  To 
    use the message, set the command_type to the type of the message and fill in the appropriate ClientCommand
    sub-message.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ClientCommandType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ClientCommandTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ClientCommandType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        INIT: SceneClientCommand.ClientCommandType.ValueType = ...  # 0
        """Initial command to be sent. Can be sent repeatedly to reset session parameters or request a scene update"""

        UPDATE: SceneClientCommand.ClientCommandType.ValueType = ...  # 1
        """Undefined at present, but used to send interaction information from VR1 back to EnSight"""

    class ClientCommandType(_ClientCommandType, metaclass=_ClientCommandTypeEnumTypeWrapper):
        """The type of the ClientCommand oneof that has been set"""
        pass

    INIT: SceneClientCommand.ClientCommandType.ValueType = ...  # 0
    """Initial command to be sent. Can be sent repeatedly to reset session parameters or request a scene update"""

    UPDATE: SceneClientCommand.ClientCommandType.ValueType = ...  # 1
    """Undefined at present, but used to send interaction information from VR1 back to EnSight"""


    COMMAND_TYPE_FIELD_NUMBER: builtins.int
    INIT_FIELD_NUMBER: builtins.int
    UPDATE_FIELD_NUMBER: builtins.int
    command_type: global___SceneClientCommand.ClientCommandType.ValueType = ...
    """The command type"""

    @property
    def init(self) -> global___SceneClientInit:
        """ Init a session/request a scene graph update"""
        pass
    @property
    def update(self) -> global___SceneClientUpdate:
        """Modify an EnSight session"""
        pass
    def __init__(self,
        *,
        command_type : global___SceneClientCommand.ClientCommandType.ValueType = ...,
        init : typing.Optional[global___SceneClientInit] = ...,
        update : typing.Optional[global___SceneClientUpdate] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ClientCommand",b"ClientCommand","init",b"init","update",b"update"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ClientCommand",b"ClientCommand","command_type",b"command_type","init",b"init","update",b"update"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["ClientCommand",b"ClientCommand"]) -> typing.Optional[typing_extensions.Literal["init","update"]]: ...
global___SceneClientCommand = SceneClientCommand

class UpdateSceneBegin(google.protobuf.message.Message):
    """@brief Begin an update sequence
    
    Sent to mark the start of an update operation, the scene will not be complete until UpdateSceneEnd is received
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESET_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    reset: builtins.bool = ...
    """If true, scene being updated will replace the current scene, client deletes all existing entity definitions. If false, this is an incremental update to be merged into existing scene entities"""

    id: builtins.int = ...
    """The scene entity id"""

    def __init__(self,
        *,
        reset : builtins.bool = ...,
        id : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id",b"id","reset",b"reset"]) -> None: ...
global___UpdateSceneBegin = UpdateSceneBegin

class UpdateSceneEnd(google.protobuf.message.Message):
    """@brief End an update sequence
    
    Sent when the entire scene as been defined and can now be rendered
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """The scene entity id"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id",b"id"]) -> None: ...
global___UpdateSceneEnd = UpdateSceneEnd

class DeleteID(google.protobuf.message.Message):
    """@brief Delete a list of entities."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IDS_FIELD_NUMBER: builtins.int
    @property
    def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """A list of entity ids that have been deleted (and non longer exist in the cache)"""
        pass
    def __init__(self,
        *,
        ids : typing.Optional[typing.Iterable[builtins.int]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ids",b"ids"]) -> None: ...
global___DeleteID = DeleteID

class UpdateView(google.protobuf.message.Message):
    """@brief Update a View entity
    
    Scenes contain a collection of View entities that provide camera definitions and 
    have groups (leading to Parts entities) as children.  A View also provides a timeline 
    over which its children should be considered visible.  The timeline contains
    two time values.  Children of the View are considered visible at some time t, 
    if: `timeline[0] <= t < timeline[1]`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    PARENT_ID_FIELD_NUMBER: builtins.int
    TIMELINE_FIELD_NUMBER: builtins.int
    LOOKAT_FIELD_NUMBER: builtins.int
    LOOKFROM_FIELD_NUMBER: builtins.int
    UPVECTOR_FIELD_NUMBER: builtins.int
    FIELDOFVIEW_FIELD_NUMBER: builtins.int
    ASPECTRATIO_FIELD_NUMBER: builtins.int
    NEARFAR_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """View entity id."""

    parent_id: builtins.int = ...
    """Scene entity id."""

    @property
    def timeline(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Start and end time these children are to be displayed, two values."""
        pass
    @property
    def lookat(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """X,Y,Z of the view lookat point."""
        pass
    @property
    def lookfrom(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """X,Y,Z of the view lookfrom point."""
        pass
    @property
    def upvector(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """NX,NY,NZ of the view up vector."""
        pass
    fieldofview: builtins.float = ...
    """The field of view angle in degrees."""

    aspectratio: builtins.float = ...
    """Display rectangle aspect ratio (dx/dy)."""

    @property
    def nearfar(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The distance from the lookfrom point to the near and far clipping planes."""
        pass
    hash: typing.Text = ...
    """hash for this message payload"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        parent_id : builtins.int = ...,
        timeline : typing.Optional[typing.Iterable[builtins.float]] = ...,
        lookat : typing.Optional[typing.Iterable[builtins.float]] = ...,
        lookfrom : typing.Optional[typing.Iterable[builtins.float]] = ...,
        upvector : typing.Optional[typing.Iterable[builtins.float]] = ...,
        fieldofview : builtins.float = ...,
        aspectratio : builtins.float = ...,
        nearfar : typing.Optional[typing.Iterable[builtins.float]] = ...,
        hash : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["aspectratio",b"aspectratio","fieldofview",b"fieldofview","hash",b"hash","id",b"id","lookat",b"lookat","lookfrom",b"lookfrom","nearfar",b"nearfar","parent_id",b"parent_id","timeline",b"timeline","upvector",b"upvector"]) -> None: ...
global___UpdateView = UpdateView

class UpdatePart(google.protobuf.message.Message):
    """@brief Update a Part entity
    
    Sent to update part rendering attributes.  Parts have Geom entity children that define 
    the bulk data arrays.
    
    The material name needs additional work.  If 'steel' or 'glass' are specified, are we expecting the client 
    to come up with shaders for those materials, or just informing that fill_color and shininess parameters 
    are steel-like or glass-like.  General thinking is to use common namespaces (e.g. granta, etc)
    for known material specifications and namespace prefixed JSON for others (e.g. ensight:{json payload}
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _RenderingMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _RenderingModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RenderingMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NODES: UpdatePart.RenderingMode.ValueType = ...  # 0
        """render the nodes of the connectivity (spheres)"""

        CONNECTIVITY: UpdatePart.RenderingMode.ValueType = ...  # 1
        """render the elements defined by the connectivity, triangles or lines. Note: if edgeflags are specified and the connectivity is triangle, element boundaries are to be outlined"""

    class RenderingMode(_RenderingMode, metaclass=_RenderingModeEnumTypeWrapper):
        """The rendering mode is actually a bit field, defining what should be rendered."""
        pass

    NODES: UpdatePart.RenderingMode.ValueType = ...  # 0
    """render the nodes of the connectivity (spheres)"""

    CONNECTIVITY: UpdatePart.RenderingMode.ValueType = ...  # 1
    """render the elements defined by the connectivity, triangles or lines. Note: if edgeflags are specified and the connectivity is triangle, element boundaries are to be outlined"""


    class _ShadingMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ShadingModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ShadingMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ELEMENTAL: UpdatePart.ShadingMode.ValueType = ...  # 0
        """Normals are specified per element face (e.g. one normal per triangle)."""

        NODAL: UpdatePart.ShadingMode.ValueType = ...  # 1
        """Normals are specified per node."""

    class ShadingMode(_ShadingMode, metaclass=_ShadingModeEnumTypeWrapper):
        """Define the location of normals"""
        pass

    ELEMENTAL: UpdatePart.ShadingMode.ValueType = ...  # 0
    """Normals are specified per element face (e.g. one normal per triangle)."""

    NODAL: UpdatePart.ShadingMode.ValueType = ...  # 1
    """Normals are specified per node."""


    class _TextureWrapMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TextureWrapModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TextureWrapMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        REPEAT: UpdatePart.TextureWrapMode.ValueType = ...  # 0
        """Like GL_REPEAT"""

        CLAMP: UpdatePart.TextureWrapMode.ValueType = ...  # 1
        """Like GL_CLAMP_TO_BORDER, except values outside [0,1] get the usual part color/lighting/color by var in DECAL mode, and killed in REPLACE or MODULATE mode."""

        CLAMP_TEXTURE: UpdatePart.TextureWrapMode.ValueType = ...  # 2
        """Like GL_CLAMP_TO_EDGE"""

    class TextureWrapMode(_TextureWrapMode, metaclass=_TextureWrapModeEnumTypeWrapper):
        """2D texture options for tex coords outside [0,1]"""
        pass

    REPEAT: UpdatePart.TextureWrapMode.ValueType = ...  # 0
    """Like GL_REPEAT"""

    CLAMP: UpdatePart.TextureWrapMode.ValueType = ...  # 1
    """Like GL_CLAMP_TO_BORDER, except values outside [0,1] get the usual part color/lighting/color by var in DECAL mode, and killed in REPLACE or MODULATE mode."""

    CLAMP_TEXTURE: UpdatePart.TextureWrapMode.ValueType = ...  # 2
    """Like GL_CLAMP_TO_EDGE"""


    class _TextureApplyMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TextureApplyModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TextureApplyMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        REPLACE: UpdatePart.TextureApplyMode.ValueType = ...  # 0
        """2D texture color replaces all other color.  No lighting.  Same as DECAL unless wrap mode is CLAMP."""

        DECAL: UpdatePart.TextureApplyMode.ValueType = ...  # 1
        """2D texture color replaces all other color.  No lighting."""

        MODULATE: UpdatePart.TextureApplyMode.ValueType = ...  # 2
        """Color as usual with part color, lighting, color by var, etc.  Then multiply by the 2D texture color."""

    class TextureApplyMode(_TextureApplyMode, metaclass=_TextureApplyModeEnumTypeWrapper):
        """2D texture options for combining texture color with part color, lighting, color by var"""
        pass

    REPLACE: UpdatePart.TextureApplyMode.ValueType = ...  # 0
    """2D texture color replaces all other color.  No lighting.  Same as DECAL unless wrap mode is CLAMP."""

    DECAL: UpdatePart.TextureApplyMode.ValueType = ...  # 1
    """2D texture color replaces all other color.  No lighting."""

    MODULATE: UpdatePart.TextureApplyMode.ValueType = ...  # 2
    """Color as usual with part color, lighting, color by var, etc.  Then multiply by the 2D texture color."""


    class _TextureSampleMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TextureSampleModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TextureSampleMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NEAREST: UpdatePart.TextureSampleMode.ValueType = ...  # 0
        """Like GL_NEAREST"""

        LINEAR: UpdatePart.TextureSampleMode.ValueType = ...  # 1
        """Like GL_LINEAR"""

    class TextureSampleMode(_TextureSampleMode, metaclass=_TextureSampleModeEnumTypeWrapper):
        """2D texture interpolation"""
        pass

    NEAREST: UpdatePart.TextureSampleMode.ValueType = ...  # 0
    """Like GL_NEAREST"""

    LINEAR: UpdatePart.TextureSampleMode.ValueType = ...  # 1
    """Like GL_LINEAR"""


    ID_FIELD_NUMBER: builtins.int
    PARENT_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    MATRIX4X4_FIELD_NUMBER: builtins.int
    FILL_COLOR_FIELD_NUMBER: builtins.int
    LINE_COLOR_FIELD_NUMBER: builtins.int
    RENDER_FIELD_NUMBER: builtins.int
    SHADING_FIELD_NUMBER: builtins.int
    AMBIENT_FIELD_NUMBER: builtins.int
    DIFFUSE_FIELD_NUMBER: builtins.int
    SPECULAR_SHINE_FIELD_NUMBER: builtins.int
    SPECULAR_INTENSITY_FIELD_NUMBER: builtins.int
    MATERIAL_NAME_FIELD_NUMBER: builtins.int
    NODE_SIZE_DEFAULT_FIELD_NUMBER: builtins.int
    COLOR_VARIABLEID_FIELD_NUMBER: builtins.int
    ALPHA_VARIABLEID_FIELD_NUMBER: builtins.int
    NODE_SIZE_VARIABLEID_FIELD_NUMBER: builtins.int
    DISPLACEMENT_VARIABLEID_FIELD_NUMBER: builtins.int
    TEXTURE_ID_FIELD_NUMBER: builtins.int
    TEXTURE_WRAP_MODE_FIELD_NUMBER: builtins.int
    TEXTURE_APPLY_MODE_FIELD_NUMBER: builtins.int
    TEXTURE_SAMPLE_MODE_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """The Part entity id"""

    parent_id: builtins.int = ...
    """Parent Group id"""

    name: typing.Text = ...
    """The name of the Part"""

    @property
    def matrix4x4(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Rigid body motion"""
        pass
    @property
    def fill_color(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Base color for the part (rgba).  If color_variableid is not set, draw the part with this RGB.  Even if color_variableid is set, combine RGB from color_variableid with A in fill_color."""
        pass
    @property
    def line_color(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Used for rendering line connectivity and element boundaries if edgeflags are specified"""
        pass
    render: global___UpdatePart.RenderingMode.ValueType = ...
    """What to aspect of the mesh to render"""

    shading: global___UpdatePart.ShadingMode.ValueType = ...
    """Defines the location of the normals.  If normals are specified per-element, triangles should be shaded as "flat" """

    ambient: builtins.float = ...
    """OpenGL style ambient coloring factor: GL_AMBIENT"""

    diffuse: builtins.float = ...
    """OpenGL style diffuse coloring rgb: GL_DIFFUSE"""

    specular_shine: builtins.float = ...
    """OpenGL style specular factor: GL_SHININESS"""

    specular_intensity: builtins.float = ...
    """OpenGL style specular factor: GL_SPECULAR"""

    material_name: typing.Text = ...
    """The material name specification"""

    node_size_default: builtins.float = ...
    """If node rendering is specified, the base size of each node"""

    color_variableid: builtins.int = ...
    """per-node or per-element coloring specification"""

    alpha_variableid: builtins.int = ...
    """If this is set, transparency varies over the part, and comes from the alpha channel for alpha_variableid.  It supercedes the alpha value in fill_color."""

    node_size_variableid: builtins.int = ...
    """If the 'render' variable has 'NODES' set, the size of rendered points can vary by the value of a variable instead of the node_size_default."""

    displacement_variableid: builtins.int = ...
    """if this is set, the vector variable should be added to the coordinate variable to generate the final coordinate."""

    texture_id: builtins.int = ...
    """2D texture to apply."""

    texture_wrap_mode: global___UpdatePart.TextureWrapMode.ValueType = ...
    """2D texture wrapping options"""

    texture_apply_mode: global___UpdatePart.TextureApplyMode.ValueType = ...
    """2D texture color blending options"""

    texture_sample_mode: global___UpdatePart.TextureSampleMode.ValueType = ...
    """2D texture sampling options"""

    hash: typing.Text = ...
    """hash for this message payload"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        parent_id : builtins.int = ...,
        name : typing.Text = ...,
        matrix4x4 : typing.Optional[typing.Iterable[builtins.float]] = ...,
        fill_color : typing.Optional[typing.Iterable[builtins.float]] = ...,
        line_color : typing.Optional[typing.Iterable[builtins.float]] = ...,
        render : global___UpdatePart.RenderingMode.ValueType = ...,
        shading : global___UpdatePart.ShadingMode.ValueType = ...,
        ambient : builtins.float = ...,
        diffuse : builtins.float = ...,
        specular_shine : builtins.float = ...,
        specular_intensity : builtins.float = ...,
        material_name : typing.Text = ...,
        node_size_default : builtins.float = ...,
        color_variableid : builtins.int = ...,
        alpha_variableid : builtins.int = ...,
        node_size_variableid : builtins.int = ...,
        displacement_variableid : builtins.int = ...,
        texture_id : builtins.int = ...,
        texture_wrap_mode : global___UpdatePart.TextureWrapMode.ValueType = ...,
        texture_apply_mode : global___UpdatePart.TextureApplyMode.ValueType = ...,
        texture_sample_mode : global___UpdatePart.TextureSampleMode.ValueType = ...,
        hash : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["alpha_variableid",b"alpha_variableid","ambient",b"ambient","color_variableid",b"color_variableid","diffuse",b"diffuse","displacement_variableid",b"displacement_variableid","fill_color",b"fill_color","hash",b"hash","id",b"id","line_color",b"line_color","material_name",b"material_name","matrix4x4",b"matrix4x4","name",b"name","node_size_default",b"node_size_default","node_size_variableid",b"node_size_variableid","parent_id",b"parent_id","render",b"render","shading",b"shading","specular_intensity",b"specular_intensity","specular_shine",b"specular_shine","texture_apply_mode",b"texture_apply_mode","texture_id",b"texture_id","texture_sample_mode",b"texture_sample_mode","texture_wrap_mode",b"texture_wrap_mode"]) -> None: ...
global___UpdatePart = UpdatePart

class UpdateGroup(google.protobuf.message.Message):
    """@brief Update a Group entity
    
    Sent to update a group entity.  The group is a simple entity serving as the basic "tree"
    node.
    
    The attributes are open for various uses, but several attribute key values have already been
    defined:
    
    [EnSight Units]: https://nexusdemo.ensight.com/docs/python/html/ENS_UNITSSchema.html#TOC-ENS_UNITS_SYSTEM "EnSight Units System"
    
    Attribute | Value
    --------- | -----
    ENS_OBJ_TYPE | The EnSight object type associated with this Group entity (e.g. "ENS_PART", "ENS_CASE", "ENS_VAR").
    ENS_OBJ_ID | The EnSight object ID associated with the Group entity.
    ENS_UNITS_SYSTEM | The unit system for the a specific ENS_CASE.  Encoded in JSON.  An example would be: '{"system":"SI","label":"Metric SI","M":"kg","L":"m","T":"s","K":"K","Q":"A","D":"rad","I":"cd","A":"mol"}'.  See also [EnSight Units].
    ENS_CASE_DATAFORMAT | The EnSight data reader used to load this portion of the tree.  An example would be: 'Fluent'.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class AttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    PARENT_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    MATRIX4X4_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """The Group entity id"""

    parent_id: builtins.int = ...
    """Parent Group or View id"""

    name: typing.Text = ...
    """The name of the Group"""

    @property
    def matrix4x4(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """A 4x4 transformation matrix"""
        pass
    @property
    def attributes(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """General attributes associated with this Group"""
        pass
    hash: typing.Text = ...
    """hash for this message payload"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        parent_id : builtins.int = ...,
        name : typing.Text = ...,
        matrix4x4 : typing.Optional[typing.Iterable[builtins.float]] = ...,
        attributes : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        hash : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["attributes",b"attributes","hash",b"hash","id",b"id","matrix4x4",b"matrix4x4","name",b"name","parent_id",b"parent_id"]) -> None: ...
global___UpdateGroup = UpdateGroup

class UpdateGeom(google.protobuf.message.Message):
    """@brief Update a Geom entity
    
    The geom entity holds the physical arrays used for rendering.
    It contains a coordinate array and connectivity that is relative to the coordinate array
    for this geom.  The connectivity can be triangles, lines or empty (points).
    If triangles, optional edgeflags specify the "line" representation of the triangles (for element outlining)
    Otherwise, the geom object can hold the data payloads for other variables tagged via their variable id.
    The use of these variables is dictated by fields in the Part entity that note the use of specific
    variables for other purposes (e.g. normals, coloring, node size, etc).
    Multiple UpdateGeom packets are send to fill in an entire array, limited by the size specified 
    in the init command.  All Geom packets for a specific array will include the full size of the
    target array (in base type units, uint32 or float) and an offset where the payload of a specific
    UpdateGeom packet should be stored in the array.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ArrayType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ArrayTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ArrayType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        COORDINATES: UpdateGeom.ArrayType.ValueType = ...  # 0
        """x1,y1,z1,x2,y2,z2 ..."""

        TRIANGLES: UpdateGeom.ArrayType.ValueType = ...  # 1
        """3*uint32 per triangle (zero based)"""

        LINES: UpdateGeom.ArrayType.ValueType = ...  # 2
        """2*uint32 per line segment (zero based)"""

        EDGEFLAGS: UpdateGeom.ArrayType.ValueType = ...  # 3
        """uint32 per element (only used with triangles)"""

        ELEM_VARIABLE: UpdateGeom.ArrayType.ValueType = ...  # 4
        """per element 1D variable values from the variable_id"""

        NODE_VARIABLE: UpdateGeom.ArrayType.ValueType = ...  # 5
        """per node 1D variable values from the variable_id"""

        ELEM_NORMALS: UpdateGeom.ArrayType.ValueType = ...  # 6
        """x1,y1,z1,x2,y2,z2 ..."""

        NODE_NORMALS: UpdateGeom.ArrayType.ValueType = ...  # 7
        """x1,y1,z1,x2,y2,z2 ..."""

        TEX_COORDINATES: UpdateGeom.ArrayType.ValueType = ...  # 8
        """2*float, always per vertex, u1,v1,u2,v2 ..."""

    class ArrayType(_ArrayType, metaclass=_ArrayTypeEnumTypeWrapper):
        """The type of array the Geom represents"""
        pass

    COORDINATES: UpdateGeom.ArrayType.ValueType = ...  # 0
    """x1,y1,z1,x2,y2,z2 ..."""

    TRIANGLES: UpdateGeom.ArrayType.ValueType = ...  # 1
    """3*uint32 per triangle (zero based)"""

    LINES: UpdateGeom.ArrayType.ValueType = ...  # 2
    """2*uint32 per line segment (zero based)"""

    EDGEFLAGS: UpdateGeom.ArrayType.ValueType = ...  # 3
    """uint32 per element (only used with triangles)"""

    ELEM_VARIABLE: UpdateGeom.ArrayType.ValueType = ...  # 4
    """per element 1D variable values from the variable_id"""

    NODE_VARIABLE: UpdateGeom.ArrayType.ValueType = ...  # 5
    """per node 1D variable values from the variable_id"""

    ELEM_NORMALS: UpdateGeom.ArrayType.ValueType = ...  # 6
    """x1,y1,z1,x2,y2,z2 ..."""

    NODE_NORMALS: UpdateGeom.ArrayType.ValueType = ...  # 7
    """x1,y1,z1,x2,y2,z2 ..."""

    TEX_COORDINATES: UpdateGeom.ArrayType.ValueType = ...  # 8
    """2*float, always per vertex, u1,v1,u2,v2 ..."""


    ID_FIELD_NUMBER: builtins.int
    PARENT_ID_FIELD_NUMBER: builtins.int
    PAYLOAD_TYPE_FIELD_NUMBER: builtins.int
    VARIABLE_ID_FIELD_NUMBER: builtins.int
    FLT_ARRAY_FIELD_NUMBER: builtins.int
    INT_ARRAY_FIELD_NUMBER: builtins.int
    CHUNK_OFFSET_FIELD_NUMBER: builtins.int
    TOTAL_ARRAY_SIZE_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """The Geom entity id"""

    parent_id: builtins.int = ...
    """Parent Part entity id"""

    payload_type: global___UpdateGeom.ArrayType.ValueType = ...
    """The type of the array represented by this entity"""

    variable_id: builtins.int = ...
    """If the ArrayType is VARIABLE, this is the associated entity id of a Variable"""

    @property
    def flt_array(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Used when payload_type is VARIABLE or COORDINATES"""
        pass
    @property
    def int_array(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Used when payload_type is TRIANGLES, LINES or EDGEFLAGS"""
        pass
    chunk_offset: builtins.int = ...
    """The offset in "elements" (floats, uint32, etc) of the array represented by this Geom"""

    total_array_size: builtins.int = ...
    """The total size in "elements" (floats, uint32, etc) of the array represented by this Geom"""

    hash: typing.Text = ...
    """hash for this message payload"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        parent_id : builtins.int = ...,
        payload_type : global___UpdateGeom.ArrayType.ValueType = ...,
        variable_id : builtins.int = ...,
        flt_array : typing.Optional[typing.Iterable[builtins.float]] = ...,
        int_array : typing.Optional[typing.Iterable[builtins.int]] = ...,
        chunk_offset : builtins.int = ...,
        total_array_size : builtins.int = ...,
        hash : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunk_offset",b"chunk_offset","flt_array",b"flt_array","hash",b"hash","id",b"id","int_array",b"int_array","parent_id",b"parent_id","payload_type",b"payload_type","total_array_size",b"total_array_size","variable_id",b"variable_id"]) -> None: ...
global___UpdateGeom = UpdateGeom

class VariableLevel(google.protobuf.message.Message):
    """@brief A "knot" point in the palette for the Variable
    
    This message maps a variable value to a specific color.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VALUE_FIELD_NUMBER: builtins.int
    RED_FIELD_NUMBER: builtins.int
    GREEN_FIELD_NUMBER: builtins.int
    BLUE_FIELD_NUMBER: builtins.int
    ALPHA_FIELD_NUMBER: builtins.int
    value: builtins.float = ...
    """The variable value the color is associated with"""

    red: builtins.float = ...
    """Red   [0, 1]"""

    green: builtins.float = ...
    """Green [0, 1]"""

    blue: builtins.float = ...
    """Blue  [0, 1]"""

    alpha: builtins.float = ...
    """Alpha [0, 1]"""

    def __init__(self,
        *,
        value : builtins.float = ...,
        red : builtins.float = ...,
        green : builtins.float = ...,
        blue : builtins.float = ...,
        alpha : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["alpha",b"alpha","blue",b"blue","green",b"green","red",b"red","value",b"value"]) -> None: ...
global___VariableLevel = VariableLevel

class UpdateVariable(google.protobuf.message.Message):
    """@brief Update a Variable entity
    
    General meta data about a variable, and about how to color by that variable.
    All parts colored by a the same variable in EnSight use the same palette, same var range, etc.
    
    The attributes are open for various uses, but several attribute key values have already been
    defined:
    
    [EnSight Units]: https://nexusdemo.ensight.com/docs/python/html/ENS_UNITSSchema.html#TOC-ENS_UNITS_SYSTEM "EnSight Units System"
    
    Attribute | Value
    --------- | -----
    ENS_OBJ_TYPE | The EnSight object type associated with this Group entity (e.g. "ENS_PART", "ENS_CASE", "ENS_VAR").
    ENS_OBJ_ID | The EnSight object ID associated with the Group entity.
    ENS_UNITS_DIMS | The unit dimensionality for the a specific ENS_VAR.  An example for a pressure variable would be: 'M/LTT'.  See also [EnSight Units].
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _VarLocation:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VarLocationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_VarLocation.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NODAL: UpdateVariable.VarLocation.ValueType = ...  # 0
        """The variable is specified per mesh node"""

        ELEMENTAL: UpdateVariable.VarLocation.ValueType = ...  # 1
        """The variable is specified per mesh element (e.g. triangle)"""

    class VarLocation(_VarLocation, metaclass=_VarLocationEnumTypeWrapper):
        """@brief Declare where a variable is defined to exist
        
        Variables can located at each node or element of the mesh.
        """
        pass

    NODAL: UpdateVariable.VarLocation.ValueType = ...  # 0
    """The variable is specified per mesh node"""

    ELEMENTAL: UpdateVariable.VarLocation.ValueType = ...  # 1
    """The variable is specified per mesh element (e.g. triangle)"""


    class _VarDimension:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VarDimensionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_VarDimension.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SCALAR: UpdateVariable.VarDimension.ValueType = ...  # 0
        """The variable has one value per location"""

        VECTOR: UpdateVariable.VarDimension.ValueType = ...  # 1
        """The variable has three values per location"""

    class VarDimension(_VarDimension, metaclass=_VarDimensionEnumTypeWrapper):
        """@brief Declare the variable dimension
        
        Variables can either be a single float (SCALAR) per observed location or
        a 3 float vector (VECTOR).
        """
        pass

    SCALAR: UpdateVariable.VarDimension.ValueType = ...  # 0
    """The variable has one value per location"""

    VECTOR: UpdateVariable.VarDimension.ValueType = ...  # 1
    """The variable has three values per location"""


    class _PaletteInterpolation:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PaletteInterpolationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PaletteInterpolation.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        CONTINUOUS: UpdateVariable.PaletteInterpolation.ValueType = ...  # 0
        """The interpolation of the variable palette is linear"""

        BANDED: UpdateVariable.PaletteInterpolation.ValueType = ...  # 1
        """The interpolation of the variable palette is a step function"""

    class PaletteInterpolation(_PaletteInterpolation, metaclass=_PaletteInterpolationEnumTypeWrapper):
        """@brief Palette interpolation options
        
        Specify if palette interpolation should be linear or stepwise.
        """
        pass

    CONTINUOUS: UpdateVariable.PaletteInterpolation.ValueType = ...  # 0
    """The interpolation of the variable palette is linear"""

    BANDED: UpdateVariable.PaletteInterpolation.ValueType = ...  # 1
    """The interpolation of the variable palette is a step function"""


    class _UndefinedDisplay:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _UndefinedDisplayEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_UndefinedDisplay.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        AS_ZERO: UpdateVariable.UndefinedDisplay.ValueType = ...  # 0
        """Draw 'undefined' as 0.0"""

        AS_INVISIBLE: UpdateVariable.UndefinedDisplay.ValueType = ...  # 1
        """Don't draw any pixels where the variable value is undefined."""

        USE_PART_COLOR: UpdateVariable.UndefinedDisplay.ValueType = ...  # 2
        """Draw 'undefined' areas using the 'fill_color' value on the part"""

        USE_UNDEF_COLOR: UpdateVariable.UndefinedDisplay.ValueType = ...  # 3
        """Draw 'undefined' areas using a color given below in undefined_color"""

    class UndefinedDisplay(_UndefinedDisplay, metaclass=_UndefinedDisplayEnumTypeWrapper):
        """@brief Undefined interpretation
        
        EnSight has a special float value indicating that the variable is undefined for a vertex or element.
        Options for drawing these elements are in the UndefinedDisplay enum.  The value that means 'undefined' is
        given below in undefined_value.  By default, the undefined value is -1.2345e-10.
        """
        pass

    AS_ZERO: UpdateVariable.UndefinedDisplay.ValueType = ...  # 0
    """Draw 'undefined' as 0.0"""

    AS_INVISIBLE: UpdateVariable.UndefinedDisplay.ValueType = ...  # 1
    """Don't draw any pixels where the variable value is undefined."""

    USE_PART_COLOR: UpdateVariable.UndefinedDisplay.ValueType = ...  # 2
    """Draw 'undefined' areas using the 'fill_color' value on the part"""

    USE_UNDEF_COLOR: UpdateVariable.UndefinedDisplay.ValueType = ...  # 3
    """Draw 'undefined' areas using a color given below in undefined_color"""


    class AttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    PARENT_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    DIMENSION_FIELD_NUMBER: builtins.int
    UNDEFINED_VALUE_FIELD_NUMBER: builtins.int
    PAL_INTERP_FIELD_NUMBER: builtins.int
    LEVELS_FIELD_NUMBER: builtins.int
    SUB_LEVELS_FIELD_NUMBER: builtins.int
    UNDEFINED_DISPLAY_FIELD_NUMBER: builtins.int
    UNDEFINED_COLOR_FIELD_NUMBER: builtins.int
    TEXTURE_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """The Variable entity id"""

    parent_id: builtins.int = ...
    """The parent scene id"""

    name: typing.Text = ...
    """The name of the variable"""

    location: global___UpdateVariable.VarLocation.ValueType = ...
    """The location of the variable"""

    dimension: global___UpdateVariable.VarDimension.ValueType = ...
    """The dimensionality of the variable"""

    undefined_value: builtins.float = ...
    """The float value that should be interpreted as "Undefined" """

    pal_interp: global___UpdateVariable.PaletteInterpolation.ValueType = ...
    """How the color palette specified by levels should be interpolated"""

    @property
    def levels(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VariableLevel]:
        """The color and var value at palette levels.  Lowest to highest."""
        pass
    sub_levels: builtins.int = ...
    """The number of "sub-levels" that might be used with BANDED interpolation. The total number of bands is (levels-1)*(sub_levels+1). The color in each level is used on the band at and above the level value, except for the last level's color, which is use on the band below it. Linearly interpolate in RGB space to get the colors of the bands between levels."""

    undefined_display: global___UpdateVariable.UndefinedDisplay.ValueType = ...
    """How should the undefined values be displayed."""

    @property
    def undefined_color(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """If undefined_display==USE_UNDEF_COLOR, rgb in [0,1] given here"""
        pass
    texture: builtins.bytes = ...
    """rgba pixel values (rrggbbaa 4 bytes/pixel) in [0,255].  For the color_variableid, use only the rgb portion of this texture. For the alpha_variableid, use only the 'a' portion of this texture.  levels[0].value should map to tex coord==0 for banded, 0.5 texel for continuous levels[levels.size()-1].value should map to tex coord==1 for banded, 1 - 0.5 texel for continuous."""

    @property
    def attributes(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """General attributes associated with this Variable"""
        pass
    hash: typing.Text = ...
    """hash for this message payload"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        parent_id : builtins.int = ...,
        name : typing.Text = ...,
        location : global___UpdateVariable.VarLocation.ValueType = ...,
        dimension : global___UpdateVariable.VarDimension.ValueType = ...,
        undefined_value : builtins.float = ...,
        pal_interp : global___UpdateVariable.PaletteInterpolation.ValueType = ...,
        levels : typing.Optional[typing.Iterable[global___VariableLevel]] = ...,
        sub_levels : builtins.int = ...,
        undefined_display : global___UpdateVariable.UndefinedDisplay.ValueType = ...,
        undefined_color : typing.Optional[typing.Iterable[builtins.float]] = ...,
        texture : builtins.bytes = ...,
        attributes : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        hash : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["attributes",b"attributes","dimension",b"dimension","hash",b"hash","id",b"id","levels",b"levels","location",b"location","name",b"name","pal_interp",b"pal_interp","parent_id",b"parent_id","sub_levels",b"sub_levels","texture",b"texture","undefined_color",b"undefined_color","undefined_display",b"undefined_display","undefined_value",b"undefined_value"]) -> None: ...
global___UpdateVariable = UpdateVariable

class UpdateTexture(google.protobuf.message.Message):
    """@brief Update a Texture entity
    
    Sent to update a 2D texture.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _TextureFormat:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TextureFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TextureFormat.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        RGB: UpdateTexture.TextureFormat.ValueType = ...  # 0
        RGBA: UpdateTexture.TextureFormat.ValueType = ...  # 1
    class TextureFormat(_TextureFormat, metaclass=_TextureFormatEnumTypeWrapper):
        """@brief Define the imaging format of a texture
        
        Texture images are always a single byte per component, but images can be
        RGB (three components) or RGBA (four components) per pixel. RGBA are the
        red, blue, green and alpha channels of the image.
        """
        pass

    RGB: UpdateTexture.TextureFormat.ValueType = ...  # 0
    RGBA: UpdateTexture.TextureFormat.ValueType = ...  # 1

    ID_FIELD_NUMBER: builtins.int
    PARENT_ID_FIELD_NUMBER: builtins.int
    FORMAT_FIELD_NUMBER: builtins.int
    WIDTH_FIELD_NUMBER: builtins.int
    HEIGHT_FIELD_NUMBER: builtins.int
    TEXELS_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """texture entity id"""

    parent_id: builtins.int = ...
    """scene entity id"""

    format: global___UpdateTexture.TextureFormat.ValueType = ...
    """RGB or RGBA"""

    width: builtins.int = ...
    """texture width.  not generally a power of 2"""

    height: builtins.int = ...
    """texture height.  not generally a power of 2"""

    texels: builtins.bytes = ...
    """packed RGB or RGBA values depending on 'format', in range [0,255]"""

    hash: typing.Text = ...
    """hash for this message payload"""

    def __init__(self,
        *,
        id : builtins.int = ...,
        parent_id : builtins.int = ...,
        format : global___UpdateTexture.TextureFormat.ValueType = ...,
        width : builtins.int = ...,
        height : builtins.int = ...,
        texels : builtins.bytes = ...,
        hash : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["format",b"format","hash",b"hash","height",b"height","id",b"id","parent_id",b"parent_id","texels",b"texels","width",b"width"]) -> None: ...
global___UpdateTexture = UpdateTexture

class SceneUpdateCommand(google.protobuf.message.Message):
    """@brief Aggregate command sent by EnSight to a client
    
    This command represents a union of a number of different commands: UpdateSceneBegin, 
    UpdateSceneEnd, DeleteID, UpdatePart, UpdateGroup, UpdateGeom, UpdateVariable and 
    UpdateView.  To use the message, set the command_type to the type of the message 
    and fill in the appropriate UpdateCommand sub-message.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _SceneUpdateCommandType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _SceneUpdateCommandTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SceneUpdateCommandType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UPDATE_SCENE_BEGIN: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 0
        """Marks the beginning of a scene update"""

        UPDATE_SCENE_END: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 1
        """Marks the completion of a scene update"""

        DELETE_ID: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 2
        """Tell the client to delete an entity ID that was defined in a previous scene update"""

        UPDATE_PART: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 3
        """Create/update a Part entity"""

        UPDATE_GROUP: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 4
        """Create/update a Group entity"""

        UPDATE_GEOM: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 5
        """Create/update a Geom entity"""

        UPDATE_VARIABLE: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 6
        """Create/update a Variable entity"""

        UPDATE_VIEW: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 7
        """Create/update a View entity"""

        UPDATE_TEXTURE: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 8
        """Create/update a Texture entity"""

    class SceneUpdateCommandType(_SceneUpdateCommandType, metaclass=_SceneUpdateCommandTypeEnumTypeWrapper):
        """@brief Specify the specific command type
        
        SceneUpdateCommand object can represent many different sub-commands, but
        packed into a common message.  The SceneUpdateCommandType is the specific
        sub-command type of the base message.
        """
        pass

    UPDATE_SCENE_BEGIN: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 0
    """Marks the beginning of a scene update"""

    UPDATE_SCENE_END: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 1
    """Marks the completion of a scene update"""

    DELETE_ID: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 2
    """Tell the client to delete an entity ID that was defined in a previous scene update"""

    UPDATE_PART: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 3
    """Create/update a Part entity"""

    UPDATE_GROUP: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 4
    """Create/update a Group entity"""

    UPDATE_GEOM: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 5
    """Create/update a Geom entity"""

    UPDATE_VARIABLE: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 6
    """Create/update a Variable entity"""

    UPDATE_VIEW: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 7
    """Create/update a View entity"""

    UPDATE_TEXTURE: SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...  # 8
    """Create/update a Texture entity"""


    COMMAND_TYPE_FIELD_NUMBER: builtins.int
    SCENE_BEGIN_FIELD_NUMBER: builtins.int
    SCENE_END_FIELD_NUMBER: builtins.int
    DELETE_ID_FIELD_NUMBER: builtins.int
    UPDATE_PART_FIELD_NUMBER: builtins.int
    UPDATE_GROUP_FIELD_NUMBER: builtins.int
    UPDATE_GEOM_FIELD_NUMBER: builtins.int
    UPDATE_VARIABLE_FIELD_NUMBER: builtins.int
    UPDATE_VIEW_FIELD_NUMBER: builtins.int
    UPDATE_TEXTURE_FIELD_NUMBER: builtins.int
    command_type: global___SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...
    """The update command type"""

    @property
    def scene_begin(self) -> global___UpdateSceneBegin:
        """Begin a scene update"""
        pass
    @property
    def scene_end(self) -> global___UpdateSceneEnd:
        """End a scene update"""
        pass
    @property
    def delete_id(self) -> global___DeleteID:
        """Delete a collection of entities from the cache"""
        pass
    @property
    def update_part(self) -> global___UpdatePart:
        """Update a Part entity"""
        pass
    @property
    def update_group(self) -> global___UpdateGroup:
        """Update a Group entity"""
        pass
    @property
    def update_geom(self) -> global___UpdateGeom:
        """Update a Geom entity"""
        pass
    @property
    def update_variable(self) -> global___UpdateVariable:
        """Update a Variable entity"""
        pass
    @property
    def update_view(self) -> global___UpdateView:
        """Update a View entity"""
        pass
    @property
    def update_texture(self) -> global___UpdateTexture:
        """Update a Texture entity"""
        pass
    def __init__(self,
        *,
        command_type : global___SceneUpdateCommand.SceneUpdateCommandType.ValueType = ...,
        scene_begin : typing.Optional[global___UpdateSceneBegin] = ...,
        scene_end : typing.Optional[global___UpdateSceneEnd] = ...,
        delete_id : typing.Optional[global___DeleteID] = ...,
        update_part : typing.Optional[global___UpdatePart] = ...,
        update_group : typing.Optional[global___UpdateGroup] = ...,
        update_geom : typing.Optional[global___UpdateGeom] = ...,
        update_variable : typing.Optional[global___UpdateVariable] = ...,
        update_view : typing.Optional[global___UpdateView] = ...,
        update_texture : typing.Optional[global___UpdateTexture] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["UpdateCommand",b"UpdateCommand","delete_id",b"delete_id","scene_begin",b"scene_begin","scene_end",b"scene_end","update_geom",b"update_geom","update_group",b"update_group","update_part",b"update_part","update_texture",b"update_texture","update_variable",b"update_variable","update_view",b"update_view"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["UpdateCommand",b"UpdateCommand","command_type",b"command_type","delete_id",b"delete_id","scene_begin",b"scene_begin","scene_end",b"scene_end","update_geom",b"update_geom","update_group",b"update_group","update_part",b"update_part","update_texture",b"update_texture","update_variable",b"update_variable","update_view",b"update_view"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["UpdateCommand",b"UpdateCommand"]) -> typing.Optional[typing_extensions.Literal["scene_begin","scene_end","delete_id","update_part","update_group","update_geom","update_variable","update_view","update_texture"]]: ...
global___SceneUpdateCommand = SceneUpdateCommand
