import aws_cdk as cdk
import aws_cdk.aws_s3
from constructs import Construct
from aws_cdk import (
    aws_s3 as _s3,
    aws_iam as _iam,
    aws_cognito as _cognito,
    aws_kms as _kms,
    aws_route53 as route53,
    aws_route53_targets as route53_targets,
    aws_cloudfront as _cloudfront,
    aws_cloudfront_origins as _cloudfront_origins,
    aws_certificatemanager as _certificate,
    aws_ec2 as _ec2,
)
from aws_cdk_constructs.bucket.edge_function import EdgeFunction
import boto3
from aws_cdk_constructs.utils import (
    normalize_environment_parameter,
    get_version,
)
from .auth_flow import AuthFlow, RedirectPaths
from .secret_generator import SecretGenerator
from .log_level import LogLevel
import aws_cdk.aws_cloudfront_origins as origins
from typing import Union, List, Dict
import os
from aws_cdk import aws_lambda, aws_cloudfront

dirname = os.path.dirname(__file__)


def check_if_bucket_exist(s3_bucket_name: str, profile: str = None) -> bool:
    aws_session = boto3.Session(profile_name=profile)
    sdk_s3 = aws_session.client('s3')
    bucket_exist = True

    if not s3_bucket_name:
        return False

    try:
        sdk_s3.get_bucket_location(Bucket=s3_bucket_name)
    except:
        bucket_exist = False

    return bucket_exist


class Bucket(Construct):
    """

    The FAO CDK Bucket Construct encapsulates different AWS S3 configurations and it is used, for example, when as a hosting server for static websites or to create auxiliary buckets to host static objects.

    The construct automatically enables the following main features:

    -	Configuration as static web hosting or private bucket;
    -	Configure a CloudFront distribution with Cognito integration to have protected static website hosting servers;
    -	Encrypt the AWS S3 bucket using FAO KMS keys when needed;
    -	Conditionally configure the bucket removal policy depending on the environment in which the construct is deployed. The policy will be set as `RETAIN` for the Production environment, otherwise set to `DESTROY`;
    -	Set the Bucket Access Control to `PRIVATE` and `BLOCK_ALL` public access unless explicitly specified that the bucket is public;
    -	When the bucket is configured to be publicly read, configure the CORS rules to enable `GET,` `POST,` `PUT,` `DELETE,` and `HEAD` methods from every origin;
    -	Enable private VPC access to the bucket, tuning the Bucket resource policy;
    -	Only enable access from the Cloudflare IP ranges when required;

    Every resource created by the construct will be tagged according to the FAO AWS tagging strategy described at https://aws.fao.org

    Args:

        id (str): the logical id of the newly created resource

        app_name (str): The application name. This will be used to generate the 'ApplicationName' tag for CSI compliance. The ID of the application. This must be unique for each system, as it will be used to calculate the AWS costs of the system

        environment (str): Specify the environment in which you want to deploy you system. Allowed values: Development, QA, Production, SharedServices

        environments_parameters (dict): The dictionary containing the references to CSI AWS environments. This will simplify the environment promotions and enable a parametric development of the infrastructures.

        bucket_name (str): The S3 Bucket in which the application S3 are stored. In case the bucket is configured to have CDN integrated with Cognito, this is also the CloudFront Distribution alias (i.e. the final domain of the website)

        bucket_is_public (str): Whether the S3 bucket should be public

        bucket_is_privately_accessed_from_vpc_over_http (str): Force the bucket to be private and enable HTTP private accessed from within the VPC. When this parameter is set to True, `bucket_is_public` and `bucket_has_cdn` will be forced to be False

        bucket_has_cdn (str): Whether the S3 bucket will be served by a Cloudflare CDN

        bucket_logic_id (str): The logical id of the S3 Bucket

        bucket_website_index_document (str): Use this parameter to configure the S3 bucket as Web Hosting. This is the S3 key of the index document of your static site (generally is index.html)

        bucket_website_error_document (str): Use this parameter to configure the S3 bucket as Web Hosting. This is the S3 key of the error document of your static site (generally is error.html)

        bucket_has_authentication (str): Create a CloudFront distribution integrated with Cognito, to enable authenticated access to the bucket

        bucket_is_encrypted (str): Whether this bucket should be encrypted. KMS is autogenerated. Default: None

        versioned (bool): Whether this bucket should have versioning turned on or not. Default: false

        encryption_allowed_principals_arns (list | str): A single ARN or an array of ARNs to be added as principal to the KMS encryption key policy of the bucket, when encrypted. These principals can utilize the key to interact with the encrypted bucket.

        bucket_enforces_ssl(str): Whether to enforce SSL for the CloudFront distribution. Default: false

        omit_cloudformation_template_outputs(bool): Omit the generation of CloudFormation template outputs. Default: false

        will_implement_cdn (str): Whether or not a CloudFront distribution should be deployed in front of the load balancer. Only applicable when an Application Load Balancer is in use

        cdn_domain_names ([str]): If "will_implement_cdn" is "True", it specifies the domain names to associate to the CloudFront distribution. Please make sure that tha provided domain names match the SSL certificate in use

        cdn_ssl_certificate_arn (str): If "will_implement_cdn" is "True" and you want to enable HTTPS for your CloudFront distribution, specify the SSL certificate ARN to use. NB: this certificate must be in North Virginia

        bucket_policy_statements: List[_iam.PolicyStatement]: List of policy statements to be added to the Bucket policy. Default: []
    """

    @property
    def bucket(self) -> aws_cdk.aws_s3.Bucket:
        """Returns the S3 bucket

        Returns:
            aws_s3.Bucket: the S3 bucket
        """
        return self._bucket

    @property
    def get_s3_bucket(self):
        """DEPRECATED: Returns the S3 bucket

        Returns:
            aws_s3.Bucket: the S3 bucket
        """

        raise DeprecationWarning(
            'This is a deprecated method, please do not use it. use Bucket.bucket attribute instead.'
        )

    @property
    def cloudfront_distribution(
        self,
    ) -> Union[_cloudfront.IDistribution, None]:
        """Returns the CloudFront distribution, if available

        Returns:
            aws_cloudfront.IDistribution: the Cloudfront distribution
        """
        return self._cloudfront_distribution

    def create_bucket(
        self,
        logic_id: str,
        bucket_name: str,
        app_name: str,
        access_control: aws_cdk.aws_s3.BucketAccessControl = None,
        public_read_access: bool = False,
        website_index_document: str = None,
        website_error_document: str = None,
        removal_policy: aws_cdk.RemovalPolicy = None,
        versioned: bool = False,
        is_encrypted: bool = False,
        encryption_allowed_principals_arns: Union[str, List[str]] = None,
        enforce_ssl: bool = False,
        **kwargs,
    ):
        raise DeprecationWarning(
            'This is a deprecated method, please do not use it. Instantiate a new FAI CDK Bucket construct instead.'
        )

    def update_distribution_origin_access(self):
        ## clean-up the OAI reference and associate the OAC with the cloudfront distribution
        # query the site bucket policy as a document
        bucket_policy = self.bucket.policy
        bucket_policy_document = bucket_policy.document

        # remove the CloudFront Origin Access Identity permission from the bucket policy
        if isinstance(bucket_policy_document, _iam.PolicyDocument):
            bucket_policy_document_json = bucket_policy_document.to_json()
            # create an updated policy without the OAI reference
            bucket_policy_updated_json = {
                'Version': '2012-10-17',
                'Statement': [],
            }
            for statement in bucket_policy_document_json['Statement']:
                if 'CanonicalUser' not in statement['Principal']:
                    bucket_policy_updated_json['Statement'].append(statement)

        # apply the updated bucket policy to the bucket
        bucket_policy_override = self.bucket.node.find_child(
            'Policy'
        ).node.default_child
        bucket_policy_override.add_override(
            'Properties.PolicyDocument', bucket_policy_updated_json
        )

        # remove the created OAI reference (S3 Origin property) for the distribution
        all_distribution_props = self.cloudfront_distribution.node.find_all()
        for child in all_distribution_props:
            if child.node.id == 'S3Origin':
                child.node.try_remove_child('Resource')

        # associate the created OAC with the distribution
        distribution_props = self.cloudfront_distribution.node.default_child

        # The amount of the distribution origins is equal to the number of direct CDK object
        # of the distribution construct - 1 (the Resource object)
        origins_amount = len(self.cloudfront_distribution.node.children) - 1

        for index in range(0, origins_amount):
            # A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is configured with static website hosting is a custom origin.
            distribution_props.add_override(
                f'Properties.DistributionConfig.Origins.{index}.S3OriginConfig.OriginAccessIdentity',
                '',
            )
            distribution_props.add_property_override(
                f'DistributionConfig.Origins.{index}.OriginAccessControlId',
                self._origin_access_control.ref,
            )

    def _create_cloudfront_distribution(
        self,
        bucket_name: str,
        cdn_ssl_certificate_arn: str,
        cdn_domain_names: List[str] = [],
        bucket_policy_statements: List[_iam.PolicyStatement] = [],
        default_behavior: _cloudfront.BehaviorOptions = None,
    ):

        # If not domain names are provided use the bucket name
        if not cdn_domain_names:
            cdn_domain_names = [bucket_name]

        distribution_id = f'distribution_{bucket_name}'
        self._cloudfront_distribution = _cloudfront.Distribution(
            self,
            distribution_id,
            default_behavior=default_behavior,
            default_root_object='index.html',
            certificate=_certificate.Certificate.from_certificate_arn(
                self,
                'https_certificate_cdn',
                certificate_arn=(
                    cdn_ssl_certificate_arn
                    if cdn_ssl_certificate_arn
                    else self.aws_account[
                        'ssl_certificate_star_fao_org_arn_north_virginia'
                    ]
                ),
            ),
            price_class=_cloudfront.PriceClass.PRICE_CLASS_100,
            domain_names=cdn_domain_names,
        )

        self._origin_access_control = _cloudfront.CfnOriginAccessControl(
            self,
            f'oac_{bucket_name}',
            origin_access_control_config=_cloudfront.CfnOriginAccessControl.OriginAccessControlConfigProperty(
                name=f'oac_{bucket_name}',
                origin_access_control_origin_type='s3',
                signing_behavior='always',
                signing_protocol='sigv4',
            ),
        )

        cloudfront_distribution_arn = (
            f'arn:aws:cloudfront::'
            + self.aws_account['id']
            + f':distribution/{self._cloudfront_distribution.distribution_id}'
        )
        bucket_statement = _iam.PolicyStatement(
            principals=[_iam.ServicePrincipal('cloudfront.amazonaws.com')],
            actions=['s3:GetObject'],
            resources=[f'{self.bucket.bucket_arn}/*'],
            conditions={
                'StringEquals': {'aws:sourceArn': cloudfront_distribution_arn}
            },
        )

        self.bucket.add_to_resource_policy(bucket_statement)

        # Add custom policy statements to bucket policy
        for statement in bucket_policy_statements:
            self.bucket.add_to_resource_policy(statement)

        return self._cloudfront_distribution

    def _create_bucket(
        self,
        logic_id: str,
        bucket_name: str,
        app_name: str,
        public_read_access: bool = False,
        website_index_document: str = None,
        website_error_document: str = None,
        removal_policy: aws_cdk.RemovalPolicy = None,
        versioned: bool = False,
        is_encrypted: bool = False,
        encryption_allowed_principals_arns: Union[str, List[str]] = None,
        enforce_ssl: bool = False,
        **kwargs,
    ) -> aws_cdk.aws_s3.Bucket:
        """Create an S3 bucket

        Args:

            logic_id (str): The logical ID of the S3 Bucket

            bucket_name (str): The S3 Bucket name

            app_name (str): The application name. This will be used to generate the 'ApplicationName' tag for CSI compliance. The ID of the application. This must be unique for each system, as it will be used to calculate the AWS costs of the system

            public_read_access (bool): Whether the S3 Bucket should be public or not

            website_index_document (str): Use this parameter to configure the S3 bucket as Web Hosting. This is the S3 key of the index document of your static site (generally is index.html)

            website_error_document (str): Use this parameter to configure the S3 bucket as Web Hosting. This is the S3 key of the error document of your static site (generally is error.html)

            removal_policy (aws_cdk. cdk.RemovalPolicy): The S3 Bucket removal policy. For more info see `removal_policy` in https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.aws_s3/Bucket.html

            versioned (Bool): Whether this bucket should have versioning turned on or not. Default: false

            is_encrypted (Bool): Whether this bucket should be encrypted. KMS is autogenerated. Default: false

            encryption_allowed_principals_arns (list | str): A single ARN or an array of ARNs to be added as principal to the KMS encryption key policy of the bucket, when encrypted. These principals can utilize the key to interact with the encrypted bucket.

            enforce_ssl(Bool): Whether to enforce SSL for the CloudFront distribution. Default: false

            will_implement_cdn (str): Whether or not a CloudFront distribution should be deployed in front of the load balancer. Only applicable when an Application Load Balancer is in use

            cdn_domain_names ([str]): If "will_implement_cdn" is "True", it specifies the domain names to associate to the CloudFront distribution. Please make sure that tha provided domain names match the SSL certificate in use

            cdn_ssl_certificate_arn (str): If "will_implement_cdn" is "True" and you want to enable HTTPS for your CloudFront distribution, specify the SSL certificate ARN to use. NB: this certificate must be in North Virginia

            bucket_policy_statements: List[_iam.PolicyStatement]: List of policy statements to be added to the Bucket policy. Default: []

            distribution_domain_name: Union[str, None]: The domain name of the CloudFront distribution, if available. Default is the 'bucket_name'

            distribution_response_headers_policy: Union[_cloudfront.ResponseHeadersPolicy, None]: The response headers policy of the CloudFront distribution, if available. Default is None
        Returns:
            aws_s3.Bucket: the S3 bucket
        """
        object_ownership = None
        if not public_read_access:
            object_ownership = _s3.ObjectOwnership.BUCKET_OWNER_PREFERRED

        # Create S3 bucket
        s3_bucket = _s3.Bucket(
            self,
            logic_id,
            bucket_name=bucket_name,
            public_read_access=public_read_access,
            website_index_document=website_index_document,
            website_error_document=website_error_document,
            removal_policy=removal_policy,
            versioned=versioned,
            encryption=_s3.BucketEncryption.KMS if is_encrypted else None,
            enforce_ssl=enforce_ssl,
            # Whether all objects should be automatically deleted when the bucket is removed from the stack or when the stack is deleted
            auto_delete_objects=not self.is_production,
            object_ownership=object_ownership,
        )

        if is_encrypted:
            key = s3_bucket.node.find_child('Key')
            _kms.Alias(
                self,
                logic_id + 'kmskeyalias',
                alias_name=app_name + '-' + logic_id,
                target_key=key,
            )

            if encryption_allowed_principals_arns:
                encryption_bucket_policy = _iam.PolicyStatement(
                    actions=[
                        'kms:Create*',
                        'kms:Describe*',
                        'kms:Decrypt',
                        'kms:Enable*',
                        'kms:List*',
                        'kms:Put*',
                        'kms:Update*',
                        'kms:Revoke*',
                        'kms:Disable*',
                        'kms:Get*',
                        'kms:Delete*',
                        'kms:ScheduleKeyDeletion',
                        'kms:CancelKeyDeletion',
                        'kms:GenerateDataKey',
                        'kms:TagResource',
                        'kms:UntagResource',
                    ],
                    resources=['*'],
                )

                # Check if `encryption_allowed_principals_arns` is an array, otherwise convert it
                if not isinstance(encryption_allowed_principals_arns, list):
                    encryption_allowed_principals_arns = [
                        encryption_allowed_principals_arns
                    ]

                # Loop over the arns arrays and add them all to the statement
                for arns in encryption_allowed_principals_arns:
                    encryption_bucket_policy.add_arn_principal(arns)

                key.add_to_resource_policy(statement=encryption_bucket_policy)

        cdk.Tags.of(s3_bucket).add(
            'ApplicationName',
            app_name,
        )

        # Create DNS record
        if not self.is_production and website_index_document:
            hosted_zone_id = self.aws_account['route53_hosted_zone_id']
            domain_name = self.aws_account['route53_domain_name']

            dns_record = bucket_name.replace(f'.{domain_name}', '')
            self.route53_zone = (
                route53.PrivateHostedZone.from_hosted_zone_attributes(
                    self,
                    f'PrivateHostedZone{dns_record}',
                    hosted_zone_id=hosted_zone_id,
                    zone_name=domain_name,
                )
            )

            route53.ARecord(
                self,
                f'S3BucketAliasRecord{dns_record}',
                zone=self.route53_zone,
                target=route53.RecordTarget.from_alias(
                    route53_targets.BucketWebsiteTarget(s3_bucket)
                ),
                record_name=f'{dns_record}.{domain_name}',
            )

        return s3_bucket

    def __init__(
        self,
        scope: Construct,
        id: str,
        app_name: str,
        environment: str,
        environments_parameters: Dict,
        bucket_name: str,
        bucket_logic_id: str = None,
        bucket_is_public: str = None,
        bucket_has_cdn: str = None,
        bucket_website_index_document: str = None,
        bucket_website_error_document: str = None,
        bucket_is_privately_accessed_from_vpc_over_http: bool = False,
        bucket_has_authentication: str = None,
        bucket_is_encrypted: str = None,
        versioned: bool = False,
        encryption_allowed_principals_arns: Union[str, List[str]] = None,
        bucket_enforces_ssl: bool = False,
        omit_cloudformation_template_outputs: bool = False,
        will_implement_cdn: str = 'false',
        cdn_domain_names: List[str] = [],
        cdn_ssl_certificate_arn: str = None,
        bucket_policy_statements: List[_iam.PolicyStatement] = [],
        distribution_domain_name: Union[str, None] = None,
        distribution_response_headers_policy: Union[
            _cloudfront.ResponseHeadersPolicy, None
        ] = None,
        user_pool_client: Union[None, _cognito.UserPoolClient] = None,
        **kwargs,
    ) -> None:
        super().__init__(scope, id, **kwargs)
        environment = normalize_environment_parameter(environment)
        app_name = app_name.lower().strip()

        # Apply mandatory tags
        cdk.Tags.of(self).add('ApplicationName', app_name)
        cdk.Tags.of(self).add('Environment', environment)

        # Apply FAO CDK tags
        cdk.Tags.of(self).add('fao-cdk-construct', 'bucket')
        cdk.Tags.of(cdk.Stack.of(self)).add('fao-cdk-version', get_version())
        cdk.Tags.of(cdk.Stack.of(self)).add('fao-cdk', 'true')

        # Declare variables
        environment = environment.lower()
        self.environment = environment
        self.aws_account = environments_parameters['accounts'][environment]
        logic_id = bucket_logic_id if bucket_logic_id else 'S3'

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Create conditions

        # Check if bucket has to be public
        public_read_access = (
            bucket_is_public
            and isinstance(bucket_is_public, str)
            and bucket_is_public.lower() == 'true'
        )

        include_cdn = (
            bucket_has_cdn
            and isinstance(bucket_has_cdn, str)
            and bucket_has_cdn.lower() == 'true'
        )

        has_authentication = (
            bucket_has_authentication
            and isinstance(bucket_has_authentication, str)
            and bucket_has_authentication.lower() == 'true'
        )

        self.is_production = environment.lower().strip() == 'production'

        is_encrypted = (
            bucket_is_encrypted
            and isinstance(bucket_is_encrypted, str)
            and bucket_is_encrypted.lower() == 'true'
        )

        enforce_ssl = (
            bucket_enforces_ssl
            and isinstance(bucket_enforces_ssl, str)
            and bucket_enforces_ssl.lower() == 'true'
        )

        create_cdn = (
            will_implement_cdn
            and isinstance(will_implement_cdn, str)
            and will_implement_cdn.lower() == 'true'
        )

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CloudFormation outputs
        if not omit_cloudformation_template_outputs:
            cdk.CfnOutput(
                self,
                f'BucketAppName{app_name}{bucket_name}',
                value=str(app_name),
            )
            cdk.CfnOutput(
                self,
                f'BucketPublicReadAccess{app_name}{bucket_name}',
                value=str(public_read_access),
            )
            cdk.CfnOutput(
                self,
                f'BucketIncludesCdn{app_name}{bucket_name}',
                value=str(include_cdn),
            )
            cdk.CfnOutput(
                self,
                f'BucketHasAuthentication{app_name}{bucket_name}',
                value=str(has_authentication),
            )
            cdk.CfnOutput(
                self,
                f'BucketIsEncrypted{app_name}{bucket_name}',
                value=str(is_encrypted),
            )
            cdk.CfnOutput(
                self,
                f'BucketBucketName{app_name}{bucket_name}',
                value=str(bucket_name),
            )

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Conditionally create resources

        # Only retain production bucket, with public assets
        removal_policy = cdk.RemovalPolicy.DESTROY
        if self.is_production and public_read_access:
            removal_policy = cdk.RemovalPolicy.RETAIN

        # Default access level: PRIVATE
        self._bucket = self._create_bucket(
            logic_id=logic_id,
            app_name=app_name,
            bucket_name=bucket_name,
            website_index_document=bucket_website_index_document,
            website_error_document=bucket_website_error_document,
            removal_policy=removal_policy,
            block_public_access=(
                _s3.BlockPublicAccess.BLOCK_ALL
                if not public_read_access
                else _s3.BlockPublicAccess(
                    block_public_acls=False,
                    block_public_policy=False,
                    ignore_public_acls=False,
                    restrict_public_buckets=False,
                )
            ),
            versioned=versioned,
            is_encrypted=is_encrypted,
            encryption_allowed_principals_arns=encryption_allowed_principals_arns,
            enforce_ssl=enforce_ssl,
            will_implement_cdn=will_implement_cdn,
            cdn_domain_names=cdn_domain_names,
            cdn_ssl_certificate_arn=cdn_ssl_certificate_arn,
            bucket_policy_statements=bucket_policy_statements,
        )

        if bucket_is_privately_accessed_from_vpc_over_http:
            # Force public read to false
            public_read_access = False
            bucket_has_cdn = False

            self._bucket.add_to_resource_policy(
                _iam.PolicyStatement(
                    principals=[_iam.AnyPrincipal()],
                    actions=['s3:GetObject'],
                    resources=[
                        'arn:aws:s3:::' + bucket_name,
                        'arn:aws:s3:::' + bucket_name + '/*',
                    ],
                    conditions={
                        'StringEquals': {
                            'aws:sourceVpc': self.aws_account['vpc']
                        }
                    },
                )
            )

        if public_read_access:
            # Grant access to anyone
            self._bucket.grant_public_access()

            # Temporary fix for:
            # https://github.com/aws/aws-cdk/issues/25358
            s3_resource = self._bucket.node.default_child
            s3_resource.add_override(
                'Properties.PublicAccessBlockConfiguration.BlockPublicPolicy',
                'False',
            )

            self._bucket.add_cors_rule(
                allowed_methods=[
                    _s3.HttpMethods.GET,
                    _s3.HttpMethods.POST,
                    _s3.HttpMethods.PUT,
                    _s3.HttpMethods.DELETE,
                    _s3.HttpMethods.HEAD,
                ],
                allowed_origins=['*'],
                allowed_headers=['*'],
            )

        # Limit access to Cloudflare
        if include_cdn:
            # Cloudflare doc https://support.cloudflare.com/hc/en-us/articles/360037983412-Configuring-an-Amazon-Web-Services-static-site-to-use-Cloudflare
            cloudflare_ips = [
                '173.245.48.0/20',
                '103.21.244.0/22',
                '103.22.200.0/22',
                '103.31.4.0/22',
                '141.101.64.0/18',
                '108.162.192.0/18',
                '190.93.240.0/20',
                '188.114.96.0/20',
                '197.234.240.0/22',
                '198.41.128.0/17',
                '162.158.0.0/15',
                '104.16.0.0/13',
                '104.24.0.0/14',
                '172.64.0.0/13',
                '131.0.72.0/22',
                '2400:cb00::/32',
                '2606:4700::/32',
                '2803:f800::/32',
                '2405:b500::/32',
                '2405:8100::/32',
                '2a06:98c0::/29',
                '2c0f:f248::/32',
            ]

            # Retrieve VPC CIDR from ID
            vpc_id = self.aws_account['vpc']
            self._vpc = _ec2.Vpc.from_lookup(
                self,
                'VPC',
                vpc_id=vpc_id,
            )
            vpc_cidr = self._vpc.vpc_cidr_block

            # Only allow access from Cloudflare IPs
            self._bucket.add_to_resource_policy(
                _iam.PolicyStatement(
                    effect=_iam.Effect.DENY,
                    principals=[_iam.AnyPrincipal()],
                    actions=['s3:GetObject'],
                    resources=[
                        'arn:aws:s3:::' + bucket_name + '/*',
                    ],
                    conditions={
                        'NotIpAddress': {
                            'aws:VpcSourceIp': vpc_cidr,
                            'aws:SourceIp': cloudflare_ips,
                        },
                        'StringNotEquals': {'aws:SourceVpc': vpc_id},
                    },
                )
            )

            # To be refactored. You want to include only once the CORS configuration.
            # if public_read_access and include_cdn are both "true"
            # If the CORS configuration is applied twice the following error will be raised
            # "Properties validation failed for resource XYZBucket with message: #/CorsConfiguration/CorsRules: array items are not unique"
            if not public_read_access:
                self._bucket.add_cors_rule(
                    allowed_methods=[
                        _s3.HttpMethods.GET,
                        _s3.HttpMethods.POST,
                        _s3.HttpMethods.PUT,
                        _s3.HttpMethods.DELETE,
                        _s3.HttpMethods.HEAD,
                    ],
                    allowed_origins=['*'],
                    allowed_headers=['*'],
                )

        # Create CloudFront distribution
        if create_cdn:
            default_behavior = _cloudfront.BehaviorOptions(
                origin=_cloudfront_origins.S3Origin(self.bucket),
                compress=True,
                # viewer_protocol_policy=_cloudfront.ViewerProtocolPolicy.HTTPS_ONLY,
                allowed_methods=_cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
                cache_policy=_cloudfront.CachePolicy.CACHING_DISABLED,
                origin_request_policy=_cloudfront.OriginRequestPolicy.ALL_VIEWER_EXCEPT_HOST_HEADER,
            )

            self._cloudfront_distribution = (
                self._create_cloudfront_distribution(
                    bucket_name=bucket_name,
                    cdn_ssl_certificate_arn=cdn_ssl_certificate_arn,
                    cdn_domain_names=cdn_domain_names,
                    bucket_policy_statements=bucket_policy_statements,
                    default_behavior=default_behavior,
                )
            )

        # Create CloudFront distribution + lambda@edge to handle authenticated access
        if has_authentication:

            user_pool_arn = self.aws_account['cognito_user_pool_arn']

            user_pool = _cognito.UserPool.from_user_pool_arn(
                self, 'UserPool', user_pool_arn=user_pool_arn
            )

            domain_name = (
                bucket_name
                if distribution_domain_name is None
                else distribution_domain_name
            )

            # If user_pool_client is not provided load default
            if not user_pool_client:

                fao_identity_provider = (
                    _cognito.UserPoolClientIdentityProvider.custom('FAO-SSO')
                )

                # https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_cognito/UserPoolClient.html
                user_pool_client = _cognito.UserPoolClient(
                    self,
                    id=f'{app_name}_{environment}_{bucket_name}_user_pool_client_id',
                    user_pool=user_pool,
                    supported_identity_providers=[fao_identity_provider],
                    generate_secret=False,
                    o_auth=_cognito.OAuthSettings(
                        callback_urls=[f'https://{domain_name}/parseauth'],
                        logout_urls=[f'https://{domain_name}/signout'],
                    ),
                )

            response_headers_policy = (
                distribution_response_headers_policy
                if distribution_response_headers_policy
                else _cloudfront.ResponseHeadersPolicy(
                    self,
                    f'{app_name}_response_headers_policy',
                    custom_headers_behavior=_cloudfront.ResponseCustomHeadersBehavior(
                        custom_headers=[]
                    ),
                    security_headers_behavior=_cloudfront.ResponseSecurityHeadersBehavior(
                        content_security_policy=_cloudfront.ResponseHeadersContentSecurityPolicy(
                            content_security_policy="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' fonts.gstatic.com cdn.jsdelivr.net; form-action 'self'; frame-src 'self'; img-src 'self' data:; object-src 'none'; style-src 'self' 'unsafe-inline' cdn.jsdelivr.net fonts.googleapis.com; script-src 'self' 'unsafe-eval' 'unsafe-inline' *.googletagmanager.com; connect-src 'self' *.google-analytics.com *.amazonaws.com; manifest-src 'self' *.fao.org; frame-ancestors 'self' *.fao.org;",
                            override=True,
                        ),
                        content_type_options=_cloudfront.ResponseHeadersContentTypeOptions(
                            override=True
                        ),
                        frame_options=_cloudfront.ResponseHeadersFrameOptions(
                            frame_option=_cloudfront.HeadersFrameOption.DENY,
                            override=True,
                        ),
                        referrer_policy=_cloudfront.ResponseHeadersReferrerPolicy(
                            referrer_policy=_cloudfront.HeadersReferrerPolicy.SAME_ORIGIN,
                            override=True,
                        ),
                        strict_transport_security=_cloudfront.ResponseHeadersStrictTransportSecurity(
                            access_control_max_age=cdk.Duration.seconds(
                                31536000
                            ),
                            include_subdomains=True,
                            preload=True,
                            override=True,
                        ),
                        xss_protection=_cloudfront.ResponseHeadersXSSProtection(
                            protection=True, mode_block=True, override=True
                        ),
                    ),
                )
            )

            origin = origins.S3Origin(self.bucket)

            redirect_paths = RedirectPaths(
                sign_in='/parseauth',
                auth_refresh='/refreshauth',
                sign_out='/signout',
            )

            oauthScopes = [
                _cognito.OAuthScope.PHONE,
                _cognito.OAuthScope.EMAIL,
                _cognito.OAuthScope.PROFILE,
                _cognito.OAuthScope.OPENID,
                _cognito.OAuthScope.COGNITO_ADMIN,
            ]

            nonce_signing_secret = SecretGenerator(
                self, 'SecretGenerator'
            ).secret

            auth_flow = AuthFlow(
                self,
                app_name + 'AuthFlow',
                log_level=LogLevel.DEBUG,
                app_name=app_name,
                oauth_scopes=oauthScopes,
                redirect_paths=redirect_paths,
                nonce_signing_secret=nonce_signing_secret,
                cognito_auth_domain=self.aws_account['cognito_domain'],
                user_pool_client=user_pool_client,
                user_pool=user_pool,
                cookie_settings=dict(
                    idToken='Path=/; Secure; SameSite=Lax',
                    accessToken='Path=/; Secure; SameSite=Lax',
                    refreshToken='Path=/; Secure; SameSite=Lax',
                    nonce='Path=/; Secure; HttpOnly; SameSite=Lax',
                ),
            )

            check_auth = auth_flow.check_auth.edge_lambda
            parse_auth = auth_flow.parse_auth.edge_lambda
            refresh_auth = auth_flow.refresh_auth.edge_lambda
            sign_out = auth_flow.sign_out.edge_lambda

            add_index_edge_function = EdgeFunction(
                self,
                'AddIndex',
                name='add-index',
                code=aws_lambda.Code.from_asset(
                    path=os.path.join(dirname, '../lambdas/add-index/')
                ),
                edge_role=auth_flow.edge_role,
                configuration=auth_flow.configuration,
                event_type=aws_cloudfront.LambdaEdgeEventType.ORIGIN_REQUEST,
            )

            default_behavior = _cloudfront.BehaviorOptions(
                origin=origin,
                compress=True,
                origin_request_policy=None,
                viewer_protocol_policy=_cloudfront.ViewerProtocolPolicy.HTTPS_ONLY,
                edge_lambdas=[add_index_edge_function.edge_lambda, check_auth],
                cache_policy=_cloudfront.CachePolicy.CACHING_DISABLED,
                response_headers_policy=response_headers_policy,
            )

            self._cloudfront_distribution = (
                self._create_cloudfront_distribution(
                    bucket_name=bucket_name,
                    cdn_ssl_certificate_arn=cdn_ssl_certificate_arn,
                    cdn_domain_names=cdn_domain_names,
                    bucket_policy_statements=bucket_policy_statements,
                    default_behavior=default_behavior,
                )
            )

            self._cloudfront_distribution.add_behavior(
                redirect_paths['sign_in'],
                origin,
                compress=True,
                origin_request_policy=_cloudfront.OriginRequestPolicy.ALL_VIEWER,
                viewer_protocol_policy=_cloudfront.ViewerProtocolPolicy.HTTPS_ONLY,
                edge_lambdas=[parse_auth],
            )
            self._cloudfront_distribution.add_behavior(
                redirect_paths['auth_refresh'],
                origin,
                compress=True,
                origin_request_policy=_cloudfront.OriginRequestPolicy.ALL_VIEWER,
                viewer_protocol_policy=_cloudfront.ViewerProtocolPolicy.HTTPS_ONLY,
                edge_lambdas=[refresh_auth],
            )
            self._cloudfront_distribution.add_behavior(
                redirect_paths['sign_out'],
                origin,
                compress=True,
                origin_request_policy=_cloudfront.OriginRequestPolicy.ALL_VIEWER,
                viewer_protocol_policy=_cloudfront.ViewerProtocolPolicy.HTTPS_ONLY,
                edge_lambdas=[sign_out],
            )

            # Add /index.html when not present

            # self._cloudfront_distribution.add_behavior(
            #     '/*',
            #     origin,
            #     compress=True,
            #     # origin_request_policy=_cloudfront.OriginRequestPolicy.ALL_VIEWER,
            #     viewer_protocol_policy=_cloudfront.ViewerProtocolPolicy.HTTPS_ONLY,
            #     edge_lambdas=[add_index_edge_function.edge_lambda],
            # )

            self.update_distribution_origin_access()
