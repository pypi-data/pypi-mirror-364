// This file is @generated by prost-build.
/// Wrapper message for `double`.
///
/// The JSON representation for `DoubleValue` is JSON number.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoubleValue {
    /// The double value.
    #[prost(double, tag = "1")]
    pub value: f64,
}
/// Wrapper message for `float`.
///
/// The JSON representation for `FloatValue` is JSON number.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloatValue {
    /// The float value.
    #[prost(float, tag = "1")]
    pub value: f32,
}
/// Wrapper message for `int64`.
///
/// The JSON representation for `Int64Value` is JSON string.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Int64Value {
    /// The int64 value.
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// Wrapper message for `uint64`.
///
/// The JSON representation for `UInt64Value` is JSON string.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UInt64Value {
    /// The uint64 value.
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
/// Wrapper message for `int32`.
///
/// The JSON representation for `Int32Value` is JSON number.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Int32Value {
    /// The int32 value.
    #[prost(int32, tag = "1")]
    pub value: i32,
}
/// Wrapper message for `uint32`.
///
/// The JSON representation for `UInt32Value` is JSON number.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UInt32Value {
    /// The uint32 value.
    #[prost(uint32, tag = "1")]
    pub value: u32,
}
/// Wrapper message for `bool`.
///
/// The JSON representation for `BoolValue` is JSON `true` and `false`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BoolValue {
    /// The bool value.
    #[prost(bool, tag = "1")]
    pub value: bool,
}
/// Wrapper message for `string`.
///
/// The JSON representation for `StringValue` is JSON string.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringValue {
    /// The string value.
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
/// Wrapper message for `bytes`.
///
/// The JSON representation for `BytesValue` is JSON string.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BytesValue {
    /// The bytes value.
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// APP配置设备信息内容
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfoConfig {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub sn: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub mac: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    /// 设备model name，最大长度32
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// 设备SN信息，最大长度32
    #[prost(string, tag = "2")]
    pub sn: ::prost::alloc::string::String,
    /// 设备MAC地址 （暂未使用）
    #[prost(bytes = "vec", tag = "3")]
    pub mac: ::prost::alloc::vec::Vec<u8>,
    /// 硬件版本，最大长度32
    #[prost(string, tag = "4")]
    pub hw_version: ::prost::alloc::string::String,
    /// 固件版本，最大长度32
    #[prost(string, tag = "5")]
    pub fw_version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HardwareInfo {
    /// 电池电量， 0-100
    #[prost(uint32, tag = "1")]
    pub bat_level: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WpaConfig {
    /// 加密类型
    #[prost(enumeration = "WiFiSecurity", tag = "1")]
    pub security: i32,
    /// SSID， 最大长度为32
    #[prost(string, tag = "2")]
    pub ssid: ::prost::alloc::string::String,
    /// 密码， 最小长度8，最大长度32。当security类型为NONE时，密码为空。
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WiFiConfig {
    /// 有效参数为 0: 20MHz 带宽； 1: 40MHz 带宽
    #[prost(message, optional, tag = "1")]
    pub band_40mhz: ::core::option::Option<UInt32Value>,
    /// WPA 配置
    #[prost(message, optional, tag = "2")]
    pub wpa_config: ::core::option::Option<WpaConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Xyz {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub z: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuCalibrationConfig {
    /// Accel校准配置
    #[prost(message, optional, tag = "1")]
    pub acc: ::core::option::Option<Xyz>,
    /// Gyro校准配置
    #[prost(message, optional, tag = "2")]
    pub gyro: ::core::option::Option<Xyz>,
    /// Mag校准配置硬磁校准参数
    #[prost(message, optional, tag = "3")]
    pub mag_hard_iron: ::core::option::Option<Xyz>,
    /// Mag校准配置软磁校准参数a
    #[prost(message, optional, tag = "4")]
    pub mag_soft_iron_a: ::core::option::Option<Xyz>,
    /// Mag校准配置软磁校准参数b
    #[prost(message, optional, tag = "5")]
    pub mag_soft_iron_b: ::core::option::Option<Xyz>,
    /// Mag校准配置软磁校准参数c
    #[prost(message, optional, tag = "6")]
    pub mag_soft_iron_c: ::core::option::Option<Xyz>,
}
/// APP发起OTA
/// 固件进入OTA模式后，开始请求文件
/// APP和固件交互传输升级包
/// 固件接收完成后,自动重启
/// 重启后，会擦写Flash
/// 操作Flash完成后，新固件运行，上报OTA完成状态。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtaConfig {
    #[prost(enumeration = "ota_config::Cmd", tag = "1")]
    pub cmd: i32,
    #[prost(message, optional, tag = "2")]
    pub ota_data: ::core::option::Option<OtaData>,
    /// START 命令，带新固件信息
    #[prost(uint32, tag = "3")]
    pub file_size: u32,
    /// OTA 文件md5值，长度为32
    #[prost(string, tag = "4")]
    pub file_md5: ::prost::alloc::string::String,
    /// OTA 文件sha256值，长度为64
    #[prost(string, tag = "5")]
    pub file_sha256: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OtaConfig`.
pub mod ota_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cmd {
        None = 0,
        /// 前台传输MCU升级文件
        OtaStart = 1,
        /// 重启升级MCU
        OtaReboot = 2,
    }
    impl Cmd {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::OtaStart => "OTA_START",
                Self::OtaReboot => "OTA_REBOOT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "OTA_START" => Some(Self::OtaStart),
                "OTA_REBOOT" => Some(Self::OtaReboot),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OtaConfigResp {
    /// 如果没有错误，恢复空OtaConfigResp
    #[prost(enumeration = "ota_config_resp::State", tag = "1")]
    pub state: i32,
    /// 镜像的offset
    #[prost(uint32, tag = "2")]
    pub offset: u32,
}
/// Nested message and enum types in `OtaConfigResp`.
pub mod ota_config_resp {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        None = 0,
        /// entry为true，返回状态为Downloading
        Downloading = 1,
        /// 接收到最后一包数据，返回FINISHED
        DownloadFinished = 2,
        /// 如果收到reboot，返回该状态后，再重启
        Rebooting = 3,
        /// 重新运行会发送该状态
        Rebooted = 4,
        /// 设备端状态异常，终止本次OTA
        Abort = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Downloading => "DOWNLOADING",
                Self::DownloadFinished => "DOWNLOAD_FINISHED",
                Self::Rebooting => "REBOOTING",
                Self::Rebooted => "REBOOTED",
                Self::Abort => "ABORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "DOWNLOADING" => Some(Self::Downloading),
                "DOWNLOAD_FINISHED" => Some(Self::DownloadFinished),
                "REBOOTING" => Some(Self::Rebooting),
                "REBOOTED" => Some(Self::Rebooted),
                "ABORT" => Some(Self::Abort),
                _ => None,
            }
        }
    }
}
/// APP发送OTA文件数据
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtaData {
    #[prost(uint32, tag = "1")]
    pub offset: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// 结束标志
    #[prost(bool, tag = "3")]
    pub finished: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigRespError {
    ConfigErrSuccess = 0,
    /// 硬件错误
    ConfigErrHardware = 1,
    /// 参数错误
    ConfigErrParameter = 2,
    /// 未知错误
    ConfigErrUnknown = 3,
}
impl ConfigRespError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ConfigErrSuccess => "CONFIG_ERR_SUCCESS",
            Self::ConfigErrHardware => "CONFIG_ERR_HARDWARE",
            Self::ConfigErrParameter => "CONFIG_ERR_PARAMETER",
            Self::ConfigErrUnknown => "CONFIG_ERR_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONFIG_ERR_SUCCESS" => Some(Self::ConfigErrSuccess),
            "CONFIG_ERR_HARDWARE" => Some(Self::ConfigErrHardware),
            "CONFIG_ERR_PARAMETER" => Some(Self::ConfigErrParameter),
            "CONFIG_ERR_UNKNOWN" => Some(Self::ConfigErrUnknown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WiFiSecurity {
    SecurityNone = 0,
    /// 无加密
    SecurityOpen = 1,
    /// WPA2 混合加密方式，包括TKIP和AES
    SecurityWpa2MixedPsk = 2,
}
impl WiFiSecurity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SecurityNone => "SECURITY_NONE",
            Self::SecurityOpen => "SECURITY_OPEN",
            Self::SecurityWpa2MixedPsk => "SECURITY_WPA2_MIXED_PSK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SECURITY_NONE" => Some(Self::SecurityNone),
            "SECURITY_OPEN" => Some(Self::SecurityOpen),
            "SECURITY_WPA2_MIXED_PSK" => Some(Self::SecurityWpa2MixedPsk),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WiFiStatus {
    /// 无配对状态
    None = 0,
    /// 空闲状态
    Idle = 1,
    /// 连接中
    Connecting = 2,
    /// 连接成功
    ConnSuccess = 3,
    /// 连接失败
    ConnFail = 4,
}
impl WiFiStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Idle => "IDLE",
            Self::Connecting => "CONNECTING",
            Self::ConnSuccess => "CONN_SUCCESS",
            Self::ConnFail => "CONN_FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "IDLE" => Some(Self::Idle),
            "CONNECTING" => Some(Self::Connecting),
            "CONN_SUCCESS" => Some(Self::ConnSuccess),
            "CONN_FAIL" => Some(Self::ConnFail),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppBle {
    /// 消息 ID
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    /// 设置设备信息
    #[prost(message, optional, tag = "3")]
    pub device_info: ::core::option::Option<DeviceInfoConfig>,
    /// 设置WiFi配置
    #[prost(message, optional, tag = "4")]
    pub wifi_config: ::core::option::Option<WiFiConfig>,
    /// OTA 升级数据, 无需设置 MsgType
    #[prost(message, optional, tag = "5")]
    pub ota_cfg: ::core::option::Option<OtaConfig>,
    /// 获取设备信息
    #[prost(message, optional, tag = "6")]
    pub device_info_req: ::core::option::Option<BoolValue>,
    /// 获取WiFi配置
    #[prost(message, optional, tag = "7")]
    pub wifi_config_req: ::core::option::Option<BoolValue>,
    /// 获取WiFi状态
    #[prost(message, optional, tag = "8")]
    pub wifi_status_req: ::core::option::Option<BoolValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleApp {
    /// 消息ID
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    /// 消息错误代码
    #[prost(enumeration = "ConfigRespError", tag = "2")]
    pub error: i32,
    /// 设备信息
    #[prost(message, optional, tag = "3")]
    pub device_info: ::core::option::Option<DeviceInfo>,
    /// WiFi配置信息
    #[prost(message, optional, tag = "4")]
    pub wifi_config: ::core::option::Option<WiFiConfig>,
    /// WiFi连接状态
    #[prost(enumeration = "WiFiStatus", tag = "5")]
    pub wifi_status: i32,
    /// OTA 升级配置
    #[prost(message, optional, tag = "6")]
    pub ota_resp: ::core::option::Option<OtaConfigResp>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EegConfig {
    #[prost(enumeration = "EegSampleRate", tag = "1")]
    pub freq: i32,
    #[prost(enumeration = "EegSignalGain", tag = "2")]
    pub gain: i32,
    #[prost(enumeration = "eeg_config::SignalSource", tag = "3")]
    pub source: i32,
}
/// Nested message and enum types in `EEGConfig`.
pub mod eeg_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SignalSource {
        /// 设备默认值是NORMAL
        SignalNone = 0,
        /// 用户EEG输入信号
        Normal = 1,
        /// INxP, INxN短接， 用于测量偏置或噪声
        Shorted = 2,
        /// 供电检测
        Mvdd = 3,
        /// 内部测试信号，为1Hz的方波
        TestSignal = 4,
    }
    impl SignalSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SignalNone => "SIGNAL_NONE",
                Self::Normal => "NORMAL",
                Self::Shorted => "SHORTED",
                Self::Mvdd => "MVDD",
                Self::TestSignal => "TEST_SIGNAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SIGNAL_NONE" => Some(Self::SignalNone),
                "NORMAL" => Some(Self::Normal),
                "SHORTED" => Some(Self::Shorted),
                "MVDD" => Some(Self::Mvdd),
                "TEST_SIGNAL" => Some(Self::TestSignal),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EegLeadOffConfig {
    /// lead-off检测芯片
    #[prost(enumeration = "EegLeadOffChip", tag = "1")]
    pub chip: i32,
    /// lead-off检测频率
    #[prost(enumeration = "eeg_lead_off_config::Frequency", tag = "2")]
    pub ac_freq: i32,
    /// lead-off检测电流
    #[prost(enumeration = "eeg_lead_off_config::Current", tag = "3")]
    pub current: i32,
    /// 采样率，默认为EEG_SR_250Hz
    #[prost(enumeration = "EegSampleRate", tag = "4")]
    pub freq: i32,
    /// 增益， 默认为EEG_GAIN_1
    #[prost(enumeration = "EegSignalGain", tag = "5")]
    pub gain: i32,
}
/// Nested message and enum types in `EEGLeadOffConfig`.
pub mod eeg_lead_off_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Frequency {
        /// 设备默认值是31.2Hz
        FreqNone = 0,
        /// 直流lead-off检测
        Dc = 1,
        /// 交流lead-off检测， 频率7.8Hz
        Ac7p8hz = 2,
        /// 交流lead-off检测， 频率31.2Hz
        Ac31p2hz = 3,
        /// 交流lead-off检测， 频率f_dr/4, f_dr为EEG采样率
        AcFdr4 = 4,
    }
    impl Frequency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FreqNone => "FREQ_NONE",
                Self::Dc => "DC",
                Self::Ac7p8hz => "AC_7P8HZ",
                Self::Ac31p2hz => "AC_31P2HZ",
                Self::AcFdr4 => "AC_Fdr_4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FREQ_NONE" => Some(Self::FreqNone),
                "DC" => Some(Self::Dc),
                "AC_7P8HZ" => Some(Self::Ac7p8hz),
                "AC_31P2HZ" => Some(Self::Ac31p2hz),
                "AC_Fdr_4" => Some(Self::AcFdr4),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Current {
        /// 设备默认值是6nA
        CurNone = 0,
        /// lead-off电流源输出为6nA
        Cur6nA = 1,
        /// lead-off电流源输出为24nA
        Cur24nA = 2,
        /// lead-off电流源输出为6uA
        Cur6uA = 3,
        /// lead-off电流源输出为24uA
        Cur24uA = 4,
    }
    impl Current {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CurNone => "CUR_NONE",
                Self::Cur6nA => "CUR_6nA",
                Self::Cur24nA => "CUR_24nA",
                Self::Cur6uA => "CUR_6uA",
                Self::Cur24uA => "CUR_24uA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUR_NONE" => Some(Self::CurNone),
                "CUR_6nA" => Some(Self::Cur6nA),
                "CUR_24nA" => Some(Self::Cur24nA),
                "CUR_6uA" => Some(Self::Cur6uA),
                "CUR_24uA" => Some(Self::Cur24uA),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuConfig {
    #[prost(enumeration = "ImuSampleRate", tag = "1")]
    pub freq: i32,
    /// Accel数据类型
    #[prost(enumeration = "ImuDataType", tag = "2")]
    pub acc_type: i32,
    /// Gyro数据类型
    #[prost(enumeration = "ImuDataType", tag = "3")]
    pub gyro_type: i32,
    /// Mag数据类型
    #[prost(enumeration = "ImuDataType", tag = "4")]
    pub mag_type: i32,
    /// 校准配置
    #[prost(message, optional, tag = "5")]
    pub correction: ::core::option::Option<ImuCalibrationConfig>,
    /// Accel系数，转换后带单位g
    #[prost(float, tag = "6")]
    pub acc_coefficient: f32,
    /// Gyro系数，转换后带单位dps
    #[prost(float, tag = "7")]
    pub gyro_coefficient: f32,
    /// Mag系数，转换后带单位gauss
    #[prost(float, tag = "8")]
    pub mag_coefficient: f32,
}
/// 	EEG ADS1299 channels:
/// 		+-----------+-----------+-----------+-----------+
/// 		| ADS1299_0 | ADS1299_1 | ADS1299_3 | ADS1299_4 |
/// 		+-----------+-----------+-----------+-----------+
/// 		|0         7|8        15|16       23|24       31|
///       +-----------+-----------+-----------+-----------+
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EegSampleRate {
    /// 设备默认值是EEG_SR_250Hz
    EegSrNone = 0,
    EegSr250hz = 1,
    EegSr500hz = 2,
    EegSr1000hz = 3,
    EegSr2000hz = 4,
}
impl EegSampleRate {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EegSrNone => "EEG_SR_NONE",
            Self::EegSr250hz => "EEG_SR_250Hz",
            Self::EegSr500hz => "EEG_SR_500Hz",
            Self::EegSr1000hz => "EEG_SR_1000Hz",
            Self::EegSr2000hz => "EEG_SR_2000Hz",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EEG_SR_NONE" => Some(Self::EegSrNone),
            "EEG_SR_250Hz" => Some(Self::EegSr250hz),
            "EEG_SR_500Hz" => Some(Self::EegSr500hz),
            "EEG_SR_1000Hz" => Some(Self::EegSr1000hz),
            "EEG_SR_2000Hz" => Some(Self::EegSr2000hz),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EegSignalGain {
    /// 设备默认值是EEG_GAIN_6
    EegGainNone = 0,
    /// 原始信号
    EegGain1 = 1,
    /// 原始信号放大2倍
    EegGain2 = 2,
    /// 原始信号放大4倍
    EegGain4 = 3,
    /// 原始信号放大6倍
    EegGain6 = 4,
    /// 原始信号放大8倍
    EegGain8 = 5,
    /// 原始信号放大12倍
    EegGain12 = 6,
    /// 原始信号放大24倍
    EegGain24 = 7,
}
impl EegSignalGain {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EegGainNone => "EEG_GAIN_NONE",
            Self::EegGain1 => "EEG_GAIN_1",
            Self::EegGain2 => "EEG_GAIN_2",
            Self::EegGain4 => "EEG_GAIN_4",
            Self::EegGain6 => "EEG_GAIN_6",
            Self::EegGain8 => "EEG_GAIN_8",
            Self::EegGain12 => "EEG_GAIN_12",
            Self::EegGain24 => "EEG_GAIN_24",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EEG_GAIN_NONE" => Some(Self::EegGainNone),
            "EEG_GAIN_1" => Some(Self::EegGain1),
            "EEG_GAIN_2" => Some(Self::EegGain2),
            "EEG_GAIN_4" => Some(Self::EegGain4),
            "EEG_GAIN_6" => Some(Self::EegGain6),
            "EEG_GAIN_8" => Some(Self::EegGain8),
            "EEG_GAIN_12" => Some(Self::EegGain12),
            "EEG_GAIN_24" => Some(Self::EegGain24),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EegMode {
    /// 设备默认值是EEG_MODE_NORMAL
    None = 0,
    /// EEG信号采集
    Normal = 1,
    /// Lead-off阻抗检测
    LeadOff = 2,
}
impl EegMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "EEG_MODE_NONE",
            Self::Normal => "EEG_MODE_NORMAL",
            Self::LeadOff => "EEG_MODE_LEAD_OFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EEG_MODE_NONE" => Some(Self::None),
            "EEG_MODE_NORMAL" => Some(Self::Normal),
            "EEG_MODE_LEAD_OFF" => Some(Self::LeadOff),
            _ => None,
        }
    }
}
/// 设备EEG lead-off检测说明：
///   1. EEG功能基于4个处于daisy-chain模式的ADS1299芯片，每个芯片包含8个EEG通道，共32个EEG通道
///   2. lead-off功能一次只能检测1个芯片，所以4个ADS1299芯片需要分别做4次lead-off检测
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EegLeadOffChip {
    ChipNone = 0,
    Chip1 = 1,
    Chip2 = 2,
    Chip3 = 3,
    Chip4 = 4,
}
impl EegLeadOffChip {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChipNone => "CHIP_NONE",
            Self::Chip1 => "CHIP_1",
            Self::Chip2 => "CHIP_2",
            Self::Chip3 => "CHIP_3",
            Self::Chip4 => "CHIP_4",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHIP_NONE" => Some(Self::ChipNone),
            "CHIP_1" => Some(Self::Chip1),
            "CHIP_2" => Some(Self::Chip2),
            "CHIP_3" => Some(Self::Chip3),
            "CHIP_4" => Some(Self::Chip4),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImuSampleRate {
    /// 设备默认值是IMU_SR_50Hz
    ImuSrNone = 0,
    ImuSr50hz = 1,
    ImuSr100hz = 2,
}
impl ImuSampleRate {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ImuSrNone => "IMU_SR_NONE",
            Self::ImuSr50hz => "IMU_SR_50Hz",
            Self::ImuSr100hz => "IMU_SR_100Hz",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMU_SR_NONE" => Some(Self::ImuSrNone),
            "IMU_SR_50Hz" => Some(Self::ImuSr50hz),
            "IMU_SR_100Hz" => Some(Self::ImuSr100hz),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImuDataType {
    /// 设备默认值是RAW_DATA
    ImuTypeNone = 0,
    /// 原始数据
    RawData = 1,
    /// 校准后的数据
    CalibratedData = 2,
}
impl ImuDataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ImuTypeNone => "IMU_TYPE_NONE",
            Self::RawData => "RAW_DATA",
            Self::CalibratedData => "CALIBRATED_DATA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMU_TYPE_NONE" => Some(Self::ImuTypeNone),
            "RAW_DATA" => Some(Self::RawData),
            "CALIBRATED_DATA" => Some(Self::CalibratedData),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuAcqRequest {
    /// 设置IMU配置
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<ImuConfig>,
    /// 获取IMU配置
    #[prost(message, optional, tag = "3")]
    pub config_req: ::core::option::Option<BoolValue>,
    /// 开始/关闭IMU采样
    #[prost(message, optional, tag = "4")]
    pub enable: ::core::option::Option<BoolValue>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EegAcqRequest {
    /// 设置EEG配置
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<EegConfig>,
    /// 设置lead-off配置
    #[prost(message, optional, tag = "3")]
    pub lead_off: ::core::option::Option<EegLeadOffConfig>,
    /// 获取EEG配置
    #[prost(message, optional, tag = "4")]
    pub config_req: ::core::option::Option<BoolValue>,
    /// 获取lead-off配置
    #[prost(message, optional, tag = "5")]
    pub lead_off_req: ::core::option::Option<BoolValue>,
    /// 开始/关闭采样
    #[prost(message, optional, tag = "6")]
    pub enable: ::core::option::Option<BoolValue>,
    /// 工作模式
    #[prost(enumeration = "EegMode", tag = "7")]
    pub mode: i32,
    /// 获取工作模式
    #[prost(message, optional, tag = "8")]
    pub mode_req: ::core::option::Option<BoolValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppMain {
    /// 在有消息执行状态时，会以相同的msg_id发送给App。设备主动发送的msg_id为0
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    /// EEG 相关消息
    #[prost(message, optional, tag = "3")]
    pub eeg: ::core::option::Option<EegAcqRequest>,
    /// IMU 相关消息
    #[prost(message, optional, tag = "4")]
    pub imu: ::core::option::Option<ImuAcqRequest>,
    /// OTA 升级数据
    #[prost(message, optional, tag = "5")]
    pub ota_cfg: ::core::option::Option<OtaConfig>,
    /// 请求设备信息（WiFi 端）
    #[prost(message, optional, tag = "6")]
    pub device_info_req: ::core::option::Option<BoolValue>,
    /// 请求硬件状态
    #[prost(message, optional, tag = "7")]
    pub hw_info_req: ::core::option::Option<BoolValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EegData {
    #[prost(message, optional, tag = "1")]
    pub sample_1: ::core::option::Option<eeg_data::EegSample>,
    #[prost(message, optional, tag = "2")]
    pub sample_2: ::core::option::Option<eeg_data::EegSample>,
    #[prost(message, optional, tag = "3")]
    pub sample_3: ::core::option::Option<eeg_data::EegSample>,
    #[prost(message, optional, tag = "4")]
    pub sample_4: ::core::option::Option<eeg_data::EegSample>,
    /// lead-off模式时，确定当前活动芯片
    #[prost(enumeration = "EegLeadOffChip", tag = "5")]
    pub lead_off_chip: i32,
    #[prost(enumeration = "EegSampleRate", tag = "6")]
    pub freq: i32,
    #[prost(enumeration = "EegSignalGain", tag = "7")]
    pub gain: i32,
}
/// Nested message and enum types in `EEGData`.
pub mod eeg_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EegSample {
        #[prost(uint32, tag = "1")]
        pub timestamp: u32,
        #[prost(bytes = "vec", tag = "2")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuData {
    #[prost(uint32, tag = "1")]
    pub timestamp: u32,
    #[prost(message, optional, tag = "2")]
    pub accel: ::core::option::Option<imu_data::ImuValue>,
    #[prost(message, optional, tag = "3")]
    pub gyro: ::core::option::Option<imu_data::ImuValue>,
    #[prost(message, optional, tag = "4")]
    pub mag: ::core::option::Option<imu_data::ImuValue>,
    /// 单位转换系数，转换后带单位g，
    #[prost(float, tag = "5")]
    pub acc_coefficient: f32,
    /// 单位转换系数，转换后带单位dps(degree-per-second),
    #[prost(float, tag = "6")]
    pub gyro_coefficient: f32,
    /// 单位转换系数，换转后带单位gauss
    #[prost(float, tag = "7")]
    pub mag_coefficient: f32,
    #[prost(enumeration = "ImuSampleRate", tag = "8")]
    pub freq: i32,
}
/// Nested message and enum types in `IMUData`.
pub mod imu_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ImuValue {
        #[prost(float, tag = "2")]
        pub cord_x: f32,
        #[prost(float, tag = "3")]
        pub cord_y: f32,
        #[prost(float, tag = "4")]
        pub cord_z: f32,
        #[prost(enumeration = "super::ImuDataType", tag = "5")]
        pub r#type: i32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuAcqResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<ImuConfig>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<ImuData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EegAcqResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<EegConfig>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<EegData>,
    #[prost(message, optional, tag = "3")]
    pub lead_off: ::core::option::Option<EegLeadOffConfig>,
    #[prost(enumeration = "EegMode", tag = "4")]
    pub mode: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainApp {
    #[prost(uint32, tag = "1")]
    pub msg_id: u32,
    /// 消息错误代码
    #[prost(enumeration = "ConfigRespError", tag = "2")]
    pub err: i32,
    /// EEG 相关消息
    #[prost(message, optional, tag = "3")]
    pub eeg: ::core::option::Option<EegAcqResponse>,
    /// IMU 相关消息
    #[prost(message, optional, tag = "4")]
    pub imu: ::core::option::Option<ImuAcqResponse>,
    /// OTA 升级配置
    #[prost(message, optional, tag = "5")]
    pub ota_resp: ::core::option::Option<OtaConfigResp>,
    /// 设备信息
    #[prost(message, optional, tag = "6")]
    pub device_info: ::core::option::Option<DeviceInfo>,
    /// 设备状态，电池电量等
    #[prost(message, optional, tag = "7")]
    pub hw_info: ::core::option::Option<HardwareInfo>,
}
