"""Test the method naming strategy."""
import pytest

from openapi_to_httpx.naming_strategy import MethodNamingStrategy


class TestMethodNamingStrategy:
    """Test cases for MethodNamingStrategy."""
    
    @pytest.fixture
    def strategy(self):
        """Provide a fresh strategy instance for each test."""
        return MethodNamingStrategy()
    
    @pytest.mark.parametrize("path,method,expected", [
        # Basic CRUD operations
        ("/api/v1/sessions/", "POST", "post_api_v1_sessions"),
        ("/api/v1/sessions/", "GET", "get_api_v1_sessions"),
        ("/api/v1/sessions/{session_id}", "GET", "get_api_v1_sessions_session_id"),
        ("/api/v1/sessions/{session_id}", "PUT", "put_api_v1_sessions_session_id"),
        ("/api/v1/sessions/{session_id}", "DELETE", "delete_api_v1_sessions_session_id"),
        
        # Nested resources
        ("/api/v1/users/{user_id}/sessions/", "POST", "post_api_v1_users_user_id_sessions"),
        ("/api/v1/users/{user_id}/sessions/", "GET", "get_api_v1_users_user_id_sessions"),
        ("/api/v1/users/{user_id}/sessions/{session_id}", "GET", "get_api_v1_users_user_id_sessions_session_id"),
        
        # Simple paths
        ("/users/", "POST", "post_users"),
        ("/categories/", "POST", "post_categories"),
        ("/children/", "POST", "post_children"),
        
        # Special HTTP methods
        ("/sessions/{id}", "PATCH", "patch_sessions_id"),
        ("/sessions/{id}", "HEAD", "head_sessions_id"),
        ("/sessions/{id}", "OPTIONS", "options_sessions_id"),
        
        # Root paths
        ("/", "GET", "get_root"),
        
        # Complex nested resources
        ("/organizations/{org_id}/projects/{project_id}/tasks/", "POST", 
         "post_organizations_org_id_projects_project_id_tasks"),
        ("/organizations/{org_id}/projects/{project_id}/tasks/{task_id}", "GET",
         "get_organizations_org_id_projects_project_id_tasks_task_id"),
    ])
    def test_method_name_generation(self, strategy, path, method, expected):
        """Test various path/method combinations produce expected names."""
        assert strategy.generate_method_name(path, method) == expected
    
    @pytest.mark.parametrize("version,expected_post,expected_get", [
        ("v1", "post_api_v1_sessions", "get_api_v1_sessions"),
        ("v2", "post_api_v2_sessions", "get_api_v2_sessions"),
        ("v3", "post_api_v3_sessions", "get_api_v3_sessions"),
    ])
    def test_versioned_apis(self, strategy, version, expected_post, expected_get):
        """Test versioned API endpoints generate distinct names."""
        assert strategy.generate_method_name(f"/api/{version}/sessions/", "POST") == expected_post
        assert strategy.generate_method_name(f"/api/{version}/sessions/", "GET") == expected_get
        assert strategy.generate_method_name(f"/api/{version}/sessions/{{id}}", "GET") == f"get_api_{version}_sessions_id"
    
    def test_operation_id_usage(self, strategy):
        """Test that operationIds are always used when provided."""
        # operationId should be used
        assert strategy.generate_method_name("/api/v1/sessions/", "POST", "createSession") == "create_session"
        
        # Same path/method returns cached result
        assert strategy.generate_method_name(
            "/api/v1/sessions/", 
            "POST", 
            "post_api_v1_sessions_with_very_long_autogenerated_name"
        ) == "create_session"
    
    def test_conflict_resolution(self, strategy):
        """Test that naming conflicts are resolved with suffixes."""
        # First occurrence
        assert strategy.generate_method_name("/sessions/", "POST") == "post_sessions"
        # Different path - no conflict
        assert strategy.generate_method_name("/session/", "POST") == "post_session"
        assert strategy.generate_method_name("/api/sessions/", "POST") == "post_api_sessions"
    
    def test_trailing_slash_handling(self, strategy):
        """Test consistent handling of trailing slashes."""
        assert strategy.generate_method_name("/users", "GET") == "get_users"
        # Same path with trailing slash gets suffix to avoid conflict
        assert strategy.generate_method_name("/users/", "GET") == "get_users_2"
    
    def test_cache_consistency(self, strategy):
        """Test that the same path/method always returns the same name."""
        # Generate name
        name1 = strategy.generate_method_name("/api/v1/sessions/", "POST")
        
        # Generate other names
        strategy.generate_method_name("/users/", "POST")
        strategy.generate_method_name("/tasks/", "POST")
        
        # Should get the same name for the same path/method
        name2 = strategy.generate_method_name("/api/v1/sessions/", "POST")
        
        assert name1 == name2 == "post_api_v1_sessions"
    
    def test_long_operation_id_usage(self, strategy):
        """Test that even long operationIds are used when provided."""
        # Test with a fresh strategy to avoid caching
        fresh_strategy = MethodNamingStrategy()
        
        # Long operationId should be used
        result = fresh_strategy.generate_method_name(
            "/api/v1/execute/{session_id}", 
            "POST", 
            "execute_command_api_v1_execute__session_id__post"
        )
        assert result == "execute_command_api_v1_execute__session_id__post"