import functools
import math
from itertools import repeat
from typing import Literal, Tuple, List, Union, Any, Iterator, TypeVar, overload

import numpy as np

_T = TypeVar('_T', list, tuple, str, bytes, np.ndarray)

class Cycles:
    def __init__(self, *cycles: Union[Tuple[int, ...], List[int]]) -> None: ...

    def __hash__(self) -> int: ...

    def is_identity(self) -> bool: ...

    def __eq__(self, value: 'Cycles') -> bool: ...

    def __lt__(self, value: 'Cycles') -> bool: ...

    def __mul__(self, other: 'Cycles') -> 'Cycles': ...

    def __rmul__(self, other: 'Cycles') -> 'Cycles': ...

    def __pow__(self, n: int) -> 'Cycles': ...

    def __invert__(self) -> 'Cycles': ...

    def inv(self) -> 'Cycles': ...

    @property
    def order(self) -> int: ...

    @property
    def support(self) -> Tuple[int, ...]: ...

    @property
    def signature(self) -> int: ...

    def __len__(self) -> int: ...

    def __repr__(self) -> str: ...

    def to_matrix(self) -> np.ndarray: ...

    def replace(self, expr: Any) -> Any: ...

    def __call__(self, *cycle: Union[Tuple[int, ...], List[int]]) -> 'Cycles': ...

    def commutator(self, x: 'Cycles') -> 'Cycles': ...

    def simplify(self) -> 'Cycles': ...

    def expand(self) -> Iterator['Cycles']: ...

@overload
def permute(expr: list, perm: Cycles) -> list: ...
@overload
def permute(expr: tuple, perm: Cycles) -> tuple: ...
@overload
def permute(expr: str, perm: Cycles) -> str: ...
@overload
def permute(expr: bytes, perm: Cycles) -> bytes: ...
@overload
def permute(expr: np.ndarray, perm: Cycles) -> np.ndarray: ...

def find_permutation(expr1: list, expr2: list) -> Cycles: ...

def random_permutation(n: int) -> Cycles: ...
