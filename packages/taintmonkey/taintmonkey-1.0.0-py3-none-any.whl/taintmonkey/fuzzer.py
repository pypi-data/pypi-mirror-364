# TODO(bliutech): need to implement the following patterns / structure
# do via dependency injection?
# - executor
# - observer
# - mutator (start with a NoOp mutator where it just uses the corpus as a dictionary)

# For now, we have a primitive structure with a dictionary fuzzer.

from abc import ABC, abstractmethod
from contextlib import contextmanager
from io import StringIO
import random
from random import randint
import os
import sys

from flask import Flask

from taintmonkey.client import register_taint_client

from grammarinator.tool import DefaultGeneratorFactory, GeneratorTool
import itertools
from math import inf
from grammarinator.runtime import *


class Fuzzer(ABC):
    @abstractmethod
    def get_context(self):
        pass


class DictionaryFuzzer(Fuzzer):
    def __init__(self, app: Flask, corpus: str = None):
        self.flask_app = app
        self.corpus = corpus
        self.inputs = []
        self.load_corpus()

    @contextmanager
    def get_context(self):  # type: ignore
        # Choose a random input from the dictionary
        random.shuffle(self.inputs)
        test_client = self.flask_app.test_client()

        yield (test_client, self.inputs)

    def load_corpus(self):
        if not os.path.exists(self.corpus):
            raise FileNotFoundError(f"Corpus file not found: {self.corpus}")
        with open(self.corpus, "r") as f:
            self.inputs = [line.strip() for line in f if line.strip()]


# Generated by Grammarinator 23.7
class JSONGenerator(Generator):
    def __init__(self, key_pool_frequency: float = 0, key_pool: list = None):
        """
        Constructor - optionally set a key pool and how frequently keys should be sampled from it
        """
        self.key_pool_frequency = key_pool_frequency
        self.key_pool = key_pool
        super().__init__()

    def EOF(self, parent=None):
        pass

    EOF.min_depth = 0

    def json(self, parent=None):
        """
        Defines top-level JSON structure
        Currently it can be any value (object, array, string, etc.)
        If you want to enforce top-level as always an object, replace:
        self.value(...) --> self.obj(...)
        """
        with RuleContext(self, UnparserRule(name="json", parent=parent)) as current:
            self.obj(parent=current)
            self.EOF(parent=current)
            return current

    json.min_depth = 1

    def obj(self, parent=None):
        """
        Defines a JSON object
        """
        with RuleContext(self, UnparserRule(name="obj", parent=parent)) as current:
            # first list -> minimum depth constraints
            # second list -> probability weights (delete second element for no empty option)
            with AlternationContext(self, [2, 0], [10, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    # Non-empty object branch
                    UnlexerRule(src="{", parent=current)
                    self.pair(parent=current)
                    if self._max_depth >= 2:
                        # Adjust number of pairs by changing min and max
                        for _ in self._model.quantify(current, 0, min=3, max=inf):
                            UnlexerRule(src=",", parent=current)
                            self.pair(parent=current)
                    UnlexerRule(src="}", parent=current)
                elif choice0 == 1:
                    # Empty object ('{}') branch
                    UnlexerRule(src="{", parent=current)
                    UnlexerRule(src="}", parent=current)
            return current

    obj.min_depth = 0

    def pair(self, parent=None):
        """
        Defines a key-value pair
        """
        with RuleContext(self, UnparserRule(name="pair", parent=parent)) as current:
            # Optional: provide a key corpus
            # Adjust probability to adjust how often used
            if random.random() < self.key_pool_frequency:
                key = random.choice(self.key_pool)
                UnlexerRule(src=f'"{key}"', parent=current)
            else:
                self.STRING(parent=current)  # key
            UnlexerRule(src=":", parent=current)
            self.value(parent=current)  # value
            return current

    pair.min_depth = 1

    def arr(self, parent=None):
        """
        Defines a JSON array
        """
        with RuleContext(self, UnparserRule(name="arr", parent=parent)) as current:
            # first list -> minimum depth constraints
            # second list -> probability weights (delete second element for no empty option)
            with AlternationContext(self, [1, 0], [10, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    # Non-empty array
                    UnlexerRule(src="[", parent=current)
                    self.value(parent=current)
                    if self._max_depth >= 1:
                        # Adjust number of array elements by changing min and max
                        for _ in self._model.quantify(current, 0, min=2, max=inf):
                            UnlexerRule(src=",", parent=current)
                            self.value(parent=current)
                    UnlexerRule(src="]", parent=current)
                elif choice0 == 1:
                    # Empty array
                    UnlexerRule(src="[", parent=current)
                    UnlexerRule(src="]", parent=current)
            return current

    arr.min_depth = 0

    def value(self, parent=None):
        """
        Decides what kind of JSON value to provide (string, number, obj, etc.)

        """
        with RuleContext(self, UnparserRule(name="value", parent=parent)) as current:
            # first list -> minimum depth constraints
            # second list -> probability weights
            # weights incides: 0 - STRING, 1 - NUMBER, 2 - obj, 3 - arr, 4 - "true", 5 - "false". 6 - "null"
            with AlternationContext(
                self, [1, 2, 1, 1, 0, 0, 0], [10, 5, 10, 10, 1, 1, 1]
            ) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [None, None, None, None, "true", "false", "null"][choice0]
                rule = [self.STRING, self.NUMBER, self.obj, self.arr, None, None, None][
                    choice0
                ]
                if src is not None:
                    UnlexerRule(src=src, parent=current)  # emit literal
                else:
                    rule(parent=current)  # generate structured value
            return current

    value.min_depth = 0

    def STRING(self, parent=None):
        """
        Emits a string
        """
        with RuleContext(self, UnlexerRule(name="STRING", parent=parent)) as current:
            UnlexerRule(src='"', parent=current)
            if self._max_depth >= 1:
                # first list -> minimum depth constraints
                # second list -> probability weights (delete second element for no empty option)
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [0, 2], [1, 3]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.ESC, self.SAFECODEPOINT][choice0](parent=current)
            UnlexerRule(src='"', parent=current)
            return current

    STRING.min_depth = 0

    def ESC(self, parent=None):
        """
        Emits a backslash-escaped character
        """
        with RuleContext(self, UnlexerRule(name="ESC", parent=parent)) as current:
            UnlexerRule(src="\\", parent=current)
            # first list -> minimum depth constraints
            # second list -> probability weights (delete second element for no empty option)
            with AlternationContext(self, [0, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    # single character escape sequence
                    UnlexerRule(
                        src=self._model.charset(current, 0, self._charsets[1]),
                        parent=current,
                    )
                elif choice0 == 1:
                    # Unicode escape sequence
                    self.UNICODE(parent=current)
            return current

    ESC.min_depth = 1

    def UNICODE(self, parent=None):
        """
        Emits a Unicode escape sequence
        """
        with RuleContext(self, UnlexerRule(name="UNICODE", parent=parent)) as current:
            UnlexerRule(src="u", parent=current)
            self.HEX(parent=current)
            self.HEX(parent=current)
            self.HEX(parent=current)
            self.HEX(parent=current)
            return current

    UNICODE.min_depth = 1

    def HEX(self, parent=None):
        # Emits a single hexadecimal character
        with RuleContext(self, UnlexerRule(name="HEX", parent=parent)) as current:
            UnlexerRule(
                src=self._model.charset(current, 0, self._charsets[2]), parent=current
            )
            return current

    HEX.min_depth = 0

    def SAFECODEPOINT(self, parent=None):
        """
        Emits a printable character (doesn't need escaping)
        """
        with RuleContext(
            self, UnlexerRule(name="SAFECODEPOINT", parent=parent)
        ) as current:
            UnlexerRule(
                src=self._model.charset(current, 0, self._charsets[3]), parent=current
            )
            return current

    SAFECODEPOINT.min_depth = 0

    def NUMBER(self, parent=None):
        """
        Emits a number (integer or float)
        """
        with RuleContext(self, UnlexerRule(name="NUMBER", parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src="-", parent=current)
            self.INT(parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=".", parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 2, min=1, max=inf):
                            UnlexerRule(
                                src=self._model.charset(current, 0, self._charsets[4]),
                                parent=current,
                            )
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 3, min=0, max=1):
                    self.EXP(parent=current)
            return current

    NUMBER.min_depth = 1

    def INT(self, parent=None):
        """
        Emits an integer, either 0 or starting with 1-9
        """
        with RuleContext(self, UnlexerRule(name="INT", parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src="0", parent=current)
                elif choice0 == 1:
                    UnlexerRule(
                        src=self._model.charset(current, 0, self._charsets[5]),
                        parent=current,
                    )
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            UnlexerRule(
                                src=self._model.charset(current, 1, self._charsets[6]),
                                parent=current,
                            )
            return current

    INT.min_depth = 0

    def EXP(self, parent=None):
        # Emits an exponential part
        with RuleContext(self, UnlexerRule(name="EXP", parent=parent)) as current:
            UnlexerRule(
                src=self._model.charset(current, 0, self._charsets[7]), parent=current
            )
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(
                        src=self._model.charset(current, 1, self._charsets[8]),
                        parent=current,
                    )
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=1, max=inf):
                    UnlexerRule(
                        src=self._model.charset(current, 2, self._charsets[9]),
                        parent=current,
                    )
            return current

    EXP.min_depth = 0

    def WS(self, parent=None):
        # Emits whitespace characters
        with RuleContext(self, UnlexerRule(name="WS", parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(
                        src=self._model.charset(current, 0, self._charsets[10]),
                        parent=current,
                    )
            return current

    WS.min_depth = 0

    _default_rule = json

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(
            itertools.chain.from_iterable(
                [
                    range(34, 35),
                    range(47, 48),
                    range(92, 93),
                    range(98, 99),
                    range(102, 103),
                    range(110, 111),
                    range(114, 115),
                    range(116, 117),
                ]
            )
        ),
        2: list(
            itertools.chain.from_iterable(
                [range(48, 58), range(65, 71), range(97, 103)]
            )
        ),
        3: list(
            itertools.chain.from_iterable(
                [range(32, 34), range(35, 92), range(93, 127)]
            )
        ),
        4: list(itertools.chain.from_iterable([range(48, 58)])),
        5: list(itertools.chain.from_iterable([range(49, 58)])),
        6: list(itertools.chain.from_iterable([range(48, 58)])),
        7: list(itertools.chain.from_iterable([range(69, 70), range(101, 102)])),
        8: list(itertools.chain.from_iterable([range(43, 44), range(45, 46)])),
        9: list(itertools.chain.from_iterable([range(48, 58)])),
        10: list(
            itertools.chain.from_iterable(
                [range(9, 10), range(10, 11), range(13, 14), range(32, 33)]
            )
        ),
    }


class GrammarBasedFuzzer(Fuzzer):
    def __init__(
        self, app: Flask, key_pool_frequency: float = 0, key_pool: list = None
    ):
        self.flask_app = app
        self.key_pool_frequency = key_pool_frequency
        self.key_pool = key_pool

    @contextmanager
    def get_context(self):
        test_client = self.flask_app.test_client()

        def input_generator():
            while True:
                try:
                    generator = JSONGenerator(
                        key_pool_frequency=self.key_pool_frequency,
                        key_pool=self.key_pool,
                    )
                    generator._max_depth = 10
                    yield generator.json()
                except RecursionError:
                    continue

        yield (test_client, input_generator())


class MutationBasedFuzzer(Fuzzer):
    def __init__(
        self,
        app: Flask,
        corpus: str = None,
        min_len: int = 1,
        max_len: int = 1000,
        min_mutations: int = 0,
        max_mutations: int = 10,
    ):
        self.flask_app = app
        self.corpus = corpus
        self.inputs = []
        self.load_corpus()

        self.min_len = min_len
        self.max_len = max_len
        self.min_mutations = min_mutations
        self.max_mutations = max_mutations

        # list of string mutators supported, along with corresponding side effects
        self.STRING_MUTATORS = {
            MutationBasedFuzzer.mutate_string_bit_flip: "none",
            MutationBasedFuzzer.mutate_string_add_sub_byte: "none",
            MutationBasedFuzzer.mutate_string_insert_character: "increase",
            MutationBasedFuzzer.mutate_string_delete_character: "decrease",
            MutationBasedFuzzer.mutate_string_swap_two_chars: "none",
            MutationBasedFuzzer.mutate_string_duplicate_substring: "increase",
            MutationBasedFuzzer.mutate_string_repeat_substring: "increase",
            MutationBasedFuzzer.mutate_string_delete_substring: "decrease",
        }

    def load_corpus(self):
        if not os.path.exists(self.corpus):
            raise FileNotFoundError(f"Corpus file not found: {self.corpus}")
        with open(self.corpus, "r") as f:
            self.inputs = [line.strip() for line in f if line.strip()]

    # string mutation methods
    @staticmethod
    def random_int(max: int) -> int:
        if max == 1 or max == 0:
            return 0
        return random.randint(0, max - 1)

    @staticmethod
    def mutate_string_bit_flip(input: str) -> str:
        if len(input) == 0:
            return input
        position = MutationBasedFuzzer.random_int(len(input))
        replacement_character = chr(
            ord(input[position]) ^ (1 << MutationBasedFuzzer.random_int(8))
        )
        mutation = input[0:position] + replacement_character + input[position + 1 :]
        return mutation

    @staticmethod
    def mutate_string_add_sub_byte(input: str) -> str:
        if len(input) == 0:
            return input
        position = MutationBasedFuzzer.random_int(len(input))
        delta = MutationBasedFuzzer.random_int(256)
        replacement_character = chr((ord(input[position]) + delta) % 256)
        mutation = input[0:position] + replacement_character + input[position + 1 :]
        return mutation

    @staticmethod
    def mutate_string_insert_character(input: str) -> str:
        if len(input) == 0:
            mutation = chr(MutationBasedFuzzer.random_int(256))
        position = MutationBasedFuzzer.random_int(len(input))
        character = chr(MutationBasedFuzzer.random_int(256))
        mutation = input[0:position] + character + input[position:]
        return mutation

    @staticmethod
    def mutate_string_delete_character(input: str) -> str:
        if len(input) == 0:
            return input
        position = MutationBasedFuzzer.random_int(len(input))
        mutation = input[: position - 1] + input[position]
        return mutation

    @staticmethod
    def mutate_string_swap_two_chars(input: str) -> str:
        if len(input) < 2:
            return input
        first_character_position = MutationBasedFuzzer.random_int(len(input))
        second_character_position = MutationBasedFuzzer.random_int(len(input))

        while first_character_position == second_character_position:
            second_character_position = MutationBasedFuzzer.random_int(len(input))

        mutation = list(input)
        (
            mutation[first_character_position],
            mutation[second_character_position],
        ) = (
            mutation[second_character_position],
            mutation[first_character_position],
        )
        mutation_str = "".join(mutation)
        return mutation_str

    @staticmethod
    def mutate_string_duplicate_substring(input: str) -> str:
        if len(input) < 2:
            return input
        first_character_position = MutationBasedFuzzer.random_int(len(input))
        second_character_position = random.randint(first_character_position, len(input))
        substring = input[first_character_position:second_character_position]

        substring_position = MutationBasedFuzzer.random_int(len(input))
        mutation = input[:substring_position] + substring + input[substring_position:]
        return mutation

    @staticmethod
    def mutate_string_repeat_substring(input: str) -> str:
        if len(input) < 2:
            return input
        first_character_position = MutationBasedFuzzer.random_int(len(input))
        second_character_position = random.randint(first_character_position, len(input))
        substring = input[first_character_position:second_character_position]
        mutation = (
            input[:second_character_position]
            + substring
            + input[second_character_position:]
        )
        return mutation

    @staticmethod
    def mutate_string_delete_substring(input: str) -> str:
        if len(input) < 2:
            return input
        first_character_position = MutationBasedFuzzer.random_int(len(input))
        second_character_position = random.randint(first_character_position, len(input))

        mutation = input[:first_character_position] + input[second_character_position:]
        return mutation

    def apply_mutations(self, input: str) -> str:
        """
        Applies random mutations to the input string
        Constrainted by min/max mutations and min/max length
        """
        num_mutations = random.randint(self.min_mutations, self.max_mutations)
        for _ in range(num_mutations):
            mutator, side_effect = random.choice(list(self.STRING_MUTATORS.items()))
            if (len(input) == self.max_len and side_effect == "increase") or (
                len(input) == self.min_len and side_effect == "decrease"
            ):
                break
            input = mutator(input)

        return input

    @contextmanager
    def get_context(self):  # type: ignore
        test_client = self.flask_app.test_client()

        def input_generator():
            while True:
                try:
                    input = random.choice(self.inputs)
                    yield self.apply_mutations(input)
                except Exception as e:
                    print(f"Exception: {e}")
                    continue

        yield (test_client, input_generator())


if __name__ == "__main__":
    app = Flask(__name__)
    g = MutationBasedFuzzer(
        app, corpus="plugins/cwe_78_os_command_injection/dictionary.txt"
    )

    with g.get_context() as (_, input_gen):
        for _, input_val in zip(range(20), input_gen):
            print(input_val)
