"""
Common utilities for this package.

@date: 30.06.2025
@author: Baptiste Pestourie
"""

from __future__ import annotations

import importlib
import os
import shutil
import sys
import tempfile
from contextlib import contextmanager
from types import ModuleType
from typing import Generator


# --- Errors ---
class SmeltError(Exception):
    """
    Base exception class for Smelt errors
    """


class SmeltMissingModule(SmeltError): ...


def get_extension_suffix(target_triple: str) -> str:
    """
    Generate the C extension module filename.

    Parameters
    ----------
    target_triple: str
        The target triple, e.g., 'aarch64-linux-gnu'.

    Returns
    -------
    str
        The extension filename, e.g., '.cpython-312-aarch64-linux-gnu.so'
    """
    major = sys.version_info.major
    minor = sys.version_info.minor
    return f".cpython-{major}{minor}-{target_triple}.so"


@contextmanager
def import_shadowed_module(path: str) -> Generator[ModuleType, None, None]:
    """
    Allows importting a .py module shadowed by its .so counterpart
    (typically generated by mypy).
    .so python modules (generally, compiled C extensions) have higher priority on import
    over .py modules. This is is done so that module can provide optional C extensions
    with a pure Python implementation as fallback (e.g., if the interpreter is not CPython,
    or if the C extension cannot be compiled for the target platform)

    This function temporarily REMOVES the .so and proceeds to import the shadowed.
    It is a context manager and will restore the removed .so on exit,
    unless a new version has been built in the meantime (e.g., if the import
    was required as part of a recompile process)
    """
    with tempfile.TemporaryDirectory() as tmp:
        try:
            mod = importlib.import_module(path)
        except ImportError as exc:
            msg = f"Failed to import {path} while trying to mypycify"
            raise SmeltMissingModule(msg) from exc
        mod_path = mod.__file__
        assert mod_path is not None, f"Cannot module to mypycify: {path}"
        if mod_path.endswith((".py", ".pyc")):
            yield mod
        else:
            backup_path = os.path.join(tmp, os.path.basename(mod_path))
            shutil.copy(mod_path, backup_path)
            os.remove(mod_path)
            os.sync()

            try:
                # using reload as otherwise importlib will use the cache
                # and re-import the now deleted .so
                mod = importlib.reload(mod)
                assert mod.__file__ is not None and not (mod.__file__.endswith(".so"))
                yield mod
            except ImportError as exc:
                msg = f"Failed to import {path} while trying to mypycify"
                raise SmeltMissingModule(msg) from exc
