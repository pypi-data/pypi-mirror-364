{
  "hash": "c5d534abe98787b696c968f1987d5305",
  "result": {
    "markdown": "---\nengine: knitr\n---\n\n\n# Advanced Group Usage\n\nThis is a tutorial on how Liesel's {class}`.Group` class can be used to derive\nnew classes that represent re-usable model parts. This tutorial covers the\nfollowing parts:\n\n1. Derive new classes from {class}`.Group` to represent related {class}`.Var`s.\n2. Use these groups to create a Gibbs kernel.\n\n\n\n## Background\n\nAs the topic for this group tutorial, we will create groups for a semiparametric\nregression model using Bayesian P-Splines. In this tutorial, we only give\nminimal background on the model itself - instead, for details on the model, the\ninterested reader should consider the original paper by [Lang & Brezger\n(2012)](https://doi.org/10.1198/1061860043010).\n\nIn Bayesian P-Splines, we try to estimate a function $f(x)$ of a covariate $x$ - which\nmay, for example, represent the relationship between $x$ and the response's mean. To\nimplement the estination, we parameterize the functione estimate by the product of\na design matrix of basis function evaluations $\\boldsymbol{B}(x)$ and a vector of\nspline coefficients $\\boldsymbol{\\beta}$, i.e.\n$f(x) \\approx \\boldsymbol{B}(x)\\boldsymbol{\\beta}$.\nThe goal is to estimate $\\boldsymbol{\\beta}$. In Bayesian P-Splines, we are commonly\nworking with a rank-deficient (degenerate) multivariate normal prior on\n$\\boldsymbol{\\beta}$. The unnormalized prior can be written as\n\n$$\np(\\boldsymbol{\\beta}) \\propto \\exp\\left(\n    - \\frac{1}{2\\tau^2}\n    \\boldsymbol{\\beta}^T \\boldsymbol{K} \\boldsymbol{\\beta}\n    \\right),\n$$\n\nwhere $\\boldsymbol{K}$ is an appropriately defined penalty matrix, commonly a\nrank-deficient squared second order difference matrix where the variance and the\nparameter $\\tau^2$ controls the amount of strength of the penalty (usually a\nlarge $\\tau^2$ allows for a wiggly function) and corresponds to an inverse\nsmoothing parameter.\n\nIn Bayesian P-Splines, the variance parameter $\\tau^2$ receives a hyperprior. A\ncommon choice is to set\n\n$$\n\\tau^2 \\sim \\text{InverseGamma}(a, b)\n$$\n\nwith shape $a$ and scale $b$ as hyperparameters. We will create one group each\nfor $\\tau^2$ and for $\\boldsymbol{\\beta}$. Then, we will create an overarching\ngroup that represents a complete P-Spline.\n\n## Setup\n\nWe start by importing the modules that we are going to use in this tutorial.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport jax.numpy as jnp\nimport jax\nimport tensorflow_probability.substrates.jax.distributions as tfd\n\nimport liesel.model as lsl\nimport liesel.goose as gs\nfrom liesel.distributions.mvn_degen import MultivariateNormalDegenerate\nfrom liesel.goose.types import Array\n```\n:::\n\n\n\n## Define groups\n\n### Inverse smoothing parameter $\\tau^2$\n\nThis is straight-forward group: We initialize it with a name, values for the\nhyperparameters of the inverse gamma prior, and an initial value for $\\tau^2$.\n\nTo do so, we simply overload the `__init__` method, use this method to create\nthe needed {class}`.Var`s and finalize initialization by calling the `__init__`\nof the parent class. This last step makes sure that the individual nodes are\ncorrectly informed about their group membership.\n\nNote that we use the group name here as the prefix the for names of the\nindividual variables inside the group. That makes it easy to make these names\nunique within a model, which is a requirement for Liesel.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass VarianceIG(lsl.Group):\n    def __init__(\n        self, name: str, a: float, b: float, start_value: float = 1000.0\n    ) -> None:\n        a_var = lsl.Var(a, name=f\"{name}_a\")\n        b_var = lsl.Var(b, name=f\"{name}_b\")\n\n        prior = lsl.Dist(tfd.InverseGamma, concentration=a_var, scale=b_var)\n        tau2 = lsl.Var.new_param(start_value, distribution=prior, name=name)\n        super().__init__(name=name, a=a_var, b=b_var, tau2=tau2)\n```\n:::\n\n\n\n### Spline coefficient\n\nNext, we create the group for our spline coefficient in a very similar way.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass SplineCoef(lsl.Group):\n    def __init__(self, name: str, penalty: Array, tau2: lsl.param) -> None:\n        penalty_var = lsl.Var(penalty, name=f\"{name}_penalty\")\n\n        evals = jax.numpy.linalg.eigvalsh(penalty)\n        rank = lsl.Value(jnp.sum(evals > 0.0), _name=f\"{name}_rank\")\n        _log_pdet = jnp.log(jnp.where(evals > 0.0, evals, 1.0)).sum()\n        log_pdet = lsl.Value(_log_pdet, _name=f\"{name}_log_pdet\")\n\n        prior = lsl.Dist(\n            MultivariateNormalDegenerate.from_penalty,\n            loc=0.0,\n            var=tau2,\n            pen=penalty_var,\n            rank=rank,\n            log_pdet=log_pdet\n        )\n        start_value = np.zeros(np.shape(penalty)[-1], np.float32)\n\n        coef = lsl.Var.new_param(start_value, distribution=prior, name=name)\n\n        super().__init__(name, coef=coef, penalty=penalty_var, tau2=tau2, rank=rank)\n\n```\n:::\n\n\n\n## Use groups\n\nWe can use these groups to quickly create model building blocks and access their\nelements:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntau2_group = VarianceIG(name=\"tau2\", a=0.01, b=0.01)\n\nprint(tau2_group[\"tau2\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVar(name=\"tau2\")\n```\n:::\n:::\n\n\nWe can directly use the `tau2_group` to create an instance of\n`SplineCoef`:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsecond_diff = np.diff(np.eye(10), n=2, axis=0)\npenalty = second_diff.T @ second_diff\ncoef_group = SplineCoef(name=\"coef\", penalty=penalty, tau2=tau2_group[\"tau2\"])\n```\n:::\n\n\nEach group offers access to all its members through `mappingproxy` instances, which are\nbasically immutable dictionaries:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntau2_group.vars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmappingproxy({'a': Var(name=\"tau2_a\"), 'b': Var(name=\"tau2_b\"), 'tau2': Var(name=\"tau2\")})\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncoef_group.vars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmappingproxy({'coef': Var(name=\"coef\"), 'penalty': Var(name=\"coef_penalty\"), 'tau2': Var(name=\"tau2\")})\n```\n:::\n:::\n\n\n## A complete P-Spline group\n\nIn this last step, we create an overarching group that incorporates the observed\nbasis matrix of our spline and evaluates the estimated\nfunction $\\hat{f}(x) = \\boldsymbol{B}(x)\\hat{\\boldsymbol{\\beta}}$. Note the following:\n\n1. Here, we create a `SplineCoef` instance *inside* the new group's `__init__`, because\n   this step is always the same with P-Splines, once we know the penalty and the variance\n   parameter $\\tau^2$.\n2. We do not automatically create an instance of our `IGVariance` group for the variance\n   parameter, but allow users to pass any fitting group instance to the class. This makes\n   our `PSpline` class very flexible: we could easily replace the `IGVariance` group\n   with another group that represents a different prior for $\\tau^2$. For this `PSpline`\n   group, it is only important that there is a key `\"tau2\"` in the `tau2_group`.\n3. In the code below, we represent $\\hat{f}(x)$ with a variable named `smooth` to stay\n   consistent with the terminology used in {class}`.DistRegBuilder`.\n4. In our `super().__init__` call at the end, we make sure to add not only the\n   Vars `basis_matrix` and `smooth` that we directly created, but also all\n   members of the `coef_group` and `tau2_group`. That way, we can access all\n   relevant vars just from this overarching `PSpline` group.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass PSpline(lsl.Group):\n    def __init__(\n        self, name, basis_matrix: Array, penalty: Array, tau2_group: lsl.Group\n    ) -> None:\n        coef_group = SplineCoef(\n            name=f\"{name}_coef\", penalty=penalty, tau2=tau2_group[\"tau2\"]\n        )\n\n        basis_matrix = lsl.Var.new_obs(basis_matrix, name=f\"{name}_basis_matrix\")\n        smooth = lsl.Var(\n            lsl.Calc(jnp.dot, basis_matrix, coef_group[\"coef\"]), name=name\n        )\n\n        group_vars = coef_group.nodes_and_vars | tau2_group.nodes_and_vars\n\n        super().__init__(\n            name=name,\n            basis_matrix=basis_matrix,\n            smooth=smooth,\n            **group_vars\n        )\n```\n:::\n\n\nOf course it may be convenient to specialize this `PSpline` group, depending on\nyour usage. For example, we could imagine to adapt it to an `IGPSpline` group\nthat works on the assumption that you want to use an inverse gamma prior on\n$\\tau^2$. Such a group would require the input parameters `a` and `b` instead of\nthe `tau2_group`. The latter would be created automatically, just as the\n`coef_group` is in the code snippet above.\n\n### Group graph\n\nTo see what we have created, let's initialize a toy example of our group to look\nat the resulting graph. First, we create the group:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nbasis_matrix = np.random.uniform(size=(15, 10)) # NOT a valid basis matrix, just for show!\n\nsecond_diff = np.diff(np.eye(10), n=2, axis=0)\npenalty = second_diff.T @ second_diff\n\ntau2_group = VarianceIG(name=\"tau2\", a=0.01, b=0.01)\np_spline = PSpline(name=\"p_spline\", basis_matrix=basis_matrix, penalty=penalty, tau2_group=tau2_group)\n```\n:::\n\n\nNext, we add this group to a {class}`.GraphBuilder`, build a model and plot the\ngraph:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmodel = lsl.GraphBuilder().add_groups(p_spline).build_model()\n\nlsl.plot_vars(model)\n```\n\n::: {.cell-output-display}\n![](07-groups_files/figure-commonmark/group-graph-1.png)\n:::\n:::\n\n\n## Use group to build a Gibbs sampler\n\nWhen we use an inverse gamma prior for $\\tau^2$, we can set up a Gibbs sampler\nto sample from the posterior distribution of $\\tau^2$. In Liesel, we can\nconveniently define a {class}`~.goose.GibbsKernel` simply by supplying a stateless\n`transition` function and the name of the corresponding variable. Groups can\nhelp us to make this process modular, because they provide an interface with\nreliable and human-readable names for our variables.\n\nWhat we actually want to do is to create a factory-function that takes our\n`PSpline` group as the input, creates an appropriate `transition` function under\nthe hood and finally returns a fully functioning `GibbsKernel`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef tau2_gibbs_kernel(p_spline: PSpline) -> gs.GibbsKernel:\n    \"\"\"Builds a Gibbs kernel for a smoothing parameter with an inverse gamma prior.\"\"\"\n    position_key = p_spline[\"tau2\"].name\n\n    def transition(prng_key, model_state):\n        a_prior = p_spline.value_from(model_state, \"a\")\n        b_prior = p_spline.value_from(model_state, \"b\")\n\n        rank = p_spline.value_from(model_state, \"rank\")\n        K = p_spline.value_from(model_state, \"penalty\")\n\n        beta = p_spline.value_from(model_state, \"coef\")\n\n        a_gibbs = jnp.squeeze(a_prior + 0.5 * rank)\n        b_gibbs = jnp.squeeze(b_prior + 0.5 * (beta @ K @ beta))\n\n        draw = b_gibbs / jax.random.gamma(prng_key, a_gibbs)\n\n        return {position_key: draw}\n\n    return gs.GibbsKernel([position_key], transition)\n```\n:::\n\n\nMost of the work here is done by the {meth}`.Group.value_from` method, which is\nnothing more than syntactic sugar for extracting a variable's value from a model\nstate using only the short and meaningful name of that variable *within* its\ngroup. For example, the call\n\n```python\nbeta = p_spline.value_from(model_state, \"coef\")\n```\n\nreplaces a call like the following:\n\n```python\nbeta = model_state[\"long_unique_variable_name_coef\"]\n```\n\n## Supercharging your groups\n\nGroups are convenient tools for building re-usable model components. But with\ntwo simple tricks, they can be even more powerful:\n\n1. Assign group members as attributes to the group. This enables syntax\n   completion - do I need to say more?\n2. Document the group's init parameters and attributes. This will make your code\n   much more re-usable by your future self and maybe even by other users.\n\nLet's consider an example using our `IGVariance` class from above:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass VarianceIG(lsl.Group):\n    \"\"\"\n    Variance parameter with an inverse gamma prior.\n\n    Parameters\n    ----------\n    name\n        Group name. Will also be used as the name for the variance parameter variable.\n    a\n        Prior shape.\n    b\n        Prior scale.\n    \"\"\"\n    def __init__(\n        self, name: str, a: float, b: float, start_value: float = 1000.0\n    ) -> None:\n        self.a = lsl.Var(a, name=\"f{name}_a\")\n        \"\"\"Prior shape variable.\"\"\"\n\n        self.b = lsl.Var(b, name=\"f{name}_b\")\n        \"\"\"Prior scale variable.\"\"\"\n\n        prior = lsl.Dist(tfd.InverseGamma, concentration=self.a, scale=self.b)\n\n        self.tau2 = lsl.Var.new_param(start_value, distribution=prior, name=name)\n        \"\"\"Variance parameter variable.\"\"\"\n\n        super().__init__(name=name, a=self.a, b=self.b, tau2=self.tau2)\n```\n:::\n\n\nThis concludes our tutorial on group usage.\n",
    "supporting": [
      "07-groups_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}