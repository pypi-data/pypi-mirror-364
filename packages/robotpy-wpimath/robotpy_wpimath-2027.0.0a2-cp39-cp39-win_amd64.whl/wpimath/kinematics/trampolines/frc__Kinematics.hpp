// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/kinematics/Kinematics.h>

// from extra_includes
#include <frc/kinematics/DifferentialDriveWheelPositions.h>
#include <frc/kinematics/DifferentialDriveWheelSpeeds.h>
#include <frc/kinematics/MecanumDriveWheelPositions.h>
#include <frc/kinematics/MecanumDriveWheelSpeeds.h>
#include <frc/kinematics/SwerveDriveKinematics.h>

namespace frc {

template <typename WheelSpeeds, typename WheelPositions, typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_Kinematics : CfgBase
{
  using Base = frc::Kinematics<WheelSpeeds, WheelPositions>;
  using override_base_KToChassisSpeeds_KRTWheelSpeeds = frc::Kinematics<WheelSpeeds, WheelPositions>;
  using override_base_KToWheelSpeeds_KRTChassisSpeeds = frc::Kinematics<WheelSpeeds, WheelPositions>;
  using override_base_KToTwist2d_KRTWheelPositions_KRTWheelPositions = frc::Kinematics<WheelSpeeds, WheelPositions>;
  using override_base_KInterpolate_KRTWheelPositions_KRTWheelPositions_d = frc::Kinematics<WheelSpeeds, WheelPositions>;
};

template <typename PyTrampolineBase, typename WheelSpeeds, typename WheelPositions, typename PyTrampolineCfg>
struct PyTrampoline_Kinematics : PyTrampolineBase {
  using PyTrampolineBase::PyTrampolineBase;

  #ifndef SWGEN_DISABLE_KToChassisSpeeds_KRTWheelSpeeds
    ChassisSpeeds ToChassisSpeeds(const WheelSpeeds& wheelSpeeds) const override {
      using LookupBase = typename PyTrampolineCfg::Base;
      SEMIWRAP_OVERRIDE_PURE_NAME(Kinematics, PYBIND11_TYPE(ChassisSpeeds), LookupBase,
        "toChassisSpeeds", ToChassisSpeeds, wheelSpeeds);
    }
  #endif

  #ifndef SWGEN_DISABLE_KToWheelSpeeds_KRTChassisSpeeds
    WheelSpeeds ToWheelSpeeds(const ChassisSpeeds& chassisSpeeds) const override {
      using LookupBase = typename PyTrampolineCfg::Base;
      SEMIWRAP_OVERRIDE_PURE_NAME(Kinematics, PYBIND11_TYPE(WheelSpeeds), LookupBase,
        "toWheelSpeeds", ToWheelSpeeds, chassisSpeeds);
    }
  #endif

  #ifndef SWGEN_DISABLE_KToTwist2d_KRTWheelPositions_KRTWheelPositions
    Twist2d ToTwist2d(const WheelPositions& start, const WheelPositions& end) const override {
      using LookupBase = typename PyTrampolineCfg::Base;
      SEMIWRAP_OVERRIDE_PURE_NAME(Kinematics, PYBIND11_TYPE(Twist2d), LookupBase,
        "toTwist2d", ToTwist2d, start, end);
    }
  #endif

  #ifndef SWGEN_DISABLE_KInterpolate_KRTWheelPositions_KRTWheelPositions_d
    WheelPositions Interpolate(const WheelPositions& start, const WheelPositions& end, double t) const override {
      using LookupBase = typename PyTrampolineCfg::Base;
      SEMIWRAP_OVERRIDE_PURE_NAME(Kinematics, PYBIND11_TYPE(WheelPositions), LookupBase,
        "interpolate", Interpolate, start, end, t);
    }
  #endif
};

}; // namespace frc

#include <wpi_array_type_caster.h>

namespace swgen {

using namespace frc;

template <typename WheelSpeeds, typename WheelPositions>
struct bind_frc__Kinematics {
  struct Kinematics_Trampoline : frc::PyTrampoline_Kinematics<typename frc::Kinematics<WheelSpeeds, WheelPositions>, WheelSpeeds, WheelPositions, typename frc::PyTrampolineCfg_Kinematics<WheelSpeeds, WheelPositions>>, py::trampoline_self_life_support {
      using RpyBase = frc::PyTrampoline_Kinematics<typename frc::Kinematics<WheelSpeeds, WheelPositions>, WheelSpeeds, WheelPositions, typename frc::PyTrampolineCfg_Kinematics<WheelSpeeds, WheelPositions>>;
      using RpyBase::RpyBase;
  };
  static_assert(std::is_abstract<Kinematics_Trampoline>::value == false, "frc::Kinematics<WheelSpeeds, WheelPositions> " SEMIWRAP_BAD_TRAMPOLINE);
  py::class_<typename frc::Kinematics<WheelSpeeds, WheelPositions>, py::smart_holder, Kinematics_Trampoline> cls_Kinematics;

  py::module &m;
  std::string clsName;
  bind_frc__Kinematics(py::module &m, const char * clsName) :
    cls_Kinematics(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_Kinematics.doc() = 
      "Helper class that converts a chassis velocity (dx, dy, and dtheta components)\n"
      "into individual wheel speeds. Robot code should not use this directly-\n"
      "Instead, use the particular type for your drivetrain (e.g.,\n"
      "DifferentialDriveKinematics).\n"
      "\n"
      "Inverse kinematics converts a desired chassis speed into wheel speeds whereas\n"
      "forward kinematics converts wheel speeds into chassis speed.";
    cls_Kinematics
      .def(py::init<>(), release_gil())
      .def("toChassisSpeeds", &frc::Kinematics<WheelSpeeds, WheelPositions>::ToChassisSpeeds
        , py::arg("wheelSpeeds")
        , release_gil()
        , py::doc(
        "Performs forward kinematics to return the resulting chassis speed from the\n"
        "wheel speeds. This method is often used for odometry -- determining the\n"
        "robot's position on the field using data from the real-world speed of each\n"
        "wheel on the robot.\n"
        "\n"
        ":param wheelSpeeds: The speeds of the wheels.\n"
        "\n"
        ":returns: The chassis speed.")
      )
      .def("toWheelSpeeds", &frc::Kinematics<WheelSpeeds, WheelPositions>::ToWheelSpeeds
        , py::arg("chassisSpeeds")
        , release_gil()
        , py::doc(
        "Performs inverse kinematics to return the wheel speeds from a desired\n"
        "chassis velocity. This method is often used to convert joystick values into\n"
        "wheel speeds.\n"
        "\n"
        ":param chassisSpeeds: The desired chassis speed.\n"
        "\n"
        ":returns: The wheel speeds.")
      )
      .def("toTwist2d", &frc::Kinematics<WheelSpeeds, WheelPositions>::ToTwist2d
        , py::arg("start"), py::arg("end")
        , release_gil()
        , py::doc(
        "Performs forward kinematics to return the resulting Twist2d from the given\n"
        "change in wheel positions. This method is often used for odometry --\n"
        "determining the robot's position on the field using changes in the distance\n"
        "driven by each wheel on the robot.\n"
        "\n"
        ":param start: The starting distances driven by the wheels.\n"
        ":param end:   The ending distances driven by the wheels.\n"
        "\n"
        ":returns: The resulting Twist2d in the robot's movement.")
      )
      .def("interpolate", &frc::Kinematics<WheelSpeeds, WheelPositions>::Interpolate
        , py::arg("start"), py::arg("end"), py::arg("t")
        , release_gil()
        , py::doc(
        "Performs interpolation between two values.\n"
        "\n"
        ":param start: The value to start at.\n"
        ":param end:   The value to end at.\n"
        ":param t:     How far between the two values to interpolate. This should be\n"
        "              bounded to [0, 1].\n"
        "\n"
        ":returns: The interpolated value.")
      )
    ;
    if (set_doc) {
      cls_Kinematics.doc() = set_doc;
    }
    if (add_doc) {
      cls_Kinematics.doc() = py::cast<std::string>(cls_Kinematics.doc()) + add_doc;
    }
  }
}; // struct bind_frc__Kinematics

}; // namespace swgen
