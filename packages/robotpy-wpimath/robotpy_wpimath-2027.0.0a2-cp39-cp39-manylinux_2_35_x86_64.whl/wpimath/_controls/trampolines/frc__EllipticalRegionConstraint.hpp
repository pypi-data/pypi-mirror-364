// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/trajectory/constraint/EllipticalRegionConstraint.h>

// from extra_includes
#include <PyTrajectoryConstraint.h>

#include <trampolines/frc__TrajectoryConstraint.hpp>

namespace frc {

template <typename Constraint, typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_EllipticalRegionConstraint :
  frc::PyTrampolineCfg_TrajectoryConstraint<
  CfgBase
  >
{
  using Base = frc::EllipticalRegionConstraint<Constraint>;
  using override_base_KMaxVelocity_KRTPose2d_Tcurvature_t_Tmeters_per_second_t = frc::EllipticalRegionConstraint<Constraint>;
  using override_base_KMinMaxAcceleration_KRTPose2d_Tcurvature_t_Tmeters_per_second_t = frc::EllipticalRegionConstraint<Constraint>;
};

template <typename PyTrampolineBase, typename Constraint, typename PyTrampolineCfg>
using PyTrampolineBase_EllipticalRegionConstraint =
  frc::PyTrampoline_TrajectoryConstraint<
    PyTrampolineBase
    , PyTrampolineCfg>
;

template <typename PyTrampolineBase, typename Constraint, typename PyTrampolineCfg>
struct PyTrampoline_EllipticalRegionConstraint : PyTrampolineBase_EllipticalRegionConstraint<PyTrampolineBase, Constraint, PyTrampolineCfg> {
  using PyTrampolineBase_EllipticalRegionConstraint<PyTrampolineBase, Constraint, PyTrampolineCfg>::PyTrampolineBase_EllipticalRegionConstraint;
  using MinMax = frc::TrajectoryConstraint::MinMax;

  #ifndef SWGEN_DISABLE_KMaxVelocity_KRTPose2d_Tcurvature_t_Tmeters_per_second_t
    units::meters_per_second_t MaxVelocity(const Pose2d& pose, units::curvature_t curvature, units::meters_per_second_t velocity) const override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_KMaxVelocity_KRTPose2d_Tcurvature_t_Tmeters_per_second_t;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(units::meters_per_second_t), LookupBase,
        "maxVelocity", pose, curvature, velocity);
      return CxxCallBase::MaxVelocity(std::forward<decltype(pose)>(pose), std::move(curvature), std::move(velocity));
    }
  #endif

  #ifndef SWGEN_DISABLE_KMinMaxAcceleration_KRTPose2d_Tcurvature_t_Tmeters_per_second_t
    MinMax MinMaxAcceleration(const Pose2d& pose, units::curvature_t curvature, units::meters_per_second_t speed) const override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_KMinMaxAcceleration_KRTPose2d_Tcurvature_t_Tmeters_per_second_t;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(MinMax), LookupBase,
        "minMaxAcceleration", pose, curvature, speed);
      return CxxCallBase::MinMaxAcceleration(std::forward<decltype(pose)>(pose), std::move(curvature), std::move(speed));
    }
  #endif
};

}; // namespace frc

#include <units_compound_type_caster.h>
#include <units_length_type_caster.h>
#include <units_velocity_type_caster.h>

namespace swgen {

using namespace frc;

template <typename Constraint>
struct bind_frc__EllipticalRegionConstraint {
  using MinMax = frc::TrajectoryConstraint::MinMax;
  struct EllipticalRegionConstraint_Trampoline : frc::PyTrampoline_EllipticalRegionConstraint<typename frc::EllipticalRegionConstraint<Constraint>, Constraint, typename frc::PyTrampolineCfg_EllipticalRegionConstraint<Constraint>>, py::trampoline_self_life_support {
      using RpyBase = frc::PyTrampoline_EllipticalRegionConstraint<typename frc::EllipticalRegionConstraint<Constraint>, Constraint, typename frc::PyTrampolineCfg_EllipticalRegionConstraint<Constraint>>;
      using RpyBase::RpyBase;
  };
  static_assert(std::is_abstract<EllipticalRegionConstraint_Trampoline>::value == false, "frc::EllipticalRegionConstraint<Constraint> " SEMIWRAP_BAD_TRAMPOLINE);
  py::class_<typename frc::EllipticalRegionConstraint<Constraint>, py::smart_holder, EllipticalRegionConstraint_Trampoline, frc::TrajectoryConstraint> cls_EllipticalRegionConstraint;

  py::module &m;
  std::string clsName;
  bind_frc__EllipticalRegionConstraint(py::module &m, const char * clsName) :
    cls_EllipticalRegionConstraint(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_EllipticalRegionConstraint.doc() = "Enforces a particular constraint only within an elliptical region.";
    cls_EllipticalRegionConstraint
      .def(py::init<const Translation2d&, units::meter_t, units::meter_t, const Rotation2d&, const Constraint&>()
        , py::arg("center"), py::arg("xWidth"), py::arg("yWidth"), py::arg("rotation"), py::arg("constraint")
        , release_gil(), py::keep_alive<1, 2>(), py::keep_alive<1, 5>(), py::keep_alive<1, 6>()
        , py::doc(
        "Constructs a new EllipticalRegionConstraint.\n"
        "\n"
        ":deprecated: Use constructor taking Ellipse2d instead.\n"
        "\n"
        ":param center:     The center of the ellipse in which to enforce the constraint.\n"
        ":param xWidth:     The width of the ellipse in which to enforce the constraint.\n"
        ":param yWidth:     The height of the ellipse in which to enforce the constraint.\n"
        ":param rotation:   The rotation to apply to all radii around the origin.\n"
        ":param constraint: The constraint to enforce when the robot is within the\n"
        "                   region.")
      )
      .def(py::init<const Ellipse2d&, const Constraint&>()
        , py::arg("ellipse"), py::arg("constraint")
        , release_gil(), py::keep_alive<1, 2>(), py::keep_alive<1, 3>()
        , py::doc(
        "Constructs a new EllipticalRegionConstraint.\n"
        "\n"
        ":param ellipse:    The ellipse in which to enforce the constraint.\n"
        ":param constraint: The constraint to enforce when the robot is within the\n"
        "                   region.")
      )
      .def("maxVelocity", &frc::EllipticalRegionConstraint<Constraint>::MaxVelocity
        , py::arg("pose"), py::arg("curvature"), py::arg("velocity")
        , release_gil()
      )
      .def("minMaxAcceleration", &frc::EllipticalRegionConstraint<Constraint>::MinMaxAcceleration
        , py::arg("pose"), py::arg("curvature"), py::arg("speed")
        , release_gil()
      )
    ;
    if (set_doc) {
      cls_EllipticalRegionConstraint.doc() = set_doc;
    }
    if (add_doc) {
      cls_EllipticalRegionConstraint.doc() = py::cast<std::string>(cls_EllipticalRegionConstraint.doc()) + add_doc;
    }

    cls_EllipticalRegionConstraint
      .def_static("fromFeet", [](const Translation2d& center, units::foot_t xWidth,
                                 units::foot_t yWidth, const Rotation2d& rotation,
                                 const Constraint& constraint) {
        return std::make_shared<EllipticalRegionConstraint<Constraint>>(center, xWidth, yWidth, rotation, constraint);
      }, py::arg("center"), py::arg("xWidth"), py::arg("yWidth"), py::arg("rotation"), py::arg("constraint"))
    ;
  }
}; // struct bind_frc__EllipticalRegionConstraint

}; // namespace swgen
