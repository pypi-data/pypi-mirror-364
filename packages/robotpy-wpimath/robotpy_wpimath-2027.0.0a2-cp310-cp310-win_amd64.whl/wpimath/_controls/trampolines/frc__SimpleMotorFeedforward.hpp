// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <frc/controller/SimpleMotorFeedforward.h>

// from extra_includes
#include <units/dimensionless.h>

#include <units_acceleration_type_caster.h>
#include <units_angle_type_caster.h>
#include <units_angular_acceleration_type_caster.h>
#include <units_angular_velocity_type_caster.h>
#include <units_compound_type_caster.h>
#include <units_length_type_caster.h>
#include <units_time_type_caster.h>
#include <units_velocity_type_caster.h>
#include <units_voltage_type_caster.h>

namespace swgen {

using namespace frc;

template <typename Distance>
struct bind_frc__SimpleMotorFeedforward {
  using Velocity = typename frc::SimpleMotorFeedforward<Distance>::Velocity;
  using Acceleration = typename frc::SimpleMotorFeedforward<Distance>::Acceleration;
  using kv_unit = typename frc::SimpleMotorFeedforward<Distance>::kv_unit;
  using ka_unit = typename frc::SimpleMotorFeedforward<Distance>::ka_unit;
  py::class_<typename frc::SimpleMotorFeedforward<Distance>, py::smart_holder> cls_SimpleMotorFeedforward;

  py::module &m;
  std::string clsName;
  bind_frc__SimpleMotorFeedforward(py::module &m, const char * clsName) :
    cls_SimpleMotorFeedforward(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_SimpleMotorFeedforward.doc() = 
      "A helper class that computes feedforward voltages for a simple\n"
      "permanent-magnet DC motor.";
    cls_SimpleMotorFeedforward
      .def(py::init<units::volt_t, units::unit_t<kv_unit>, units::unit_t<ka_unit>, units::second_t>()
        , py::arg("kS"), py::arg("kV"), py::arg("kA") = units::unit_t<ka_unit> (0), py::arg("dt") = (units::second_t)20_ms
        , release_gil()
        , py::doc(
        "Creates a new SimpleMotorFeedforward with the specified gains.\n"
        "\n"
        ":param kS: The static gain, in volts.\n"
        ":param kV: The velocity gain, in volt seconds per distance.\n"
        ":param kA: The acceleration gain, in volt secondsÂ² per distance.\n"
        ":param dt: The period in seconds.\n"
        "           @throws IllegalArgumentException for kv &lt; zero.\n"
        "           @throws IllegalArgumentException for ka &lt; zero.\n"
        "           @throws IllegalArgumentException for period &le; zero.")
      )
      .def("calculate", static_cast<units::volt_t (frc::SimpleMotorFeedforward<Distance>::*)(units::unit_t<Velocity>) const>(&frc::SimpleMotorFeedforward<Distance>::Calculate)
        , py::arg("velocity")
        , release_gil()
        , py::doc(
        "Calculates the feedforward from the gains and velocity setpoint assuming\n"
        "discrete control. Use this method when the velocity setpoint does not\n"
        "change.\n"
        "\n"
        ":param velocity: The velocity setpoint.\n"
        "\n"
        ":returns: The computed feedforward, in volts.")
      )
      .def("calculate", static_cast<units::volt_t (frc::SimpleMotorFeedforward<Distance>::*)(units::unit_t<Velocity>, units::unit_t<Velocity>) const>(&frc::SimpleMotorFeedforward<Distance>::Calculate)
        , py::arg("currentVelocity"), py::arg("nextVelocity")
        , release_gil()
        , py::doc(
        "Calculates the feedforward from the gains and setpoints assuming discrete\n"
        "control.\n"
        "\n"
        "Note this method is inaccurate when the velocity crosses 0.\n"
        "\n"
        ":param currentVelocity: The current velocity setpoint.\n"
        ":param nextVelocity:    The next velocity setpoint.\n"
        "\n"
        ":returns: The computed feedforward, in volts.")
      )
      .def("maxAchievableVelocity", &frc::SimpleMotorFeedforward<Distance>::MaxAchievableVelocity
        , py::arg("maxVoltage"), py::arg("acceleration")
        , release_gil()
        , py::doc(
        "Calculates the maximum achievable velocity given a maximum voltage supply\n"
        "and an acceleration.  Useful for ensuring that velocity and\n"
        "acceleration constraints for a trapezoidal profile are simultaneously\n"
        "achievable - enter the acceleration constraint, and this will give you\n"
        "a simultaneously-achievable velocity constraint.\n"
        "\n"
        ":param maxVoltage:   The maximum voltage that can be supplied to the motor.\n"
        ":param acceleration: The acceleration of the motor.\n"
        "\n"
        ":returns: The maximum possible velocity at the given acceleration.")
      )
      .def("minAchievableVelocity", &frc::SimpleMotorFeedforward<Distance>::MinAchievableVelocity
        , py::arg("maxVoltage"), py::arg("acceleration")
        , release_gil()
        , py::doc(
        "Calculates the minimum achievable velocity given a maximum voltage supply\n"
        "and an acceleration.  Useful for ensuring that velocity and\n"
        "acceleration constraints for a trapezoidal profile are simultaneously\n"
        "achievable - enter the acceleration constraint, and this will give you\n"
        "a simultaneously-achievable velocity constraint.\n"
        "\n"
        ":param maxVoltage:   The maximum voltage that can be supplied to the motor.\n"
        ":param acceleration: The acceleration of the motor.\n"
        "\n"
        ":returns: The minimum possible velocity at the given acceleration.")
      )
      .def("maxAchievableAcceleration", &frc::SimpleMotorFeedforward<Distance>::MaxAchievableAcceleration
        , py::arg("maxVoltage"), py::arg("velocity")
        , release_gil()
        , py::doc(
        "Calculates the maximum achievable acceleration given a maximum voltage\n"
        "supply and a velocity. Useful for ensuring that velocity and\n"
        "acceleration constraints for a trapezoidal profile are simultaneously\n"
        "achievable - enter the velocity constraint, and this will give you\n"
        "a simultaneously-achievable acceleration constraint.\n"
        "\n"
        ":param maxVoltage: The maximum voltage that can be supplied to the motor.\n"
        ":param velocity:   The velocity of the motor.\n"
        "\n"
        ":returns: The maximum possible acceleration at the given velocity.")
      )
      .def("minAchievableAcceleration", &frc::SimpleMotorFeedforward<Distance>::MinAchievableAcceleration
        , py::arg("maxVoltage"), py::arg("velocity")
        , release_gil()
        , py::doc(
        "Calculates the minimum achievable acceleration given a maximum voltage\n"
        "supply and a velocity. Useful for ensuring that velocity and\n"
        "acceleration constraints for a trapezoidal profile are simultaneously\n"
        "achievable - enter the velocity constraint, and this will give you\n"
        "a simultaneously-achievable acceleration constraint.\n"
        "\n"
        ":param maxVoltage: The maximum voltage that can be supplied to the motor.\n"
        ":param velocity:   The velocity of the motor.\n"
        "\n"
        ":returns: The minimum possible acceleration at the given velocity.")
      )
      .def("setKs", &frc::SimpleMotorFeedforward<Distance>::SetKs
        , py::arg("kS")
        , release_gil()
        , py::doc(
        "Sets the static gain.\n"
        "\n"
        ":param kS: The static gain.")
      )
      .def("setKv", &frc::SimpleMotorFeedforward<Distance>::SetKv
        , py::arg("kV")
        , release_gil()
        , py::doc(
        "Sets the velocity gain.\n"
        "\n"
        ":param kV: The velocity gain.")
      )
      .def("setKa", &frc::SimpleMotorFeedforward<Distance>::SetKa
        , py::arg("kA")
        , release_gil()
        , py::doc(
        "Sets the acceleration gain.\n"
        "\n"
        ":param kA: The acceleration gain.")
      )
      .def("getKs", &frc::SimpleMotorFeedforward<Distance>::GetKs
        , release_gil()
        , py::doc(
        "Returns the static gain.\n"
        "\n"
        ":returns: The static gain.")
      )
      .def("getKv", &frc::SimpleMotorFeedforward<Distance>::GetKv
        , release_gil()
        , py::doc(
        "Returns the velocity gain.\n"
        "\n"
        ":returns: The velocity gain.")
      )
      .def("getKa", &frc::SimpleMotorFeedforward<Distance>::GetKa
        , release_gil()
        , py::doc(
        "Returns the acceleration gain.\n"
        "\n"
        ":returns: The acceleration gain.")
      )
      .def("getDt", &frc::SimpleMotorFeedforward<Distance>::GetDt
        , release_gil()
        , py::doc(
        "Returns the period.\n"
        "\n"
        ":returns: The period.")
      )
    ;
    if (set_doc) {
      cls_SimpleMotorFeedforward.doc() = set_doc;
    }
    if (add_doc) {
      cls_SimpleMotorFeedforward.doc() = py::cast<std::string>(cls_SimpleMotorFeedforward.doc()) + add_doc;
    }
  }
}; // struct bind_frc__SimpleMotorFeedforward

}; // namespace swgen
