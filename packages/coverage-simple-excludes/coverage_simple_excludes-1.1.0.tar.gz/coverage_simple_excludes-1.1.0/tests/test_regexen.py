import re
import unittest
import importlib
import coverage
import coverage_simple_excludes as uut

class RegexTestCase(unittest.TestCase):

    def test_python_regex(self):
        mk_re = uut._make_python_regex  # pyright: ignore [reportPrivateUsage]  # pylint: disable=protected-access

        # ##### On Python 3.13 #####
        r3_13 = re.compile('\\A(?:' + '|'.join(mk_re(3,13)) + ')\\Z')
        # Example: If the line is marked with `req-lt3.13`, this means a Python version
        # lower than 3.13 is required, but this is 3.13, which means the regex should match,
        # which means the line of code should be excluded. If the line is marked with `req-ge3.13`,
        # this means a Python version of 3.13 or later is required, which is the case,
        # which means the regex *shouldn't* match, so that the line is *not* excluded.

        # The regular expressions are generated by my re-int-ineq, which should be stable,
        # so it should be ok to check them against a fixed string:
        self.assertEqual(r3_13.pattern, '\\A(?:'
            # For "Less Than", match any major versions 0-2,
            'req-lt(?:[0-2]\\.[0-9]+'
                # or major version 3 and minor versions 13 or below (minor versions 10 to 13, or any single-digit)
                '|3\\.(?:1[0-3]|[0-9]))'
            '(?![0-9])|'
            # For "Greater or Equal", match any major versions 4 or higher (two or more digit major version numbers, or single-digit 4-9),
            'req-ge(?:(?:[1-9][0-9]+|[4-9])\\.[0-9]+'
                # or major version 3 and minor versions 14 or higher
                # (minor versions 14 to 19, three or more digit version numbers, or two-digit 20 to 99)
                '|3\\.(?:1[4-9]|[1-9][0-9]{2,}|[2-9][0-9]))'
        '(?![0-9])' ')\\Z')

        # In other words, on Python 3.13, the following comments should match,
        # causing those lines to be *excluded* from coverage:
        for c in ('req-lt3.13','req-lt3.12','req-lt3.11','req-lt3.0','req-lt2.99','req-lt2.9','req-lt2.0','req-lt1.9',
                  'req-ge3.14','req-ge3.15','req-ge3.99','req-ge4.0','req-ge4.1','req-ge5.0','req-ge5.1', ):
            self.assertRegex(c, r3_13)
        # ... and the following comments shouldn't match, causing these lines to be *included* in coverage:
        for c in ('req-ge3.13','req-ge3.12','req-ge3.11','req-ge3.0','req-ge2.99','req-ge2.9','req-ge2.0','req-ge1.9',
                  'req-lt3.14','req-lt3.15','req-lt3.99','req-lt4.0','req-lt4.1','req-lt5.0','req-lt5.1', ):
            self.assertNotRegex(c, r3_13)

        # ##### On Python 3.0 #####
        r3_0 = re.compile('\\A(?:' + '|'.join(mk_re(3,0)) + ')\\Z')
        self.assertEqual(r3_0.pattern, '\\A(?:'
            # For "Less Than", match any major versions 0-2, or exactly 3.0
            'req-lt(?:[0-2]\\.[0-9]+' '|3\\.0)'
            '(?![0-9])|'
            # For "Greater or Equal", match any major versions 4 or higher (two or more digit major version numbers, or single-digit 4-9)
            'req-ge(?:(?:[1-9][0-9]+|[4-9])\\.[0-9]+'
                # or major version 3 and any minor version greater than 0 (any integer beginning with 1-9)
                '|3\\.[1-9][0-9]*)'
        '(?![0-9])' ')\\Z')
        for c in ('req-lt3.0','req-lt2.9','req-lt2.1','req-lt2.0','req-lt1.9',
                  'req-ge3.1','req-ge3.9','req-ge4.0','req-ge4.1','req-ge5.0','req-ge5.1', ):
            self.assertRegex(c, r3_0)  # match = exclude
        for c in ('req-ge3.0','req-ge2.9','req-ge2.1','req-ge2.0','req-ge1.9',
                  'req-lt3.1','req-lt3.9','req-lt4.0','req-lt4.1','req-lt5.0','req-lt5.1', ):
            self.assertNotRegex(c, r3_0)  # no match = include

    def test_load_plugin(self):
        # This test will be run under `coverage`, and its configuration includes the `coverage_simple_excludes` plugin.
        # This means that the plugin module will have been loaded before coverage recording starts, resulting in its
        # top-level code being reported as not being covered. So, to get it to be recorded, we force it to be reloaded,
        # which should be ok since the module shouldn't have changed.
        importlib.reload(uut)
        # Next, we want to force the plugin's initialization code to be run, so its coverage is recorded as well:
        coverage.Coverage(plugins=[uut.coverage_init]).load()
