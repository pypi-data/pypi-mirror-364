# CopyrightÂ© 2023-2025 Quantum Interface (quantuminterface@ipe.kit.edu)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
The event detection module is responsible for minimizing the data amount
generated by the microwave SQUID multiplexer.
Several parameters allow customization of the module to the specific needs
and the shape of the expected pulses.
The output of the module are the extracted pulses of the individual sensor data streams.
While the data of the sensors arrive in a TDM scheme at the input,
the packages at the output are transferred sequentially.
If multiple events are detected at the same time,
they are buffered and transmitted one after the other.
"""

from cirque.packages.grpc import datatypes_pb2
from cirque.packages.grpc import eventdetection_pb2, eventdetection_pb2_grpc

from . import servicehubcontrol
from .servicehubutils import servicehub_call


class EventDetection:
    """
    The EventDetection class is responsible for the communication with its
    specific Plugin on the platform. Generate the interface to a new endpoint
    by passing the connection and the endpoint name.
    """

    def __init__(self, connection, endpoint):
        self.connection = connection
        self._stub = eventdetection_pb2_grpc.EventDetectionServiceStub(
            connection.get_channel()
        )
        hubcontrol = servicehubcontrol.ServicehubControl(connection)
        self.index = hubcontrol.get_endpoint_index_of_plugin(
            "EventDetectionPlugin", endpoint
        )
        self.tdm_channels = self._stub.GetTDMChannels(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def get_tdm_channels(self):
        """
        Reads the amount of connected TDM-Channels to the module
        """
        return self._stub.GetTDMChannels(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    servicehub_call(errormsg="failed", tries=1)

    def activate_bypass(self):
        """
        Activates the Bypass in order to acquire raw data after the fluxramp demodulation.
        By default, the bypass is enabled
        """
        return self._stub.ActivateBypass(datatypes_pb2.EndpointIndex(value=self.index))

    @servicehub_call(errormsg="failed", tries=1)
    def deactivate_bypass(self):
        """
        Deactivates the Bypass to enable the EventDetection.
        After Activation, the DMA is filled with sequential packages
        and not a continouous stream anymore
        """
        return self._stub.DeactivateBypass(
            datatypes_pb2.EndpointIndex(value=self.index)
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_bypass_status(self):
        """
        Returns the current status of the Bypass.
        """
        return self._stub.GetBypassStatus(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_pretrigger_values(self, pretriggervalues=32):
        """
        Defines the number of samples to be stored within an event package before the trigger fires.
        The maximum value for the pretrigger samples depends on the hardware configuration.
        Exceeding the limit leads to an error message, the value is not updated in this case.

        Args:
            pretriggervalues (int): number of pretrigger values. Default value is 32
        """
        return self._stub.SetPretriggerValues(
            datatypes_pb2.IndexedUInt(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                value=pretriggervalues,
            )
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_pretrigger_values(self):
        """
        Returns the number of pretrigger values stored within the event packages.
        """
        return self._stub.GetPretriggerValues(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def enable(self):
        """
        Enables the module. Currently not implemented.
        """
        return self._stub.Enable(datatypes_pb2.EndpointIndex(value=self.index))

    @servicehub_call(errormsg="failed", tries=1)
    def get_enable(self):
        """
        Returns whether the module is enabled.
        Currently not implemented.
        """
        return self._stub.GetEnable(datatypes_pb2.EndpointIndex(value=self.index)).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_event_length(self, length=1000):
        """
        Defines the total number of samples stored within an event package.
        This number consists of both the pretrigger values and posttrigger values.
        The value of the pretrigger values can be defined individually
        by the "SetPretriggerValues" Method.
        The maximum value for the event length depends on the hardware configuration.
        Exceeding the limit leads to an error message, the value is not updated in this case.

        Args:
            length (int): number of samples within a package. Default value is 1000
        """
        return self._stub.SetEventLength(
            datatypes_pb2.IndexedUInt(
                index=datatypes_pb2.EndpointIndex(value=self.index), value=length
            )
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_event_length(self):
        """
        Returns the number of samples within a single event package.
        This number consists of both the pretrigger and the posttrigger samples
        """
        return self._stub.GetEventLength(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_trigger_engine(self, triggerengine=0):
        """
        The event detection module contains two individual trigger engines that check,
        whether a pulse occurs.
        Trigger engine THRESHOLD simply compares the difference between two succeeding samples
        by a definable threshold.
        This threshold can be defined by the method "SetEventThreshold".
        Trigger engine MOVING_AVERAGE implements a moving average filter,
        calculating the average of four succeeding samples
        and then comparing the difference by a threshold.
        The threshold is the same as for the first trigger engine
        and can be defined by the method "SetEventThreshold".

        Args:
            triggerengine (int): Defines which trigger engine to use.
            0 is THRESHOLD, 1 is MOVING_AVERAGE
        """
        return self._stub.SetTriggerEngine(
            eventdetection_pb2.TriggerEngine(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                value=triggerengine,
            )
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_trigger_engine(self):
        """
        Returns the trigger engine that is currently used for finding pulses in the data streams.
        """
        return self._stub.GetTriggerEngine(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_event_threshold(self, threshold=1000):
        """
        Defines the threshold that is used for detecting pulses.
        The threshold is utilized within the trigger engines.

        Args:
            threshold (int): defines the limit, whether data is recognized as a pulse edge.
            Default value is 1000
        """
        return self._stub.SetEventThreshold(
            datatypes_pb2.IndexedUInt(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                value=threshold,
            )
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_event_threshold(self):
        """
        Returns the value for the threshold that is used to detect pulses
        in the individual data streams of the sensors
        """
        return self._stub.GetEventThreshold(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def reset_timestamp(self):
        """
        As part of the event package header, the time of occurence is stored.
        Calling this function resets the timestamp back to zero for one specific endpoint.
        """
        return self._stub.ResetTimestamp(datatypes_pb2.EndpointIndex(value=self.index))

    @servicehub_call(errormsg="failed", tries=1)
    def reset_global_timestamp(self):
        """
        As part of the event package header, the time of occurence is stored.
        Calling this function resets the timestamp back to zero for all endpoints.
        The specific endpoint does not have to be defined,
        since the driver automatically detects the master
        and resets the timestamp for all endpoints.
        This leads to synchronization of the modules.
        """
        return self._stub.ResetGlobalTimestamp(datatypes_pb2.Empty())

    @servicehub_call(errormsg="failed", tries=1)
    def reset_counters(self):
        """
        The event detection module tracks the amount of stored and discarded events.
        Calling this function resets the values for these counters
        """
        return self._stub.ResetCounters(datatypes_pb2.EndpointIndex(value=self.index))

    @servicehub_call(errormsg="failed", tries=1)
    def get_discarded_events(self):
        """
        Returns the number of discarded events since the module is online
        or the last reset of the counters.
        Events are discarded, if the buffer is completely occupied.
        """
        return self._stub.GetDiscardedEvents(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def get_stored_events(self):
        """
        Returns the number of stored events since the module is online
        or since the last counter reset
        """
        return self._stub.GetStoredEvents(
            datatypes_pb2.EndpointIndex(value=self.index)
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_software_trigger(self):
        """
        Storing an event package can be triggered manually.
        After defining which channels should be triggered with the "SetTriggerChannels" method,
        this method activates the software trigger.
        """
        return self._stub.SetSoftwareTrigger(
            datatypes_pb2.EndpointIndex(value=self.index)
        )

    @servicehub_call(errormsg="failed", tries=1)
    def set_single_trigger_channel(self, channel=0, status=False):
        """
        With this method, a single channel that shall be triggered can be defined.
        After defining the channels, the software trigger can be activated
        by the "SetSoftwareTrigger" functionality

        Args:
            channel (int): Index of the channel to be updated
            status (bool): Activate/Deactivate trigger channel
        """
        return self._stub.SetSingleTriggerChannel(
            eventdetection_pb2.ChannelConfiguration(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                channel=channel,
                status=status,
            )
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_single_trigger_channel(self, channel=0):
        """
        Returns whether a single channel is activated for the software trigger

        Args:
            channel (int): Index of the channel of interest
        """
        return self._stub.GetSingleTriggerChannel(
            eventdetection_pb2.ChannelNumber(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                channel=channel,
            )
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_trigger_channels(self, channels):
        """
        With this method, the channels that shall be triggered can be defined.
        After defining the channels, the software trigger can be activated
        by the "SetSoftwareTrigger" functionality

        Args:
            channels (int[]): Array that contain the indices of the channels to be triggered
        """
        for channel in range(self.tdm_channels):
            self._stub.SetSingleTriggerChannel(
                eventdetection_pb2.ChannelConfiguration(
                    index=datatypes_pb2.EndpointIndex(value=self.index),
                    channel=channel,
                    status=False,
                )
            )
        for channel in channels:
            self._stub.SetSingleTriggerChannel(
                eventdetection_pb2.ChannelConfiguration(
                    index=datatypes_pb2.EndpointIndex(value=self.index),
                    channel=channel,
                    status=True,
                )
            )

    @servicehub_call(errormsg="failed", tries=1)
    def get_trigger_channels(self):
        """
        Returns the indices of channels that are activated for the software trigger
        """
        list_trigger_channels = []
        for channel in range(self.tdm_channels):
            status = self._stub.GetSingleTriggerChannel(
                eventdetection_pb2.ChannelNumber(
                    index=datatypes_pb2.EndpointIndex(value=self.index),
                    channel=channel,
                )
            ).value
            if status is True:
                list_trigger_channels.append(channel)
        return list_trigger_channels

    @servicehub_call(errormsg="failed", tries=1)
    def set_active_channel(self, channel=0, status=False):
        """
        Activates/Deactivates a single channel.
        Deactivated channels are not considered by the trigger engine, no packets will be stored.

        Args:
            channel (int): Index of the channel to be active/deactive
            status (bool): Activate/Deactivate the channel
        """
        return self._stub.SetChannelActive(
            eventdetection_pb2.ChannelConfiguration(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                channel=channel,
                status=status,
            )
        )

    @servicehub_call(errormsg="failed", tries=1)
    def get_active_channel(self, channel=0):
        """
        Returns the status of a specific channel

        Args:
            channel (int): Index of the channel of interest
        """
        return self._stub.GetChannelActive(
            eventdetection_pb2.ChannelNumber(
                index=datatypes_pb2.EndpointIndex(value=self.index),
                channel=channel,
            )
        ).value

    @servicehub_call(errormsg="failed", tries=1)
    def set_active_channels(self, channels):
        """
        Channels can individually be activated.
        Deactivated channels are not considered by the trigger engine, no packets will be stored.

        Args:
            channels (int[]): Array of ints that contain the indices of channels to be active
        """
        for channel in range(self.tdm_channels):
            self._stub.SetChannelActive(
                eventdetection_pb2.ChannelConfiguration(
                    index=datatypes_pb2.EndpointIndex(value=self.index),
                    channel=channel,
                    status=False,
                )
            )
        for channel in channels:
            self._stub.SetChannelActive(
                eventdetection_pb2.ChannelConfiguration(
                    index=datatypes_pb2.EndpointIndex(value=self.index),
                    channel=channel,
                    status=True,
                )
            )

    @servicehub_call(errormsg="failed", tries=1)
    def get_active_channels(self):
        """
        Returns the indices of currently activated channels as an array
        """
        list_active_channels = []
        for channel in range(self.tdm_channels):
            status = self._stub.GetChannelActive(
                eventdetection_pb2.ChannelNumber(
                    index=datatypes_pb2.EndpointIndex(value=self.index),
                    channel=channel,
                )
            ).value
            if status is True:
                list_active_channels.append(channel)
        return list_active_channels
