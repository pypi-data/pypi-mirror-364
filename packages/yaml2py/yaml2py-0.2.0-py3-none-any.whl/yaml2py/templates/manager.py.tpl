# THIS FILE IS AUTO-GENERATED BY yaml2py.
# DO NOT EDIT THIS FILE MANUALLY.

import time
import yaml
import os
from typing import Any, Dict, List, Optional
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from threading import Thread
try:
    from yaml2py.env_loader import load_yaml_with_env, EnvironmentVariableError
except ImportError:
    # 如果作為獨立模組使用，提供簡單的後備實作
    def load_yaml_with_env(content, strict=False):
        if isinstance(content, str):
            return yaml.safe_load(content)
        return content
try:
    from .schema import (
{{SCHEMA_IMPORTS}}
    )
except ImportError:
    from schema import (
{{SCHEMA_IMPORTS}}
    )


def find_config_path(filename="config.yaml", max_depth=5):
    """
    從當前工作目錄開始向上查找配置文件。
    會依次尋找 'filename', 'config/filename', 'conf/filename'。
    也會嘗試 .yml 副檔名。

    參數：
        filename (str): 配置文件名稱，預設為 'config.yaml'。
        max_depth (int): 最大向上查找的目錄層數，預設為 5。

    返回：
        str 或 None: 找到的配置文件路徑，若未找到則返回 None。
    """
    path = "."
    
    # 如果是 .yaml，也嘗試 .yml
    alt_filename = None
    if filename.endswith('.yaml'):
        alt_filename = filename[:-5] + '.yml'
    elif filename.endswith('.yml'):
        alt_filename = filename[:-4] + '.yaml'
    
    for _ in range(max_depth):
        abs_path = os.path.abspath(path)
        
        # 檢查幾種常見的路徑模式
        check_paths = [
            os.path.join(abs_path, filename),
            os.path.join(abs_path, 'config', filename),
            os.path.join(abs_path, 'conf', filename),
        ]
        
        # 如果有替代檔名，也加入檢查
        if alt_filename:
            check_paths.extend([
                os.path.join(abs_path, alt_filename),
                os.path.join(abs_path, 'config', alt_filename),
                os.path.join(abs_path, 'conf', alt_filename),
            ])
        
        for p in check_paths:
            if os.path.exists(p):
                return p
        
        # 如果找不到，就到上一層目錄
        if os.path.dirname(abs_path) == abs_path:  # 到達根目錄
            break
        path = os.path.join(path, "..")
        
    return None


class ConfigFileHandler(FileSystemEventHandler):
    """
    文件系統事件處理器，用於監控配置文件的變更。

    當監控的配置文件發生變更時，觸發重新加載配置的操作。
    """
    def __init__(self, config_manager):
        """
        初始化事件處理器。

        參數：
            config_manager (ConfigManager): 配置管理器實例。
        """
        self.config_manager = config_manager
        self.last_modified_time = 0

    def on_modified(self, event):
        """
        當監控的文件被修改時觸發。

        參數：
            event: 文件系統事件對象。
        """
        if os.path.normpath(event.src_path) == os.path.normpath(self.config_manager.config_path):
            current_time = time.time()
            if current_time - self.last_modified_time > 1:
                self.last_modified_time = current_time
                print(f"Config file {event.src_path} changed, reloading values...")
                self.config_manager.reload_config()


class ConfigManager:
    """
    配置管理器，負責加載、管理和監控 YAML 配置文件。

    使用單例模式確保全局只有一個配置管理器實例。
    支援巢狀結構和複雜型態。
    """
    _instance = None
    _initialized = False

    def __new__(cls, *args, **kwargs): 
        """
        創建或返回單例實例。
        """
        if cls._instance is None: 
            cls._instance = super().__new__(cls) 
        return cls._instance

    def __init__(self, config_path: Optional[str] = None):
        """
        初始化配置管理器。

        參數：
            config_path (str): 配置文件的路徑，若未提供則自動查找。
        """
        if self._initialized:
            # 如果已經初始化，並且傳入了新的路徑，這可能是一個錯誤，發出警告。
            if config_path and config_path != self.config_path:
                print(f"Warning: ConfigManager already initialized with path '{self.config_path}'. Ignoring new path '{config_path}'.")
            return
        
        if config_path:
            # 1. 優先使用使用者明確提供的路徑
            self.config_path = config_path
        else:
            # 2. 如果未提供，則自動向上查找
            self.config_path = find_config_path()

        if not self.config_path or not os.path.exists(self.config_path):
            raise FileNotFoundError(
                "Could not find config.yaml or config.yml. Please provide the path explicitly "
                "to ConfigManager(config_path='/path/to/your/config.yaml') "
                "or place it in the project root or a 'config/' subdirectory."
            )
        
        print(f"ConfigManager is using configuration file: {self.config_path}")

        # 載入 YAML 配置
        self._data = self._load_yaml()
        self._create_properties()

        # 在 CI 環境中停用 watchdog 以避免 segmentation fault
        if not self._is_ci_environment():
            self._start_watchdog()
        else:
            print("Running in CI environment - watchdog disabled")
        
        self._initialized = True

    def _load_yaml(self) -> Dict[str, Any]:
        """
        載入 YAML 配置文件，支援環境變數替換。
        
        返回：
            Dict[str, Any]: 配置資料字典。
        """
        with open(self.config_path, 'r', encoding='utf-8') as f:
            content = f.read()
            # 檢查是否使用嚴格模式
            strict_mode = os.getenv('YAML2PY_STRICT_ENV', 'false').lower() == 'true'
            try:
                return load_yaml_with_env(content, strict=strict_mode) or {}
            except Exception as e:
                print(f"Warning: Failed to process environment variables: {e}")
                # 如果處理失敗，退回到標準載入
                return yaml.safe_load(content) or {}

    def _create_properties(self):
        """
        根據 YAML 資料建立屬性。
        """
        self._data = self._load_yaml()
{{MANAGER_PROPERTIES}}

    def reload_config(self):
        """
        當配置文件變更時重新加載配置值。
        """
        try:
            new_data = self._load_yaml()
            self._data = new_data
            self._create_properties()
            print("Configuration values reloaded successfully.")
        except Exception as e:
            print(f"Error reloading configuration: {e}")

    def _is_ci_environment(self) -> bool:
        """
        檢測是否在 CI 環境中執行。
        
        返回：
            bool: 如果在 CI 環境中返回 True，否則返回 False。
        """
        ci_env_vars = [
            'CI',
            'CONTINUOUS_INTEGRATION',
            'GITHUB_ACTIONS',
            'GITLAB_CI',
            'JENKINS_URL',
            'TRAVIS',
            'CIRCLECI',
            'AZURE_PIPELINES_BUILD_ID',
            'BITBUCKET_BUILD_NUMBER',
            'TEAMCITY_VERSION'
        ]
        return any(os.environ.get(var) for var in ci_env_vars)

    def _start_watchdog(self):
        """
        啟動 Watchdog 觀察者以監控配置文件的變更。
        """
        event_handler = ConfigFileHandler(self)
        observer = Observer()
        config_dir = os.path.dirname(self.config_path)
        if not os.path.isdir(config_dir):
            print(f"Warning: Config directory '{config_dir}' does not exist. Watchdog not started.")
            return

        observer.schedule(event_handler, config_dir, recursive=False)
        observer_thread = Thread(target=observer.start, daemon=True)
        observer_thread.start()
        print(f"Started watchdog for config file changes at '{self.config_path}'.")
    
    def get_raw_data(self) -> Dict[str, Any]:
        """
        獲取原始的 YAML 資料。
        
        返回：
            Dict[str, Any]: 原始配置資料。
        """
        return self._data.copy()
    
    def __repr__(self) -> str:
        """返回配置管理器的字串表示。"""
        return f"ConfigManager(config_path='{self.config_path}')"