// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <rev/config/SparkBaseConfig.h>

#include <trampolines/rev__BaseConfig.hpp>

namespace rev::spark {

template <typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_SparkBaseConfig :
  rev::PyTrampolineCfg_BaseConfig<
  CfgBase
  >
{
  using Base = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTSparkBaseConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTAbsoluteEncoderConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTAnalogSensorConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTEncoderConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTLimitSwitchConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTSoftLimitConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTClosedLoopConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTSignalsConfig = rev::spark::SparkBaseConfig;
  using override_base_SetIdleMode_TIdleMode = rev::spark::SparkBaseConfig;
  using override_base_Inverted_b = rev::spark::SparkBaseConfig;
  using override_base_SmartCurrentLimit_i_i_i = rev::spark::SparkBaseConfig;
  using override_base_SecondaryCurrentLimit_d_i = rev::spark::SparkBaseConfig;
  using override_base_OpenLoopRampRate_d = rev::spark::SparkBaseConfig;
  using override_base_ClosedLoopRampRate_d = rev::spark::SparkBaseConfig;
  using override_base_VoltageCompensation_d = rev::spark::SparkBaseConfig;
  using override_base_DisableVoltageCompensation_v = rev::spark::SparkBaseConfig;
  using override_base_Follow_i_b = rev::spark::SparkBaseConfig;
  using override_base_Follow_RTSparkBase_b = rev::spark::SparkBaseConfig;
  using override_base_DisableFollowerMode_v = rev::spark::SparkBaseConfig;
  using override_base_Flatten_v = rev::spark::SparkBaseConfig;
};

template <typename PyTrampolineBase, typename PyTrampolineCfg>
using PyTrampolineBase_SparkBaseConfig =
  rev::PyTrampoline_BaseConfig<
    PyTrampolineBase
    , PyTrampolineCfg>
;

template <typename PyTrampolineBase, typename PyTrampolineCfg>
struct PyTrampoline_SparkBaseConfig : PyTrampolineBase_SparkBaseConfig<PyTrampolineBase, PyTrampolineCfg> {
  using PyTrampolineBase_SparkBaseConfig<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_SparkBaseConfig;
  using IdleMode [[maybe_unused]] = typename rev::spark::SparkBaseConfig::IdleMode;

  #ifndef SWGEN_DISABLE_Apply_RTSparkBaseConfig
    SparkBaseConfig& Apply(SparkBaseConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTSparkBaseConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTAbsoluteEncoderConfig
    SparkBaseConfig& Apply(AbsoluteEncoderConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTAbsoluteEncoderConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTAnalogSensorConfig
    SparkBaseConfig& Apply(AnalogSensorConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTAnalogSensorConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTEncoderConfig
    SparkBaseConfig& Apply(EncoderConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTEncoderConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTLimitSwitchConfig
    SparkBaseConfig& Apply(LimitSwitchConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTLimitSwitchConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTSoftLimitConfig
    SparkBaseConfig& Apply(SoftLimitConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTSoftLimitConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTClosedLoopConfig
    SparkBaseConfig& Apply(ClosedLoopConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTClosedLoopConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTSignalsConfig
    SparkBaseConfig& Apply(SignalsConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTSignalsConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_SetIdleMode_TIdleMode
    SparkBaseConfig& SetIdleMode(IdleMode idleMode) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_SetIdleMode_TIdleMode;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "setIdleMode", idleMode);
      return CxxCallBase::SetIdleMode(std::move(idleMode));
    }
  #endif

  #ifndef SWGEN_DISABLE_Inverted_b
    SparkBaseConfig& Inverted(bool inverted) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Inverted_b;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "inverted", inverted);
      return CxxCallBase::Inverted(std::move(inverted));
    }
  #endif

  #ifndef SWGEN_DISABLE_SmartCurrentLimit_i_i_i
    SparkBaseConfig& SmartCurrentLimit(int stallLimit, int freeLimit, int limitRpm) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_SmartCurrentLimit_i_i_i;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "smartCurrentLimit", stallLimit, freeLimit, limitRpm);
      return CxxCallBase::SmartCurrentLimit(std::move(stallLimit), std::move(freeLimit), std::move(limitRpm));
    }
  #endif

  #ifndef SWGEN_DISABLE_SecondaryCurrentLimit_d_i
    SparkBaseConfig& SecondaryCurrentLimit(double limit, int chopCycles) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_SecondaryCurrentLimit_d_i;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "secondaryCurrentLimit", limit, chopCycles);
      return CxxCallBase::SecondaryCurrentLimit(std::move(limit), std::move(chopCycles));
    }
  #endif

  #ifndef SWGEN_DISABLE_OpenLoopRampRate_d
    SparkBaseConfig& OpenLoopRampRate(double rate) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_OpenLoopRampRate_d;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "openLoopRampRate", rate);
      return CxxCallBase::OpenLoopRampRate(std::move(rate));
    }
  #endif

  #ifndef SWGEN_DISABLE_ClosedLoopRampRate_d
    SparkBaseConfig& ClosedLoopRampRate(double rate) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_ClosedLoopRampRate_d;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "closedLoopRampRate", rate);
      return CxxCallBase::ClosedLoopRampRate(std::move(rate));
    }
  #endif

  #ifndef SWGEN_DISABLE_VoltageCompensation_d
    SparkBaseConfig& VoltageCompensation(double nominalVoltage) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_VoltageCompensation_d;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "voltageCompensation", nominalVoltage);
      return CxxCallBase::VoltageCompensation(std::move(nominalVoltage));
    }
  #endif

  #ifndef SWGEN_DISABLE_DisableVoltageCompensation_v
    SparkBaseConfig& DisableVoltageCompensation() override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_DisableVoltageCompensation_v;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "disableVoltageCompensation", );
      return CxxCallBase::DisableVoltageCompensation();
    }
  #endif

  #ifndef SWGEN_DISABLE_Follow_i_b
    SparkBaseConfig& Follow(int leaderCanId, bool invert) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Follow_i_b;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "follow", leaderCanId, invert);
      return CxxCallBase::Follow(std::move(leaderCanId), std::move(invert));
    }
  #endif

  #ifndef SWGEN_DISABLE_Follow_RTSparkBase_b
    SparkBaseConfig& Follow(SparkBase& leader, bool invert) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Follow_RTSparkBase_b;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "follow", leader, invert);
      return CxxCallBase::Follow(std::forward<decltype(leader)>(leader), std::move(invert));
    }
  #endif

  #ifndef SWGEN_DISABLE_DisableFollowerMode_v
    SparkBaseConfig& DisableFollowerMode() override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_DisableFollowerMode_v;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "disableFollowerMode", );
      return CxxCallBase::DisableFollowerMode();
    }
  #endif

  #ifndef SWGEN_DISABLE_Flatten_v
    std::string Flatten() override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Flatten_v;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(std::string), LookupBase,
        "flatten", );
      return CxxCallBase::Flatten();
    }
  #endif
};

}; // namespace rev::spark
