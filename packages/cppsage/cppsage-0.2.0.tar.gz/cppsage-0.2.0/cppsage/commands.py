from pathlib import Path
import typer
from rich import print
import os
import sys
import subprocess

packageFileName = "requirements.txt"
preset = "windows" if os.name == "nt" else "default"
debugPreset="debug-windows" if os.name=="nt" else "debug"
execulableExtention=".exe" if os.name =="nt" else ""
app = typer.Typer(no_args_is_help=True)
buildType="Release"

@app.command()
def about():
    """Show information about the Sage project and CLI."""

    print("[bold cyan]Sage by Viuv Labs[/bold cyan]: A unified build and dependency system for C/C++")
    print("[faint white]Use '--help' to explore commands[/faint white]")

@app.command()
def compile():
    """Compile the project using the current preset and build directory."""
    onCompile()

def onCompile():
    if not os.path.isfile("CMakeLists.txt"):
        print("[bold red]Missing CMakeLists.txt[/bold red]")
        return
    
    build_dir = f"build/{preset}"
    print(build_dir)
    if not os.path.isdir(build_dir):
        if not os.path.isdir(f"packages/install"):
            runInstall()

        result = subprocess.run(["cmake", "--preset", preset])
        if result.returncode != 0:
            print("[bold red]CMake configuration failed[/bold red]")
            return
    
    subprocess.run(["cmake", "--build", build_dir, "--parallel"])

@app.command()
def run(args: list[str]):
    """
    Run one or more compiled executables from the build directory.

    Arguments should match target names generated by the build.
    Example:
        sage run main test_game
    Searches inside build/{preset}/ for matching executables.
    """
    onRun()

def onRun(args:list[str]=""):
    if not args:
        print("[bold red]Specify at least one app to build/run[/bold red]")
        return

    for arg in args:
        path_direct = f"build/{preset}/{arg}{execulableExtention}"
        path_nested = (f"{path_direct}".removesuffix(execulableExtention))+f"/{arg}{execulableExtention}"
        if os.path.isfile(path_direct):
            subprocess.run([path_direct])
        elif os.path.isfile(path_nested):
            subprocess.run([path_nested])
        else:
            print(f"[bold red]Executable '{arg}' not found[/bold red]")

@app.command()
def build(args:list[str]):
    """
    Build and Run one or more compiled executables from the build directory.

    Arguments should match target names generated by the build.
    Example:
        sage build main test_game
    Searches inside build/{preset}/ for matching executables.
    """
    onCompile()
    onRun(args=args)

@app.command()
def install(
    package: str = typer.Option(None, "--package", "-p", help="Package name to install"),
    version: str = typer.Option(None, "--version", "-v", help="Optional package version")
):
    """Install dependencies from requirements.txt or add new ones , sage install --help"""
    runInstall(package,version)


@app.command()
def doctor():
    """
    Run diagnostics and automatically configure your development environment.

    This command will:
    - Detect missing tools (e.g. compiler, CMake, Conan, Ninja) and install them if necessary.
    - Validate your toolchain setup across platforms.
    - Configure a working Conan profile tailored for Clang with sane defaults.
    - Inspect CMake presets and verify project integrity.
    - Ensure compatibility for cross-platform development with static linking options.

    [ðŸ’¡] Future versions will include environment summary, version checks,
    and auto-fix suggestions for broken configs.
    """

    print("[bold blue]Diagnostics are in progress... stay tuned![/bold blue]")
    if subprocess.run(["pip","install","conan"],capture_output=True).returncode!=0:
        print("failed to install conan")
    code=subprocess.run(["conan","profile","detect"],capture_output=True).returncode
    if code==0 or code==1:
        print("default conan profile created!")
    else:
        print("error while creating conan profile!")
        return
    conan_profile_path=subprocess.run(["conan","profile","path","default"],capture_output=True).stdout.strip()
    modifyConanProfile(conan_profile_path)

@app.command()
def create():
    """
    Generate a new starter C/C++ project with predefined structure.

    Prompts for project name and programming language (C or C++).
    Creates folders, CMake configuration, Clang-format/tidy files, presets,
    and a minimal entry point with Conan-ready setup.
    """

    project_name = typer.prompt("Enter project name").strip()
    lang = typer.prompt("Choose language (C/C++)").strip().lower()

    if not project_name:
        print("[bold red]Project name cannot be empty[/bold red]")
        raise typer.Exit()
    if lang not in ["c", "c++"]:
        print("[bold red]Invalid language. Must be 'C' or 'C++'[/bold red]")
        raise typer.Exit()

    ext = "c" if lang == "c" else "cpp"
    root = Path(project_name)
    print(f"[bold green]Scaffolding {lang.upper()} project: {project_name}[/bold green]")

    # Create directory structure
    for folder in [
         "cmake", "res",
        f"{project_name}/src", f"{project_name}/include", "packages"
    ]:
        (root / folder).mkdir(parents=True, exist_ok=True)

    # Root CMakeLists.txt
    cmake_root = f"""#Auto Generated Root CMake file by Sage
#Copyright(c) 2025 None.All rights reerved.
cmake_minimum_required(VERSION 3.6...3.31)
project({project_name} VERSION 0.1.0 LANGUAGES CXX C)
include(cmake/config.cmake)
#@add_find_package Warning: Do not remove this line

#@add_subproject Warning: Do not remove this line
add_subdirectory({project_name})
"""
    (root / "CMakeLists.txt").write_text(cmake_root)

    # config.cmake
    config_cmake = f"""#Auto Generated Root CMake file by Sage
#None
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
option(STATIC_LINK "Enable static linking" ON)
option(ENABLE_TESTS "GTests" OFF)
if(STATIC_LINK)
  set(BUILD_SHARED_LIBS OFF)
  if (WIN32)
      set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
  else()
      set(CMAKE_EXE_LINKER_FLAGS "${{CMAKE_EXE_LINKER_FLAGS}} -static")
  endif()
else()
  set(BUILD_SHARED_LIBS ON)
  if(WIN32)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL")
  endif()
endif()
set(COMPANY "None")
string(TIMESTAMP CURRENT_YEAR "%Y")
set(COPYRIGHT "Copyright(c) ${{CURRENT_YEAR}} ${{COMPANY}}.")
include_directories(${{CMAKE_BINARY_DIR}} ${{CMAKE_SOURCE_DIR}})
configure_file(res/config.h.in {project_name}config.h)
if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    message(STATUS "Enabling secure coding features for Clang")
    add_compile_options(
        -Wall -Wextra -Wpedantic
        -Wshadow -Wold-style-cast
        -Wcast-align -Wnull-dereference
        -Wformat=2 -Wformat-security
        -fstack-protector-strong
        -D_FORTIFY_SOURCE=2
        -fno-common
        #-Werror
    )
endif()
"""
    (root / "cmake/config.cmake").write_text(config_cmake)

    # res/config.h.in
    config_h = f"""#ifndef __{project_name}__
    #define __{project_name}__
#include <string_view>
namespace Project {{
    constexpr std::string_view VERSION_STRING = "@{project_name}_VERSION_MAJOR@.@{project_name}_VERSION_MINOR@.@{project_name}_VERSION_PATCH@";
    constexpr std::string_view COMPANY_NAME = "@COMPANY@";
    constexpr std::string_view COPYRIGHT_STRING = "@COPYRIGHT@";
    constexpr std::string_view PROJECT_NAME = "@PROJECT_NAME@";
}}
#endif
"""
    (root / "res/config.h.in").write_text(config_h)

    # Subproject CMakeLists.txt
    subproject_cmake = f"""add_executable({project_name} src/main.{ext}) # Add your Source Files here
"""
    (root / project_name / "CMakeLists.txt").write_text(subproject_cmake)

    # Other essential files
    (root / "CMakePresets.json").write_text("""

{
  "version": 2,
  "configurePresets": [
    {
      "name": "default",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "cacheVariables": {
        "CMAKE_TOOLCHAIN_FILE": "packages/install/conan_toolchain.cmake",
        "STATIC_LINK": false,
        "CMAKE_BUILD_TYPE":"Release",
        "CMAKE_CXX_COMPILER":"clang++",
        "CMAKE_C_COMPILER":"clang"
      }
    },
    {"name": "debug",
    "inherits":"default",
    "cacheVariables": {
      "CMAKE_BUILD_TYPE":"Debug"
    }
    },
    {
      "name": "windows",
      "inherits": "default",
      "cacheVariables": {
        "CMAKE_CXX_COMPILER":"clang-cl",
        "CMAKE_C_COMPILER":"clang-cl"
      }
    },
    {
      "name": "debug-windows",
      "inherits":"windows",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE":"Debug"
      }
    }
  ]
}""")
    (root / "packages/requirements.txt").write_text("[requires]\n[generators]\nCMakeDeps\nCMakeToolchain\n")
    (root / project_name / f"src/main.{ext}").write_text("int main() {\n    return 0;\n}")

    for name, content in {
        ".clang-format": "BasedOnStyle: Google",
        ".clang-tidy": "Checks: '*'",
        ".clangd": "CompileFlags:\n CompilationDatabase: build/default\n Add: [-Wall, -Wextra]",
        ".editorconfig": "root = true",
        ".gitignore": "build/\npackages/install/\n.vscode/",
    }.items():
        (root / name).write_text(content)

    print(f"[bold cyan]{project_name} has been created successfully![/bold cyan]")





def runInstall(package:str=None,version:str=None):
    req_path = f"packages/{packageFileName}"

    if not package:
        if os.path.isfile(req_path):
            subprocess.run(["conan", "install", req_path, "--output-folder", "packages/install", "--build=missing","-c","tools.cmake.cmaketoolchain:generator=Ninja","-s",f"build_type={buildType}"])
            return
        else:
            print(f"[bold red]Missing {req_path}[/bold red]")
        return
    req_dir=os.path.dirname(req_path)
    os.makedirs(req_dir,exist_ok=True)

    if not os.path.isfile(req_path):
        with open(req_path, "w") as f:
            f.write("[requires]\n[generators]\nCMakeDeps\nCMakeToolchain\n")

    if not version:
        print(f"[bold green]No version provided for {package}. Fetching latest...[/bold green]")
        search = subprocess.run(["conan", "search", package], capture_output=True, text=True)
        if search.returncode != 0:
            print(f"[bold red]Conan search failed for {package}[/bold red]")
            return
        lines = search.stdout.strip().splitlines()
        version = lines[-1].split("/")[1] if lines else ""

    if not version:
        print(f"[bold red]No available versions found for {package}[/bold red]")
        return

    full_package = f"{package}/{version}"
    if len(full_package)>0:
        print(f"[bold yellow]Installing: {full_package}[/bold yellow]")

        with open(req_path, "r") as f:
            lines = f.readlines()

        if full_package + "\n" in lines:
            print(f"[bold yellow]{full_package} is already listed[/bold yellow]")
            return

        for i, line in enumerate(lines):
            if line.strip() == "[requires]":
                lines.insert(i + 1, full_package + "\n")
                break

        with open(req_path, "w") as f:
            f.writelines(lines)

    subprocess.run(["conan", "install", req_path, "--output-folder", "packages/install", "--build=missing"])


@app.command()
def debug():
    global buildType
    buildType="Debug"
    global preset
    preset=debugPreset
    req_path = f"packages/{packageFileName}"
    if os.path.isfile(req_path):
        subprocess.run(["conan", "install", req_path, "--output-folder", "packages/install", "--build=missing","-c","tools.cmake.cmaketoolchain:generator=Ninja","-s",f"build_type={buildType}"])
    else:
        print(f"[bold red]Missing {req_path}[/bold red]")
        return
    onCompile()


def modifyConanProfile(conan_profile_path:str):
    if not os.path.isfile(conan_profile_path):
        print(f"{conan_profile_path} doesn't exist!")
        return
    file_data=""
    with open(conan_profile_path,"r") as file:
        file_data=file.readlines()
    for index,line in enumerate(file_data):
        if line.strip().startswith("compiler.cppstd"):
            file_data[index]="compiler.cppstd=20\n"
    file_data.append("&:compiler=clang\n")
    
    with open(conan_profile_path,"w") as file:
        file.writelines(file_data)

    print(file_data)
