"""Requirements files remover."""

import re
import shlex
import sys
from pathlib import Path
from typing import List, Set, Optional

from ...utils.package_utils import normalize
from ..base import BaseRemover
import subprocess

class RequirementsRemover(BaseRemover):
    """Remover for requirements files (.txt, .in)."""

    def can_handle(self, file_path: Path) -> bool:
        """Check if this is a requirements file."""
        return file_path.suffix.lower() in (".txt", ".in")

    def remove_unused(
        self, file_path: Path, unused: Set[str], lines: List[str]
    ) -> List[str]:
        """Remove unused dependencies from requirements files."""
        # Check if this is a compiled requirements file (contains "# via" comments)
        is_compiled_requirements = any("# via" in line for line in lines)

        if is_compiled_requirements:
            # Try recompilation first
            recompiled_lines = self._recompile_requirements(file_path)
            if recompiled_lines is not None:
                return recompiled_lines
            # Fallback to manual processing if recompilation fails
            return self._handle_compiled_requirements(lines, unused)
        else:
            # Handle regular requirements files
            modified_lines = self._handle_regular_requirements(lines, unused)
            
            # For .in files, if content was modified, attempt to regenerate the .txt file
            if file_path.suffix == ".in" and modified_lines != lines:
                self._regenerate_txt_file(file_path, modified_lines)
            
            return modified_lines

    def _handle_regular_requirements(
        self, lines: List[str], unused: Set[str]
    ) -> List[str]:
        """Handle regular requirements files."""
        out = []
        for ln in lines:
            s = ln.strip()
            if not s or s.startswith("#") or s.startswith("-r"):
                out.append(ln)
            else:
                # Handle packages with extras like pandas[excel]
                pkg_with_extras = (
                    s.split("==")[0]
                    .split(">=")[0]
                    .split("<=")[0]
                    .split(">")[0]
                    .split("<")[0]
                    .split("!")[0]
                    .split(";")[0]
                    .strip()
                )
                pkg_base = normalize(pkg_with_extras.split("[")[0].strip())
                pkg_full = normalize(pkg_with_extras)

                if pkg_base not in unused and pkg_full not in unused:
                    out.append(ln)
        return out

    def _get_pip_compile_command(self, file_path: Path) -> Optional[List[str]]:
        """Extract pip-compile command from compiled requirements file header."""
        # Determine the compiled file path
        if file_path.suffix == ".in":
            compiled_file = file_path.with_suffix(".txt")
        else:
            compiled_file = file_path
        
        # Check if compiled file exists
        if not compiled_file.exists():
            return None
            
        try:
            with open(compiled_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
        except (OSError, UnicodeDecodeError):
            return None
            
        # Look for pip-compile command in header comments
        for line in lines[:20]:  # Only check first 20 lines
            line_stripped = line.strip()
            if ("pip-compile" in line_stripped and 
                line_stripped.startswith("#") and 
                "autogenerated" not in line_stripped.lower()):
                try:
                    # Remove comment prefix and parse command
                    command_str = line_stripped.removeprefix("#").strip()
                    # Use shlex to properly handle quoted arguments
                    return shlex.split(command_str)
                except ValueError:
                    # shlex.split failed, fall back to simple split
                    return command_str.split()
        
        return None
                
    
    def _recompile_requirements(self, file_path: Path) -> Optional[List[str]]:
        """Recompile requirements file using pip-compile command."""
        # First ensure pip-compile is available
        if not self._ensure_pip_compile_available():
            return None
            
        cmd = self._get_pip_compile_command(file_path)
        if not cmd:
            # Fallback: try to generate a basic pip-compile command
            return self._fallback_recompile(file_path)
        
        try:
            # Determine the output file path
            compiled_file = file_path.with_suffix(".txt") if file_path.suffix == ".in" else file_path
            
            # Ensure the command includes --output-file parameter
            cmd_with_output = self._ensure_output_file_in_command(cmd, compiled_file)
            
            # Ensure we run the command from the correct directory
            cwd = file_path.parent if file_path.is_absolute() else Path.cwd()
            
            result = subprocess.run(
                cmd_with_output,
                cwd=cwd,
                check=True,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            # Read the recompiled file and return its contents
            if compiled_file.exists():
                try:
                    with open(compiled_file, "r", encoding="utf-8") as f:
                        return f.readlines()
                except (OSError, UnicodeDecodeError):
                    return None
            
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            # Command failed, fall back to manual processing
            return self._fallback_recompile(file_path)
        
        return None
    
    def _ensure_pip_compile_available(self) -> bool:
        """Ensure pip-compile is available, installing pip-tools if necessary."""
        # Try different ways to find pip-compile
        pip_compile_commands = [
            "pip-compile",
            "python -m piptools.scripts.pip_compile",
            f"{sys.executable} -m piptools.scripts.pip_compile"
        ]
        
        for cmd_str in pip_compile_commands:
            try:
                cmd = shlex.split(cmd_str) + ["--help"]
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if result.returncode == 0:
                    return True
            except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                continue
        
        # pip-compile not found, try to install pip-tools
        try:
            install_cmd = [sys.executable, "-m", "pip", "install", "pip-tools"]
            result = subprocess.run(
                install_cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            if result.returncode == 0:
                # Verify installation worked
                try:
                    verify_cmd = [sys.executable, "-m", "piptools.scripts.pip_compile", "--help"]
                    verify_result = subprocess.run(
                        verify_cmd,
                        capture_output=True,
                        text=True,
                        timeout=10
                    )
                    return verify_result.returncode == 0
                except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                    pass
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            pass
        
        return False
    
    def _get_working_pip_compile_command(self) -> Optional[List[str]]:
        """Get a working pip-compile command from available options."""
        pip_compile_commands = [
            ["pip-compile"],
            [sys.executable, "-m", "piptools.scripts.pip_compile"],
            ["python", "-m", "piptools.scripts.pip_compile"]
        ]
        
        for cmd in pip_compile_commands:
            try:
                test_cmd = cmd + ["--help"]
                result = subprocess.run(
                    test_cmd,
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if result.returncode == 0:
                    return cmd
            except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                continue
        
        return None

    def _ensure_output_file_in_command(self, cmd: List[str], output_file: Path) -> List[str]:
        """Ensure the pip-compile command includes --output-file parameter."""
        # Check if --output-file is already specified
        if "--output-file" in cmd or "-o" in cmd:
            return cmd
        
        # Add --output-file parameter before the input file
        # Find the input file (last non-option argument)
        new_cmd = []
        input_file_added = False
        
        for i, arg in enumerate(cmd):
            if not arg.startswith("-") and i > 0 and not input_file_added:
                # This is likely the input file, add --output-file before it
                new_cmd.extend(["--output-file", str(output_file)])
                input_file_added = True
            new_cmd.append(arg)
        
        # If we didn't find an input file in the command, add --output-file at the end
        if not input_file_added:
            new_cmd.extend(["--output-file", str(output_file)])
        
        return new_cmd

    def _fallback_recompile(self, file_path: Path) -> Optional[List[str]]:
        """Fallback strategy when pip-compile command cannot be extracted or fails."""
        # If we have a .in file, try to ensure pip-compile is available and use it
        if file_path.suffix == ".in":
            # First ensure pip-compile is available
            if not self._ensure_pip_compile_available():
                return None
            
            # Get a working pip-compile command
            base_cmd = self._get_working_pip_compile_command()
            if not base_cmd:
                return None
            
            try:
                # Determine the output file and ensure it's explicitly specified
                compiled_file = file_path.with_suffix(".txt")
                cmd = base_cmd + ["--output-file", str(compiled_file), str(file_path)]
                cwd = file_path.parent if file_path.is_absolute() else Path.cwd()
                
                result = subprocess.run(
                    cmd,
                    cwd=cwd,
                    check=True,
                    capture_output=True,
                    text=True,
                    timeout=120
                )
                
                # Read the compiled file
                if compiled_file.exists():
                    try:
                        with open(compiled_file, "r", encoding="utf-8") as f:
                            return f.readlines()
                    except (OSError, UnicodeDecodeError):
                        return None
                        
            except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                # Even with pip-tools installed, compilation failed
                pass
        
        return None

    def _regenerate_txt_file(self, in_file_path: Path, modified_lines: List[str]) -> None:
        """Regenerate the .txt file from the modified .in file."""
        # First, write the modified content to the .in file
        modified_content = "\n".join(modified_lines)
        in_file_path.write_text(modified_content, encoding="utf-8")
        
        # Now attempt to regenerate the .txt file using pip-compile
        if self._ensure_pip_compile_available():
            base_cmd = self._get_working_pip_compile_command()
            if base_cmd:
                try:
                    compiled_file = in_file_path.with_suffix(".txt")
                    cmd = base_cmd + ["--output-file", str(compiled_file), str(in_file_path)]
                    cwd = in_file_path.parent if in_file_path.is_absolute() else Path.cwd()
                    
                    result = subprocess.run(
                        cmd,
                        cwd=cwd,
                        check=True,
                        capture_output=True,
                        text=True,
                        timeout=120
                    )
                    
                    # Compilation successful - the .txt file has been regenerated
                    
                except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                    # Compilation failed, but we've already written the .in file
                    # The user will need to manually run pip-compile if needed
                    pass

    def _handle_compiled_requirements(
        self, lines: List[str], unused: Set[str]
    ) -> List[str]:
        """Handle compiled requirements files with special comment processing."""
        out = []
        i = 0
        while i < len(lines):
            ln = lines[i]
            s = ln.strip()

            # Check if this is a package line
            if s and not s.startswith("#") and not s.startswith("-r") and "==" in s:
                pkg_name = normalize(s.split("==")[0].strip())

                # Check if this package was removed from .in file and collect its via
                # dependencies
                if pkg_name in unused:
                    # Collect all via dependencies for this package to see if it should
                    # be completely removed
                    j = i + 1
                    via_dependencies = []
                    in_file_references = []

                    while j < len(lines):
                        comment_line = lines[j]
                        comment_stripped = comment_line.strip()

                        if (
                            comment_stripped.startswith("#")
                            and "via" in comment_stripped
                        ):
                            # Extract dependencies from the via comment
                            via_content = (
                                comment_stripped.replace("#", "")
                                .replace("via", "")
                                .strip()
                            )

                            # Check if this line contains .in file references
                            if re.search(r"-r\s+requirements/[^\.]*\.in", via_content):
                                # Extract the .in file reference as one unit
                                in_match = re.search(
                                    r"-r\s+requirements/[^\.]*\.in", via_content
                                )
                                if in_match:
                                    in_file_references.append(in_match.group())

                                # Remove .in references and see what other deps remain
                                remaining_content = re.sub(
                                    r"-r\s+requirements/[^\.]*\.in", "", via_content
                                ).strip()
                                if remaining_content:
                                    # Split remaining content to find other dependencies
                                    other_deps = [
                                        dep.strip()
                                        for dep in remaining_content.split()
                                        if dep.strip()
                                    ]
                                    via_dependencies.extend(other_deps)
                            else:
                                # No .in references, treat as regular dependencies
                                deps = [
                                    dep.strip()
                                    for dep in via_content.split()
                                    if dep.strip()
                                ]
                                via_dependencies.extend(deps)

                            j += 1
                        elif (
                            comment_stripped.startswith("#")
                            and "   " in comment_stripped
                        ):
                            # Continuation line - extract more dependencies
                            content = comment_stripped.replace("#", "").strip()

                            # Check if this line contains .in file references
                            if re.search(r"-r\s+requirements/[^\.]*\.in", content):
                                # Extract the .in file reference as one unit
                                in_match = re.search(
                                    r"-r\s+requirements/[^\.]*\.in", content
                                )
                                if in_match:
                                    in_file_references.append(in_match.group())

                                # Remove .in references and see what other deps remain
                                remaining_content = re.sub(
                                    r"-r\s+requirements/[^\.]*\.in", "", content
                                ).strip()
                                if remaining_content:
                                    # Split remaining content to find other dependencies
                                    other_deps = [
                                        dep.strip()
                                        for dep in remaining_content.split()
                                        if dep.strip()
                                    ]
                                    via_dependencies.extend(other_deps)
                            else:
                                # No .in references, treat as regular dependencies
                                deps = [
                                    dep.strip()
                                    for dep in content.split()
                                    if dep.strip()
                                ]
                                via_dependencies.extend(deps)

                            j += 1
                        else:
                            break

                    # Check if after removing .in references, there would be any meaningful dependencies left
                    # Also check if the remaining dependencies are themselves unused
                    remaining_dependencies = []
                    for dep in via_dependencies:
                        if dep and not dep.startswith("-r"):
                            # Check if this dependency is also in the unused set
                            dep_normalized = normalize(dep)
                            if dep_normalized not in unused:
                                remaining_dependencies.append(dep)

                    # If this package only has .in file references and no other meaningful dependencies,
                    # it should be completely removed from compiled requirements
                    if in_file_references and not remaining_dependencies:
                        # Skip both the package line and its comments entirely
                        i = j - 1
                        continue
                    else:
                        # Package has other dependencies, keep it but clean up .in
                        # references
                        out.append(ln)

                        # Process comment lines to remove .in references while keeping
                        # other deps
                        kept_any_comments = False
                        for k in range(i + 1, j):
                            comment_line = lines[k]
                            comment_stripped = comment_line.strip()

                            if comment_stripped.startswith("#") and (
                                "via" in comment_stripped or "   " in comment_stripped
                            ):
                                # Remove .in references while preserving other
                                # dependencies
                                indent = comment_line[
                                    : len(comment_line) - len(comment_line.lstrip())
                                ]
                                original_content = comment_line.strip()

                                # Remove the -r requirements/*.in reference
                                modified_content = re.sub(
                                    r"\s*-r\s+requirements/[^\.]*\.in",
                                    "",
                                    original_content,
                                )

                                # Check if there's still meaningful content after cleaning
                                # Remove '# via' part temporarily to check what's left
                                content_after_via = re.sub(
                                    r"#\s*via\s*", "", modified_content
                                ).strip()

                                if content_after_via and content_after_via not in [
                                    "#",
                                    "",
                                ]:
                                    # There are still dependencies, keep this comment
                                    # line
                                    out.append(indent + modified_content)
                                    kept_any_comments = True

                        # If we didn't keep any comment lines but the package has dependencies,
                        # something went wrong - this shouldn't happen
                        if not kept_any_comments and remaining_dependencies:
                            # Add a simple via comment for the remaining dependencies
                            deps_str = "    # via " + ", ".join(remaining_dependencies)
                            out.append(deps_str)

                        i = j - 1
                else:
                    # Package wasn't removed from .in, keep everything as-is
                    out.append(ln)

                    # Just copy the comment lines without modification
                    j = i + 1
                    while j < len(lines):
                        comment_line = lines[j]
                        comment_stripped = comment_line.strip()

                        if comment_stripped.startswith("#") and (
                            "via" in comment_stripped or "   " in comment_stripped
                        ):
                            out.append(comment_line)
                            j += 1
                        else:
                            break

                    i = j - 1
            elif s.startswith("#") and ("via" in s):
                # Check for orphaned comment blocks (comments without preceding package)
                # Look backwards to see if this comment belongs to a package
                prev_pkg_line = None
                for k in range(i - 1, -1, -1):
                    prev_line = lines[k].strip()
                    if prev_line and not prev_line.startswith("#"):
                        prev_pkg_line = prev_line
                        break
                    elif prev_line == "":
                        continue
                    else:
                        break  # Hit another comment, no package found

                # If no preceding package found, this might be an orphaned comment block
                if not prev_pkg_line or "==" not in prev_pkg_line:
                    # This is likely an orphaned comment block, skip it entirely
                    j = i
                    while j < len(lines):
                        comment_line = lines[j]
                        comment_stripped = comment_line.strip()
                        if comment_stripped.startswith("#") and (
                            "via" in comment_stripped
                            or comment_stripped.startswith("#   ")
                        ):
                            j += 1
                        else:
                            break
                    # Skip all orphaned comment lines
                    i = j - 1
                else:
                    # This is a normal comment, keep it
                    out.append(ln)
            else:
                # Non-package line (comments, empty lines, etc.)
                out.append(ln)

            i += 1

        return out
