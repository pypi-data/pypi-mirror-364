{"version":3,"file":"index-8fae9850-BydHr74R.js","sources":["../node_modules/dagre-d3-es/src/graphlib/json.js","../node_modules/mermaid/dist/index-8fae9850.js"],"sourcesContent":["import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\n\nexport { write, read };\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound(),\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g),\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n","import { layout } from \"dagre-d3-es/src/dagre/index.js\";\nimport * as graphlibJson from \"dagre-d3-es/src/graphlib/json.js\";\nimport { c as createLabel, g as getSubGraphTitleMargins, i as intersectRect, a as insertMarkers, b as clear$2, d as clear$3, u as updateNodeBounds, s as setNodeElem, e as insertNode, f as insertEdgeLabel, p as positionNode, h as insertEdge, j as positionEdgeLabel } from \"./edges-d417c7a0.js\";\nimport { l as log, c as getConfig, m as evaluate } from \"./mermaid-0603ccf8.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { a as createText } from \"./createText-423428c9.js\";\nimport { select } from \"d3\";\nlet clusterDb = {};\nlet descendants = {};\nlet parents = {};\nconst clear$1 = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\nconst isDescendant = (id, ancenstorId) => {\n  log.trace(\"In isDecendant\", ancenstorId, \" \", id, \" = \", descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n  return false;\n};\nconst edgeInCluster = (edge, clusterId) => {\n  log.info(\"Decendants of \", clusterId, \" is \", descendants[clusterId]);\n  log.info(\"Edge is \", edge);\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n  if (!descendants[clusterId]) {\n    log.debug(\"Tilt, \", clusterId, \",not in decendants\");\n    return false;\n  }\n  return descendants[clusterId].includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || descendants[clusterId].includes(edge.w);\n};\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\n    \"Copying children of \",\n    clusterId,\n    \"root\",\n    rootId,\n    \"data\",\n    graph.node(clusterId),\n    rootId\n  );\n  const nodes = graph.children(clusterId) || [];\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n  log.warn(\"Copying (nodes) clusterId\", clusterId, \"nodes\", nodes);\n  nodes.forEach((node) => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info(\"cp \", node, \" to \", rootId, \" with parent \", clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn(\"Setting parent\", node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug(\"Setting parent\", node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info(\"In copy \", clusterId, \"root\", rootId, \"data\", graph.node(clusterId), rootId);\n        log.debug(\n          \"Not Setting parent for node=\",\n          node,\n          \"cluster!==rootId\",\n          clusterId !== rootId,\n          \"node!==clusterId\",\n          node !== clusterId\n        );\n      }\n      const edges = graph.edges(node);\n      log.debug(\"Copying Edges\", edges);\n      edges.forEach((edge) => {\n        log.info(\"Edge\", edge);\n        const data2 = graph.edge(edge.v, edge.w, edge.name);\n        log.info(\"Edge data\", data2, rootId);\n        try {\n          if (edgeInCluster(edge, rootId)) {\n            log.info(\"Copying as \", edge.v, edge.w, data2, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data2, edge.name);\n            log.info(\"newGraph edges \", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\n              \"Skipping copy of edge \",\n              edge.v,\n              \"-->\",\n              edge.w,\n              \" rootId: \",\n              rootId,\n              \" clusterId:\",\n              clusterId\n            );\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug(\"Removing node\", node);\n    graph.removeNode(node);\n  });\n};\nconst extractDescendants = (id, graph) => {\n  const children = graph.children(id);\n  let res = [...children];\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n  return res;\n};\nconst findNonClusterChild = (id, graph) => {\n  log.trace(\"Searching\", id);\n  const children = graph.children(id);\n  log.trace(\"Searching children of id \", id, children);\n  if (children.length < 1) {\n    log.trace(\"This is a valid node\", id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace(\"Found replacement for\", id, \" => \", _id);\n      return _id;\n    }\n  }\n};\nconst getAnchorId = (id) => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\nconst adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug(\"Opting out, no graph \");\n    return;\n  } else {\n    log.debug(\"Opting in, graph \");\n  }\n  graph.nodes().forEach(function(id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\n        \"Cluster identified\",\n        id,\n        \" Replacement id in edges: \",\n        findNonClusterChild(id, graph)\n      );\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };\n    }\n  });\n  graph.nodes().forEach(function(id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug(\"Cluster identified\", id, descendants);\n      edges.forEach((edge) => {\n        if (edge.v !== id && edge.w !== id) {\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n          if (d1 ^ d2) {\n            log.warn(\"Edge: \", edge, \" leaves cluster \", id);\n            log.warn(\"Decendants of XXX \", id, \": \", descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug(\"Not a cluster \", id, descendants);\n    }\n  });\n  for (let id of Object.keys(clusterDb)) {\n    const nonClusterChild = clusterDb[id].id;\n    const parent = graph.parent(nonClusterChild);\n    if (parent !== id && clusterDb[parent] && !clusterDb[parent].externalConnections) {\n      clusterDb[id].id = parent;\n    }\n  }\n  graph.edges().forEach(function(e) {\n    const edge = graph.edge(e);\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.warn(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(graph.edge(e)));\n    let v = e.v;\n    let w = e.w;\n    log.warn(\n      \"Fix XXX\",\n      clusterDb,\n      \"ids:\",\n      e.v,\n      e.w,\n      \"Translating: \",\n      clusterDb[e.v],\n      \" --- \",\n      clusterDb[e.w]\n    );\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing link to self - removing XXX\", e.v, e.w, e.name);\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + \"---\" + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: \"\",\n        labelText: edge.label,\n        padding: 0,\n        shape: \"labelRect\",\n        style: \"\"\n      });\n      const edge1 = structuredClone(edge);\n      const edge2 = structuredClone(edge);\n      edge1.label = \"\";\n      edge1.arrowTypeEnd = \"none\";\n      edge2.label = \"\";\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n      graph.setEdge(v, specialId, edge1, e.name + \"-cyclic-special\");\n      graph.setEdge(specialId, w, edge2, e.name + \"-cyclic-special\");\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn(\"Fixing and trixing - removing XXX\", e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        const parent = graph.parent(v);\n        clusterDb[parent].externalConnections = true;\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        const parent = graph.parent(w);\n        clusterDb[parent].externalConnections = true;\n        edge.toCluster = e.w;\n      }\n      log.warn(\"Fix Replacing with XXX\", v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn(\"Adjusted Graph\", graphlibJson.write(graph));\n  extractor(graph, 0);\n  log.trace(clusterDb);\n};\nconst extractor = (graph, depth) => {\n  log.warn(\"extractor - \", depth, graphlibJson.write(graph), graph.children(\"D\"));\n  if (depth > 10) {\n    log.error(\"Bailing out\");\n    return;\n  }\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n  if (!hasChildren) {\n    log.debug(\"Done, no node has children\", graph.nodes());\n    return;\n  }\n  log.debug(\"Nodes = \", nodes, depth);\n  for (const node of nodes) {\n    log.debug(\n      \"Extracting node\",\n      node,\n      clusterDb,\n      clusterDb[node] && !clusterDb[node].externalConnections,\n      !graph.parent(node),\n      graph.node(node),\n      graph.children(\"D\"),\n      \" Depth \",\n      depth\n    );\n    if (!clusterDb[node]) {\n      log.debug(\"Not a cluster\", node, depth);\n    } else if (!clusterDb[node].externalConnections && // !graph.parent(node) &&\n    graph.children(node) && graph.children(node).length > 0) {\n      log.warn(\n        \"Cluster without external connections, without a parent and with children\",\n        node,\n        depth\n      );\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === \"TB\" ? \"LR\" : \"TB\";\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn(\"Fixing dir\", clusterDb[node].clusterData.dir, dir);\n      }\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true\n      }).setGraph({\n        rankdir: dir,\n        // Todo: set proper spacing\n        nodesep: 50,\n        ranksep: 50,\n        marginx: 8,\n        marginy: 8\n      }).setDefaultEdgeLabel(function() {\n        return {};\n      });\n      log.warn(\"Old graph before copy\", graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph\n      });\n      log.warn(\"New graph after copy node: (\", node, \")\", graphlibJson.write(clusterGraph));\n      log.debug(\"Old graph after copy\", graphlibJson.write(graph));\n    } else {\n      log.warn(\n        \"Cluster ** \",\n        node,\n        \" **not meeting the criteria !externalConnections:\",\n        !clusterDb[node].externalConnections,\n        \" no parent: \",\n        !graph.parent(node),\n        \" children \",\n        graph.children(node) && graph.children(node).length > 0,\n        graph.children(\"D\"),\n        depth\n      );\n      log.debug(clusterDb);\n    }\n  }\n  nodes = graph.nodes();\n  log.warn(\"New list of nodes\", nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(\" Now next level\", node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach((node) => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n  return result;\n};\nconst sortNodesByHierarchy = (graph) => sorter(graph, graph.children());\nconst rect = (parent, node) => {\n  log.info(\"Creating subgraph rect for \", node.id, node);\n  const siteConfig = getConfig();\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"cluster\" + (node.class ? \" \" + node.class : \"\")).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const useHtmlLabels = evaluate(siteConfig.flowchart.htmlLabels);\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const text = node.labelType === \"markdown\" ? createText(label, node.labelText, { style: node.labelStyle, useHtmlLabels }) : label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(siteConfig.flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  log.trace(\"Data \", node, JSON.stringify(node));\n  rect2.attr(\"style\", node.style).attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - width / 2).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width).attr(\"height\", node.height + padding);\n  const { subGraphTitleTopMargin } = getSubGraphTitleMargins(siteConfig);\n  if (useHtmlLabels) {\n    label.attr(\n      \"transform\",\n      // This puts the labal on top of the box instead of inside it\n      `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`\n    );\n  } else {\n    label.attr(\n      \"transform\",\n      // This puts the labal on top of the box instead of inside it\n      `translate(${node.x}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`\n    );\n  }\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function(point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst noteGroup = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", \"note-cluster\").attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"rx\", node.rx).attr(\"ry\", node.ry).attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding).attr(\"fill\", \"none\");\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.intersect = function(point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  const siteConfig = getConfig();\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const label = shapeSvg.insert(\"g\").attr(\"class\", \"cluster-label\");\n  const innerRect = shapeSvg.append(\"rect\");\n  const text = label.node().appendChild(createLabel(node.labelText, node.labelStyle, void 0, true));\n  let bbox = text.getBBox();\n  if (evaluate(siteConfig.flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr(\"width\", bbox.width);\n    dv.attr(\"height\", bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n  rect2.attr(\"class\", \"outer\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding).attr(\"width\", width + padding).attr(\"height\", node.height + padding);\n  innerRect.attr(\"class\", \"inner\").attr(\"x\", node.x - width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2 - halfPadding + bbox.height - 1).attr(\"width\", width + padding).attr(\"height\", node.height + padding - bbox.height - 3);\n  const { subGraphTitleTopMargin } = getSubGraphTitleMargins(siteConfig);\n  label.attr(\n    \"transform\",\n    `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 - node.padding / 3 + (evaluate(siteConfig.flowchart.htmlLabels) ? 5 : 3) + subGraphTitleTopMargin})`\n  );\n  const rectBox = rect2.node().getBBox();\n  node.height = rectBox.height;\n  node.intersect = function(point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst divider = (parent, node) => {\n  const shapeSvg = parent.insert(\"g\").attr(\"class\", node.classes).attr(\"id\", node.id);\n  const rect2 = shapeSvg.insert(\"rect\", \":first-child\");\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n  rect2.attr(\"class\", \"divider\").attr(\"x\", node.x - node.width / 2 - halfPadding).attr(\"y\", node.y - node.height / 2).attr(\"width\", node.width + padding).attr(\"height\", node.height + padding);\n  const rectBox = rect2.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function(point) {\n    return intersectRect(node, point);\n  };\n  return shapeSvg;\n};\nconst shapes = { rect, roundedWithTitle, noteGroup, divider };\nlet clusterElems = {};\nconst insertCluster = (elem, node) => {\n  log.trace(\"Inserting cluster\");\n  const shape = node.shape || \"rect\";\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nconst clear = () => {\n  clusterElems = {};\n};\nconst recursiveRender = async (_elem, graph, diagramtype, id, parentCluster, siteConfig) => {\n  log.info(\"Graph in recursive render: XXX\", graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace(\"Dir in recursive render - dir:\", dir);\n  const elem = _elem.insert(\"g\").attr(\"class\", \"root\");\n  if (!graph.nodes()) {\n    log.info(\"No nodes found for\", graph);\n  } else {\n    log.info(\"Recursive render XXX\", graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace(\"Recursive edges\", graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert(\"g\").attr(\"class\", \"clusters\");\n  const edgePaths = elem.insert(\"g\").attr(\"class\", \"edgePaths\");\n  const edgeLabels = elem.insert(\"g\").attr(\"class\", \"edgeLabels\");\n  const nodes = elem.insert(\"g\").attr(\"class\", \"nodes\");\n  await Promise.all(\n    graph.nodes().map(async function(v) {\n      const node = graph.node(v);\n      if (parentCluster !== void 0) {\n        const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n        log.info(\"Setting data for cluster XXX (\", v, \") \", data, parentCluster);\n        graph.setNode(parentCluster.id, data);\n        if (!graph.parent(v)) {\n          log.trace(\"Setting parent\", v, parentCluster.id);\n          graph.setParent(v, parentCluster.id, data);\n        }\n      }\n      log.info(\"(Insert) Node XXX\" + v + \": \" + JSON.stringify(graph.node(v)));\n      if (node && node.clusterNode) {\n        log.info(\"Cluster identified\", v, node.width, graph.node(v));\n        const o = await recursiveRender(\n          nodes,\n          node.graph,\n          diagramtype,\n          id,\n          graph.node(v),\n          siteConfig\n        );\n        const newEl = o.elem;\n        updateNodeBounds(node, newEl);\n        node.diff = o.diff || 0;\n        log.info(\"Node bounds (abc123)\", v, node, node.width, node.x, node.y);\n        setNodeElem(newEl, node);\n        log.warn(\"Recursive render complete \", newEl, node);\n      } else {\n        if (graph.children(v).length > 0) {\n          log.info(\"Cluster - the non recursive path XXX\", v, node.id, node, graph);\n          log.info(findNonClusterChild(node.id, graph));\n          clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };\n        } else {\n          log.info(\"Node - the non recursive path\", v, node.id, node);\n          await insertNode(nodes, graph.node(v), dir);\n        }\n      }\n    })\n  );\n  graph.edges().forEach(function(e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \", e, \" \", JSON.stringify(graph.edge(e)));\n    log.info(\"Fix\", clusterDb, \"ids:\", e.v, e.w, \"Translateing: \", clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n  graph.edges().forEach(function(e) {\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(e));\n  });\n  log.info(\"#############################################\");\n  log.info(\"###                Layout                 ###\");\n  log.info(\"#############################################\");\n  log.info(graph);\n  layout(graph);\n  log.info(\"Graph after layout:\", graphlibJson.write(graph));\n  let diff = 0;\n  const { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);\n  sortNodesByHierarchy(graph).forEach(function(v) {\n    const node = graph.node(v);\n    log.info(\"Position \" + v + \": \" + JSON.stringify(graph.node(v)));\n    log.info(\n      \"Position \" + v + \": (\" + node.x,\n      \",\" + node.y,\n      \") width: \",\n      node.width,\n      \" height: \",\n      node.height\n    );\n    if (node && node.clusterNode) {\n      node.y += subGraphTitleTotalMargin;\n      positionNode(node);\n    } else {\n      if (graph.children(v).length > 0) {\n        node.height += subGraphTitleTotalMargin;\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        node.y += subGraphTitleTotalMargin / 2;\n        positionNode(node);\n      }\n    }\n  });\n  graph.edges().forEach(function(e) {\n    const edge = graph.edge(e);\n    log.info(\"Edge \" + e.v + \" -> \" + e.w + \": \" + JSON.stringify(edge), edge);\n    edge.points.forEach((point) => point.y += subGraphTitleTotalMargin / 2);\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph, id);\n    positionEdgeLabel(edge, paths);\n  });\n  graph.nodes().forEach(function(v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === \"group\") {\n      diff = n.diff;\n    }\n  });\n  return { elem, diff };\n};\nconst render = async (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clear$2();\n  clear$3();\n  clear();\n  clear$1();\n  log.warn(\"Graph at first:\", JSON.stringify(graphlibJson.write(graph)));\n  adjustClustersAndEdges(graph);\n  log.warn(\"Graph after:\", JSON.stringify(graphlibJson.write(graph)));\n  const siteConfig = getConfig();\n  await recursiveRender(elem, graph, diagramtype, id, void 0, siteConfig);\n};\nexport {\n  render as r\n};\n"],"names":["write","g","json","writeNodes","writeEdges","_.isUndefined","_.clone","_.map","v","nodeValue","parent","node","e","edgeValue","edge","clusterDb","descendants","parents","clear$1","isDescendant","id","ancenstorId","log","edgeInCluster","clusterId","copy","graph","newGraph","rootId","nodes","data","edges","data2","extractDescendants","children","res","child","findNonClusterChild","_id","getAnchorId","adjustClustersAndEdges","depth","d1","d2","nonClusterChild","w","specialId","edge1","edge2","graphlibJson.write","extractor","hasChildren","dir","clusterGraph","graphlib.Graph","sorter","result","sorted","sortNodesByHierarchy","rect","siteConfig","getConfig","shapeSvg","rect2","useHtmlLabels","evaluate","label","text","createText","createLabel","bbox","div","dv","select","padding","halfPadding","width","subGraphTitleTopMargin","getSubGraphTitleMargins","rectBox","point","intersectRect","noteGroup","roundedWithTitle","innerRect","divider","shapes","clusterElems","insertCluster","elem","shape","clear","recursiveRender","_elem","diagramtype","parentCluster","clusters","edgePaths","edgeLabels","o","newEl","updateNodeBounds","setNodeElem","insertNode","insertEdgeLabel","layout","diff","subGraphTitleTotalMargin","positionNode","paths","insertEdge","positionEdgeLabel","n","render","markers","insertMarkers","clear$2","clear$3"],"mappings":"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","x_google_ignoreList":[0,1]}