import random




grammer_rules: dict[str, list[str]] = {
    # Variable values
    "VARIABLE": ["a", "b", "c", "d", "e", "f", "g", "h", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"],
    "DIGIT": [str(i) for i in range(256)],
    "VALUE": ['VARIABLE', "DIGIT"],
    
    # Arithmetics and operators
    "ARITHMETIC_OPERATOR": ["+", "-", "*", "/", "%", "**"],
    "RELATIONAL_OPERATOR": ["===", "!=", "<", ">", "<=", ">="],
    "INC_DEC_OPERATOR": ["++", "--"],
    "LOGICAL_OPERATOR_PREFIX": ["!"],
    "LOGICAL_OPERATOR_INFIX": ["&&", "||"],
    "LOGICAL_OPERATOR": ["LOGICAL_OPERATOR_PREFIX", "LOGICAL_OPERATOR_INFIX"],
    "OPERATOR": ["ARITHMETIC_OPERATOR"],

    # Formatting
    "TAB": ["\t"],
    "PARENTHESIS_OPEN": ["("],
    "PARENTHESIS_CLOSE": [")"],
    "BRACES_OPEN": ["["],
    "BRACES_CLOSE": ["]"],
    "BRACKET_OPEN": ["{"],
    "BRACKET_CLOSE": ["}"],
    "EQUALS": ["="],
    "COLON": [":"],
    "SEMICOLON": [";"],
    "COMMA": [","],

    # Keywords
    "VAR": ["var"],
    "LET": ["let"],
    "DEFINE_VAR": ['VAR', 'LET'],
    "IF": ["if"],
    "ELSE": ["else"],
    "FOR": ["for"],
    "WHILE": ["while"],
    "OF": ["of"],
    "PRINT": ['console.log', 'console.info'],
    
    # Terms and Expressions
    "TERM": ["EXPRESSION_IDENTIFIER", "DIGIT"], # Expression identifier for existing variables, else pick a random digit
    "EXPRESSION": ['TERM SPACE OPERATOR SPACE TERM'],
    "EXPRESSION_ENCLOSED": ['PARENTHESIS_OPEN EXPRESSION PARENTHESIS_CLOSE'],
    "EXPRESSION_DISPLAY": [
        'EXPRESSION_IDENTIFIER SPACE OPERATOR SPACE EXPRESSION_IDENTIFIER', 
        'EXPRESSION_IDENTIFIER SPACE OPERATOR SPACE DIGIT'
    ],
    
    "IDENTIFIER_INITIALIZATION": ["NEW_LINE IDENTIFIER_INITIALIZATION INITIALIZATION", "NEW_LINE INITIALIZATION"],
    "INITIALIZATION": ['NEW_LINE DEFINE_VAR SPACE VARIABLE SPACE EQUALS SPACE DIGIT'],
    
    "SIMPLE_ARITHMETIC_EXPRESSION": [
        'SIMPLE_ARITHMETIC_EXPRESSION ARITHMETIC_OPERATOR EXPRESSION_ENCLOSED',
        'EXPRESSION_ENCLOSED'
    ],
    
    "ASSIGNMENT_SIMPLE": ['NEW_LINE VARIABLE SPACE EQUALS SPACE EXPRESSION'],
    "ASSIGNMENT_SIMPLE_FIXED": ['NEW_LINE FIXED_VAR SPACE EQUALS SPACE FIXED_DIGIT'],
    "ASSIGNMENT_COMPLEX": [
        'NEW_LINE DEFINE_VAR SPACE VARIABLE SPACE EQUALS SPACE SIMPLE_ARITHMETIC_EXPRESSION SPACE'
        'NEW_LINE DEFINE_VAR SPACE VARIABLE SPACE EQUALS SPACE EXPRESSION SPACE',
        ''
    ],
    
    # Conditional expressions
    "OPTIONAL_NOT": ['LOGICAL_OPERATOR_PREFIX', ''],
    "CONDITIONAL_EXPRESSION": [
        'EXPRESSION_IDENTIFIER SPACE RELATIONAL_OPERATOR SPACE EXPRESSION_IDENTIFIER',
        'EXPRESSION_IDENTIFIER SPACE RELATIONAL_OPERATOR SPACE DIGIT',
    ],
    "CONDITION": ['OPTIONAL_NOT CONDITIONAL_EXPRESSION', 'CONDITIONAL_EXPRESSION'],
    "ENCLOSED_CONDITION": ['PARENTHESIS_OPEN CONDITION PARENTHESIS_CLOSE'],
    "CHAIN_CONDITION": [
        'CHAIN_CONDITION SPACE LOGICAL_OPERATOR SPACE ENCLOSED_CONDITION',
        'LOGICAL_OPERATOR_PREFIX SPACE ENCLOSED_CONDITION',
        'ENCLOSED_CONDITION'
    ],
    # Control structures
    "IF_SIMPLE": ['NEW_LINE IF PARENTHESIS_OPEN CONDITION PARENTHESIS_CLOSE SPACE BRACKET_OPEN',],
    "IF_COMPLEX": ['NEW_LINE IF PARENTHESIS_OPEN CHAIN_CONDITION PARENTHESIS_CLOSE SPACE BRACKET_OPEN'],
    "ELSE_IF_SIMPLE": ['NEW_LINE ELSE SPACE IF PARENTHESIS_OPEN CONDITION PARENTHESIS_CLOSE SPACE BRACKET_OPEN'],
    "ELSE_IF_COMPLEX": ['NEW_LINE ELSE SPACE IF PARENTHESIS_OPEN CHAIN_CONDITION PARENTHESIS_CLOSE SPACE BRACKET_OPEN'],
    "ELSE_SIMPLE": ['NEW_LINE ELSE SPACE BRACKET_OPEN'],
    
    # For loops
    "FOR_INIT": [''],
    "FOR_UPDATE": ['ASSIGNMENT_SIMPLE', 'ASSIGNMENT_COMPLEX'],
    "FOR_SIMPLE": [
        'NEW_LINE FOR PARENTHESIS_OPEN \
        DEFINE_VAR SPACE FIXED_VAR SPACE EQUALS SPACE FIXED_DIGIT_1 \
        SEMICOLON SPACE \
        FIXED_VAR SPACE FIXED_RELATIONAL_OPERATOR SPACE FIXED_DIGIT_2 \
        SEMICOLON SPACE \
        FIXED_VAR FIXED_DIGIT_3 \
        PARENTHESIS_CLOSE SPACE BRACKET_OPEN'
    ], # For FIXED_DIGIT, the third one is actually for inc/dec operators
    
    # While loops
    "WHILE_SIMPLE": [
        'FIXED_LOOP_ASSIGNMENT \
        NEW_LINE WHILE PARENTHESIS_OPEN \
        FIXED_VAR SPACE FIXED_RELATIONAL_OPERATOR SPACE FIXED_DIGIT \
        PARENTHESIS_CLOSE SPACE BRACKET_OPEN \
        DISPLAY_COMPLEX WHILE_END BRACKET_CLOSE'    
    ],
    
    
    'DISPLAY_SIMPLE': ['NEW_LINE PRINT PARENTHESIS_OPEN DISPLAY_IDENTIFIER PARENTHESIS_CLOSE'],
    'DISPLAY_SIMPLE_TABBED': ['NEW_LINE TAB PRINT PARENTHESIS_OPEN DISPLAY_IDENTIFIER PARENTHESIS_CLOSE'],
    'DISPLAY_COMPLEX': ['NEW_LINE PRINT PARENTHESIS_OPEN EXPRESSION_DISPLAY PARENTHESIS_CLOSE'],
    
    
    # Levels of complexity
    "LEVEL_1.1": ['IDENTIFIER_INITIALIZATION ASSIGNMENT_SIMPLE DISPLAY_COMPLEX'],
    "LEVEL_1.2": ['IDENTIFIER_INITIALIZATION ASSIGNMENT_COMPLEX DISPLAY_COMPLEX'],
    "LEVEL_2.1": [
        'IDENTIFIER_INITIALIZATION IF_SIMPLE DISPLAY_SIMPLE_TABBED BRACKET_CLOSE',
        'IDENTIFIER_INITIALIZATION IF_SIMPLE DISPLAY_SIMPLE_TABBED BRACKET_CLOSE ELSE_IF_SIMPLE DISPLAY_SIMPLE_TABBED BRACKET_CLOSE ELSE_SIMPLE DISPLAY_SIMPLE_TABBED BRACKET_CLOSE',
        'IDENTIFIER_INITIALIZATION IF_SIMPLE DISPLAY_SIMPLE_TABBED BRACKET_CLOSE ELSE_SIMPLE DISPLAY_SIMPLE_TABBED BRACKET_CLOSE',
    ],
    "LEVEL_3.1": [
        'IDENTIFIER_INITIALIZATION FOR_SIMPLE DISPLAY_COMPLEX BRACKET_CLOSE',
    ],
    "LEVEL_3.2": ['IDENTIFIER_INITIALIZATION ASSIGNMENT_COMPLEX FOR_SIMPLE DISPLAY_COMPLEX BRACKET_CLOSE'],
    "LEVEL_4.1": [
        'IDENTIFIER_INITIALIZATION WHILE_SIMPLE',
    ],
    
    "ALL": ['LEVEL_1.1', 'LEVEL_1.2', 'LEVEL_2.1', 'LEVEL_3.1', 'LEVEL_3.2', 'LEVEL_4.1'],
}

def get_grammer(): return grammer_rules