"""Visual styling utilities for typography, backgrounds, borders, shadows, and effects. Depends on colors module for color validation."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/style.ipynb.

# %% auto 0
__all__ = ['test_style_usage_examples']

# %% ../nbs/style.ipynb 3
from typing import Union, Literal, Optional, Tuple, Self

from .core import TailwindBuilder, patch, _spacing_class, _format_spacing_value, deduplicate_classes
from .types import ColorValue, OpacityValue, SpacingValue
from .validation import InvalidValueError, InvalidColorError, validate_opacity_value
from .colors import normalize_color, validate_color_value, is_valid_color, HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN

# %% ../nbs/style.ipynb 6
@patch
def text(self:TailwindBuilder, 
         size: Optional[Union[Literal["xs", "sm", "base", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "8xl", "9xl"], str]] = None,
         align: Optional[Literal["left", "center", "right", "justify", "start", "end"]] = None,
         weight: Optional[Literal["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"]] = None,
         color: Optional[Union[ColorValue, str]] = None) -> Self:
    """Generate text utility classes with color validation and arbitrary value support."""
    classes = []
    if size:
        if isinstance(size, str) and size not in ["xs", "sm", "base", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "8xl", "9xl"]:
            # Check if it's an arbitrary value
            if any(unit in size for unit in ['px', 'em', 'rem', 'pt', 'vh', 'vw']):
                classes.append(f"text-[{size}]")
            else:
                classes.append(f"text-{size}")
        else:
            classes.append(f"text-{size}")
    if align:
        classes.append(f"text-{align}")
    if weight:
        classes.append(f"font-{weight}")
    if color:
        # Check if color already contains opacity (e.g., 'white/80')
        opacity = None
        if isinstance(color, str) and "/" in color:
            color_part, opacity_str = color.rsplit("/", 1)
            try:
                opacity = int(opacity_str)
                color = color_part
            except ValueError:
                # Not a valid opacity suffix, treat as regular color
                pass
        
        # Normalize the color value
        color = normalize_color(color)
        
        # Check if it's a valid Tailwind color or special color
        if is_valid_color(color) and not any(pattern.match(color) for pattern in [HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN]):
            text_class = f"text-{color}"
        # Check if it's an arbitrary color value
        elif isinstance(color, str) and (color.startswith('#') or color.startswith('rgb') or color.startswith('hsl') or color.startswith('var(')):
            text_class = f"text-[{color}]"
        else:
            # For any other string, assume it's a Tailwind color
            text_class = f"text-{color}"
        
        # Apply opacity if it was extracted
        if opacity is not None:
            text_class = f"{text_class}/{opacity}"
        
        classes.append(text_class)
    
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 7
@patch
def font(
    self:TailwindBuilder,
    family: Union[Literal["sans", "serif", "mono"], str]  # Font family type or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate font family utility class with arbitrary value support."""
    if family in ["sans", "serif", "mono"]:
        class_str = f"font-{family}"
    else:
        # Arbitrary font family
        class_str = f"font-[{family}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 8
@patch
def leading(
    self:TailwindBuilder,
    value: Union[Literal["none", "tight", "snug", "normal", "relaxed", "loose"], int, str]  # Line height value or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate line-height utility class with arbitrary value support."""
    if isinstance(value, str) and value not in ["none", "tight", "snug", "normal", "relaxed", "loose"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '.']) or value.replace('.', '').isdigit():
            class_str = f"leading-[{value}]"
        else:
            class_str = f"leading-{value}"
    else:
        class_str = f"leading-{value}"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 9
@patch
def tracking(
    self:TailwindBuilder,
    value: Union[Literal["tighter", "tight", "normal", "wide", "wider", "widest"], str]  # Letter spacing value or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate letter-spacing utility class with arbitrary value support."""
    if value in ["tighter", "tight", "normal", "wide", "wider", "widest"]:
        class_str = f"tracking-{value}"
    else:
        # Arbitrary value
        class_str = f"tracking-[{value}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 11
@patch
def bg(
    self:TailwindBuilder,
    color: Union[ColorValue, str],  # Background color value or arbitrary value
    opacity: Optional[OpacityValue] = None,  # Optional opacity value (0-100)
    validate: bool = True # Vaidate the provided color predefined Tailwind color palette
) -> Self:  # Returns self for chaining
    """Generate background color utility class with validation and arbitrary value support."""
    try:
        # Check if color already contains opacity (e.g., 'white/80')
        if isinstance(color, str) and "/" in color and opacity is None:
            color_part, opacity_str = color.rsplit("/", 1)
            try:
                opacity = int(opacity_str)
                color = color_part
            except ValueError:
                # Not a valid opacity suffix, treat as regular color
                pass

        # Validate opacity if provided
        if validate and opacity is not None:
            validate_opacity_value(opacity)
        
        # Normalize the color value
        color = normalize_color(color)

        if validate:
            # Validate the color (allow opacity suffix for validation purposes)
            validate_color_value(color, allow_opacity_suffix=False)
        
        # Check if it's a valid Tailwind color or special color
        if is_valid_color(color) and not any(pattern.match(color) for pattern in [HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN]):
            base = f"bg-{color}"
        # Check if it's an arbitrary color value
        elif isinstance(color, str) and (color.startswith('#') or color.startswith('rgb') or color.startswith('hsl') or color.startswith('var(')):
            base = f"bg-[{color}]"
        else:
            # For any other string, assume it's a Tailwind color
            base = f"bg-{color}"
        
        # Apply opacity if provided
        if opacity is not None:
            class_str = f"{base}/{opacity}"
        else:
            class_str = base
            
        self._add_class(class_str)
        return self
    except InvalidValueError:
        # Re-raise InvalidValueError as-is (for opacity errors)
        raise
    except InvalidColorError as e:
        # Add context to color errors
        raise InvalidColorError(f"Invalid background color: {e}")

# %% ../nbs/style.ipynb 13
@patch
def border(self:TailwindBuilder, 
           width: Optional[Union[Literal[0, 2, 4, 8], Literal[""], str]] = "",
           side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None,
           color: Optional[Union[ColorValue, str]] = None,  # Border color value or arbitrary value
           style: Optional[Literal["solid", "dashed", "dotted", "double", "hidden", "none"]] = None) -> Self:
    """Generate border utility classes with color validation and arbitrary value support."""
    classes = []
    
    # Border width
    border_prefix = f"border{'-' + side if side else ''}"
    if width == "":
        classes.append(border_prefix)
    elif isinstance(width, str) and width not in ["0", "2", "4", "8"]:
        # Arbitrary width value
        classes.append(f"{border_prefix}-[{width}]")
    else:
        classes.append(f"{border_prefix}-{width}")
    
    # Border color
    if color:
        # Check if color already contains opacity (e.g., 'red-300/50')
        opacity = None
        if isinstance(color, str) and "/" in color:
            color_part, opacity_str = color.rsplit("/", 1)
            try:
                opacity = int(opacity_str)
                color = color_part
            except ValueError:
                # Not a valid opacity suffix, treat as regular color
                pass
        
        # Normalize the color value
        color = normalize_color(color)
        
        # Check if it's a valid Tailwind color or special color
        if is_valid_color(color) and not any(pattern.match(color) for pattern in [HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN]):
            border_class = f"border-{color}"
        # Check if it's an arbitrary color value
        elif isinstance(color, str) and (color.startswith('#') or color.startswith('rgb') or color.startswith('hsl') or color.startswith('var(')):
            border_class = f"border-[{color}]"
        else:
            # For any other string, assume it's a Tailwind color
            border_class = f"border-{color}"
        
        # Apply opacity if it was extracted
        if opacity is not None:
            border_class = f"{border_class}/{opacity}"
        
        classes.append(border_class)
    
    # Border style
    if style:
        classes.append(f"border-{style}")
    
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 14
@patch
def rounded(self:TailwindBuilder, 
            size: Optional[Union[Literal["none", "sm", "", "md", "lg", "xl", "2xl", "3xl", "full"], str]] = "",
            side: Optional[Literal["t", "r", "b", "l", "tl", "tr", "br", "bl"]] = None) -> Self:
    """Generate border-radius utility class with arbitrary value support."""
    prefix = f"rounded{'-' + side if side else ''}"
    if size == "":
        class_str = prefix
    elif size in ["none", "sm", "md", "lg", "xl", "2xl", "3xl", "full"]:
        class_str = f"{prefix}-{size}"
    else:
        # Arbitrary value
        class_str = f"{prefix}-[{size}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 16
@patch
def shadow(
    self:TailwindBuilder,
    size: Optional[Union[Literal["sm", "", "md", "lg", "xl", "2xl", "inner", "none"], str]] = ""  # Shadow size or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate box-shadow utility class with arbitrary value support."""
    if size == "":
        class_str = "shadow"
    elif size in ["sm", "md", "lg", "xl", "2xl", "inner", "none"]:
        class_str = f"shadow-{size}"
    else:
        # Arbitrary shadow value
        class_str = f"shadow-[{size}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 18
@patch
def opacity(
    self:TailwindBuilder,
    value: Union[OpacityValue, int, float, str]  # Opacity value or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate opacity utility class with arbitrary value support."""
    if value in [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]:
        class_str = f"opacity-{value}"
    else:
        # Arbitrary opacity value
        class_str = f"opacity-[{value}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 20
@patch
def overflow(self:TailwindBuilder, 
             value: Literal["auto", "hidden", "clip", "visible", "scroll"],
             axis: Optional[Literal["x", "y"]] = None) -> Self:
    """Generate overflow utility class."""
    if axis:
        class_str = f"overflow-{axis}-{value}"
    else:
        class_str = f"overflow-{value}"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 22
@patch
def object(self:TailwindBuilder, 
           fit: Optional[Literal["contain", "cover", "fill", "none", "scale-down"]] = None,
           position: Optional[Union[Literal["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], str]] = None) -> Self:
    """Generate object-fit and object-position utility classes with arbitrary value support."""
    classes = []
    if fit:
        classes.append(f"object-{fit}")
    if position:
        if position in ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]:
            classes.append(f"object-{position}")
        else:
            # Arbitrary position value
            classes.append(f"object-[{position}]")
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 24
@patch
def cursor(
    self:TailwindBuilder,
    value: Union[Literal["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"], str]  # Cursor type or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate cursor utility class with arbitrary value support."""
    if value in ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"]:
        class_str = f"cursor-{value}"
    else:
        # Arbitrary cursor value
        class_str = f"cursor-[{value}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 26
@patch
def transition(self:TailwindBuilder, 
               property: Optional[Literal["none", "all", "", "colors", "opacity", "shadow", "transform"]] = "",
               duration: Optional[Union[Literal[75, 100, 150, 200, 300, 500, 700, 1000], int, str]] = None,
               timing: Optional[Union[Literal["linear", "in", "out", "in-out"], str]] = None,
               delay: Optional[Union[int, str]] = None) -> Self:
    """Generate transition utility classes with arbitrary value support."""
    classes = []
    
    if property == "":
        classes.append("transition")
    else:
        classes.append(f"transition-{property}")
    
    if duration:
        if duration in [75, 100, 150, 200, 300, 500, 700, 1000]:
            classes.append(f"duration-{duration}")
        else:
            # Arbitrary duration
            classes.append(f"duration-[{duration}]")
    
    if timing:
        if timing in ["linear", "in", "out", "in-out"]:
            classes.append(f"ease-{timing}")
        else:
            # Arbitrary timing function
            classes.append(f"ease-[{timing}]")
    
    if delay:
        if isinstance(delay, int) and delay in [75, 100, 150, 200, 300, 500, 700, 1000]:
            classes.append(f"delay-{delay}")
        else:
            # Arbitrary delay
            classes.append(f"delay-[{delay}]")
    
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 27
@patch
def animate(
    self:TailwindBuilder,
    value: Union[Literal["none", "spin", "ping", "pulse", "bounce"], str]  # Animation type or arbitrary value
) -> Self:  # Returns self for chaining
    """Generate animation utility class with arbitrary value support."""
    if value in ["none", "spin", "ping", "pulse", "bounce"]:
        class_str = f"animate-{value}"
    else:
        # Arbitrary animation
        class_str = f"animate-[{value}]"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 29
@patch
def transform(self:TailwindBuilder, 
              scale: Optional[Union[Literal[0, 50, 75, 90, 95, 100, 105, 110, 125, 150], Tuple[Literal["x", "y"], Union[Literal[0, 50, 75, 90, 95, 100, 105, 110, 125, 150], str]], str]] = None,
              rotate: Optional[Union[Literal[0, 1, 2, 3, 6, 12, 45, 90, 180], Literal["-1", "-2", "-3", "-6", "-12", "-45", "-90", "-180"], str]] = None,
              translate: Optional[Union[Tuple[Literal["x", "y"], Union[SpacingValue, str, Tuple[Union[SpacingValue, str], bool]]], str]] = None) -> Self:
    "Generate transform utility classes with arbitrary value support and negative translate."
    classes = ["transform"]
    
    if scale is not None:
        if isinstance(scale, tuple):
            axis, value = scale
            if isinstance(value, str) and value not in [0, 50, 75, 90, 95, 100, 105, 110, 125, 150]:
                classes.append(f"scale-{axis}-[{value}]")
            else:
                classes.append(f"scale-{axis}-{value}")
        elif isinstance(scale, str):
            classes.append(f"scale-[{scale}]")
        else:
            classes.append(f"scale-{scale}")
    
    if rotate is not None:
        if isinstance(rotate, str) and rotate not in ["0", "1", "2", "3", "6", "12", "45", "90", "180", "-1", "-2", "-3", "-6", "-12", "-45", "-90", "-180"]:
            classes.append(f"rotate-[{rotate}]")
        else:
            # Handle negative rotation values properly
            if str(rotate).startswith("-"):
                classes.append(f"-rotate-{str(rotate)[1:]}")
            else:
                classes.append(f"rotate-{rotate}")
    
    if translate:
        if isinstance(translate, str):
            # Single arbitrary translate value
            classes.append(f"translate-[{translate}]")
        else:
            axis, value_spec = translate
            
            # Check if negative is specified
            if isinstance(value_spec, tuple):
                value, negative = value_spec
                is_negative = negative
            else:
                value = value_spec
                is_negative = False
                
            # Check if value is already negative
            if isinstance(value, (int, float)) and value < 0:
                is_negative = True
                value = abs(value)
            
            prefix = f"translate-{axis}"
            if is_negative:
                prefix = f"-{prefix}"
                
            if isinstance(value, str) and not value in ["px", "auto", "full"]:
                # Check if it's an arbitrary value
                if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                    classes.append(f"{prefix}-[{value}]")
                else:
                    classes.append(f"{prefix}-{_format_spacing_value(value)}")
            else:
                classes.append(f"{prefix}-{_format_spacing_value(value)}")
    
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 31
@patch
def container(
    self:TailwindBuilder,
    center: bool = True,  # Whether to center the container with mx-auto
    padding: Optional[SpacingValue] = None  # Optional padding to add
) -> Self:  # Returns self for chaining
    """Generate container utility classes."""
    classes = ["container"]
    if center:
        classes.append("mx-auto")
    if padding is not None:
        classes.append(self._spacing_class("p", padding))
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 32
@patch
def stack(
    self:TailwindBuilder,
    gap: SpacingValue = 4  # Gap between stacked items
) -> Self:  # Returns self for chaining
    """Generate flex stack utility classes."""
    class_str = f"flex flex-col {self._spacing_class('gap', gap)}"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 33
@patch
def center(
    self:TailwindBuilder,
    method: Literal["flex", "grid", "absolute"] = "flex"  # Centering method to use
) -> Self:  # Returns self for chaining
    """Generate centering utility classes."""
    if method == "flex":
        class_str = "flex items-center justify-center"
    elif method == "grid":
        class_str = "grid place-items-center"
    elif method == "absolute":
        class_str = "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
    else:
        class_str = ""
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 34
@patch
def prose(
    self:TailwindBuilder,
    size: Optional[Literal["sm", "", "lg", "xl", "2xl"]] = ""  # Prose size variant
) -> Self:  # Returns self for chaining
    """Generate prose (typography) utility classes."""
    class_str = "prose" if size == "" else f"prose prose-{size}"
    self._add_class(class_str)
    return self

# %% ../nbs/style.ipynb 35
@patch
def sr_only(
    self:TailwindBuilder
) -> Self:  # Returns self for chaining
    """Generate screen reader only utility class."""
    self._add_class("sr-only")
    return self

# %% ../nbs/style.ipynb 36
@patch
def not_sr_only(
    self:TailwindBuilder
) -> Self:  # Returns self for chaining
    """Generate not screen reader only utility class."""
    self._add_class("not-sr-only")
    return self

# %% ../nbs/style.ipynb 46
def test_style_usage_examples(
): # TODO: Add type hint
    """
    Test and demonstrate style utilities for visual styling and effects.
    
    This function serves as both a test suite and a comprehensive usage guide
    for the style utilities in cjm-tailwind-utils. It demonstrates:
    
    1. Typography utilities (text size, color, alignment, weight)
    2. Font and text styling (family, line height, letter spacing)
    3. Background colors with opacity support
    4. Border utilities with comprehensive options
    5. Border radius (rounded corners)
    6. Shadow effects
    7. Opacity control
    8. Overflow behavior
    9. Object fit and position
    10. Cursor styles
    11. Transitions and animations
    12. Transform utilities (scale, rotate, translate)
    13. Helper utilities (container, stack, center, prose)
    14. Error handling for invalid values
    
    Each test includes clear examples to help coding assistants understand
    proper usage of visual styling utilities.
    """
    
    # Import necessary for standalone usage
    from cjm_tailwind_utils.core import TailwindBuilder
    from cjm_tailwind_utils.validation import InvalidColorError
    
    # === Typography Utilities ===
    # Control text appearance
    
    # Text size
    text_size = TailwindBuilder().text(size="lg").build()
    assert text_size == "text-lg", "Large text size"
    
    # Text with multiple properties
    text_styled = TailwindBuilder().text(size="2xl", color="blue-500").build()
    assert text_styled == "text-2xl text-blue-500", "Text size and color"
    
    # Text alignment and weight
    text_align_weight = TailwindBuilder().text(align="center", weight="bold").build()
    assert text_align_weight == deduplicate_classes("text-center font-bold"), "Center aligned bold text"
    
    # Arbitrary text size
    text_arbitrary = TailwindBuilder().text(size="16px").build()
    assert text_arbitrary == "text-[16px]", "Arbitrary pixel size"
    
    # Text color with opacity
    text_opacity = TailwindBuilder().text(color="blue-500/50").build()
    assert text_opacity == "text-blue-500/50", "Text color with 50% opacity"
    
    # Hex color text
    text_hex = TailwindBuilder().text(color="#ff0000").build()
    assert text_hex == "text-[#ff0000]", "Hex color text"
    
    # RGB color text
    text_rgb = TailwindBuilder().text(color="rgb(255, 0, 0)").build()
    assert text_rgb == "text-[rgb(255,0,0)]", "RGB color text"
    
    # === Font Family ===
    # Control typeface
    
    font_sans = TailwindBuilder().font("sans").build()
    assert font_sans == "font-sans", "Sans-serif font"
    
    font_serif = TailwindBuilder().font("serif").build()
    assert font_serif == "font-serif", "Serif font"
    
    # Custom font family
    font_custom = TailwindBuilder().font("Inter, sans-serif").build()
    assert font_custom == "font-[Inter, sans-serif]", "Custom font stack"
    
    # === Line Height ===
    # Control spacing between lines
    
    leading_tight = TailwindBuilder().leading("tight").build()
    assert leading_tight == "leading-tight", "Tight line height"
    
    # Numeric line height
    leading_numeric = TailwindBuilder().leading(6).build()
    assert leading_numeric == "leading-6", "Line height scale 6"
    
    # Arbitrary line height
    leading_arbitrary = TailwindBuilder().leading("1.5").build()
    assert leading_arbitrary == "leading-[1.5]", "1.5x line height"
    
    leading_pixels = TailwindBuilder().leading("24px").build()
    assert leading_pixels == "leading-[24px]", "Pixel line height"
    
    # === Letter Spacing ===
    # Control spacing between characters
    
    tracking_wide = TailwindBuilder().tracking("wide").build()
    assert tracking_wide == "tracking-wide", "Wide letter spacing"
    
    # Arbitrary letter spacing
    tracking_em = TailwindBuilder().tracking("0.025em").build()
    assert tracking_em == "tracking-[0.025em]", "Custom em letter spacing"
    
    # === Background Colors ===
    # Set background colors with various formats
    
    # Standard Tailwind color
    bg_blue = TailwindBuilder().bg("blue-500").build()
    assert bg_blue == "bg-blue-500", "Blue background"
    
    # Background with opacity
    bg_opacity = TailwindBuilder().bg("white", opacity=80).build()
    assert bg_opacity == "bg-white/80", "White background 80% opacity"
    
    # Color string with opacity
    bg_color_opacity = TailwindBuilder().bg("blue-500/50").build()
    assert bg_color_opacity == "bg-blue-500/50", "Blue background 50% opacity"
    
    # Hex background
    bg_hex = TailwindBuilder().bg("#ff0000").build()
    assert bg_hex == "bg-[#ff0000]", "Hex color background"
    
    # RGB background
    bg_rgb = TailwindBuilder().bg("rgb(255, 0, 0)").build()
    assert bg_rgb == "bg-[rgb(255,0,0)]", "RGB color background"
    
    # CSS variable background
    bg_var = TailwindBuilder().bg("var(--primary)").build()
    assert bg_var == "bg-[var(--primary)]", "CSS variable background"
    
    # === Border Utilities ===
    # Comprehensive border styling
    
    # Basic border
    border_basic = TailwindBuilder().border().build()
    assert border_basic == "border", "Default border"
    
    # Border width
    border_width = TailwindBuilder().border(2).build()
    assert border_width == "border-2", "2px border"
    
    # Border side with width
    border_side = TailwindBuilder().border(width=0, side="t").build()
    assert border_side == "border-t-0", "Remove top border"
    
    # Border color
    border_color = TailwindBuilder().border(color="red-500").build()
    assert border_color == "border border-red-500", "Red border"
    
    # Border style
    border_style = TailwindBuilder().border(style="dashed").build()
    assert border_style == "border border-dashed", "Dashed border"
    
    # Arbitrary border width
    border_arbitrary = TailwindBuilder().border(width="3px").build()
    assert border_arbitrary == "border-[3px]", "3px border"
    
    # Hex border color
    border_hex = TailwindBuilder().border(color="#ff0000").build()
    assert border_hex == "border border-[#ff0000]", "Hex color border"
    
    # Border color with opacity
    border_opacity = TailwindBuilder().border(color="red-500/50").build()
    assert border_opacity == "border border-red-500/50", "Border with opacity"
    
    # === Border Radius ===
    # Rounded corners
    
    # Default rounded
    rounded_default = TailwindBuilder().rounded().build()
    assert rounded_default == "rounded", "Default border radius"
    
    # Large rounded
    rounded_lg = TailwindBuilder().rounded("lg").build()
    assert rounded_lg == "rounded-lg", "Large border radius"
    
    # Rounded side
    rounded_top = TailwindBuilder().rounded("full", side="t").build()
    assert rounded_top == "rounded-t-full", "Fully rounded top corners"
    
    # Arbitrary radius
    rounded_pixels = TailwindBuilder().rounded("12px").build()
    assert rounded_pixels == "rounded-[12px]", "12px border radius"
    
    # === Shadow Effects ===
    # Box shadows
    
    # Default shadow
    shadow_default = TailwindBuilder().shadow().build()
    assert shadow_default == "shadow", "Default shadow"
    
    # Large shadow
    shadow_lg = TailwindBuilder().shadow("lg").build()
    assert shadow_lg == "shadow-lg", "Large shadow"
    
    # Inner shadow
    shadow_inner = TailwindBuilder().shadow("inner").build()
    assert shadow_inner == "shadow-inner", "Inner shadow"
    
    # Custom shadow
    shadow_custom = TailwindBuilder().shadow("0 4px 6px rgba(0,0,0,0.1)").build()
    assert shadow_custom == "shadow-[0 4px 6px rgba(0,0,0,0.1)]", "Custom shadow"
    
    # === Opacity ===
    # Element transparency
    
    opacity_50 = TailwindBuilder().opacity(50).build()
    assert opacity_50 == "opacity-50", "50% opacity"
    
    opacity_0 = TailwindBuilder().opacity(0).build()
    assert opacity_0 == "opacity-0", "Fully transparent"
    
    # Arbitrary opacity
    opacity_decimal = TailwindBuilder().opacity(0.75).build()
    assert opacity_decimal == "opacity-[0.75]", "75% opacity as decimal"
    
    opacity_string = TailwindBuilder().opacity("0.33").build()
    assert opacity_string == "opacity-[0.33]", "33% opacity as string"
    
    # === Overflow Control ===
    # Content overflow behavior
    
    overflow_hidden = TailwindBuilder().overflow("hidden").build()
    assert overflow_hidden == "overflow-hidden", "Hide overflow"
    
    # Directional overflow
    overflow_x_scroll = TailwindBuilder().overflow("scroll", axis="x").build()
    assert overflow_x_scroll == "overflow-x-scroll", "Horizontal scroll"
    
    overflow_y_auto = TailwindBuilder().overflow("auto", axis="y").build()
    assert overflow_y_auto == "overflow-y-auto", "Vertical auto scroll"
    
    # === Object Fit and Position ===
    # For images and media
    
    object_cover = TailwindBuilder().object(fit="cover").build()
    assert object_cover == "object-cover", "Cover object fit"
    
    object_center = TailwindBuilder().object(position="center").build()
    assert object_center == "object-center", "Center object position"
    
    # Combined object properties
    object_combined = TailwindBuilder().object(fit="contain", position="top").build()
    assert object_combined == "object-contain object-top", "Contain fit, top position"
    
    # Arbitrary position
    object_custom_pos = TailwindBuilder().object(position="25% 75%").build()
    assert object_custom_pos == "object-[25% 75%]", "Custom object position"
    
    # === Cursor Styles ===
    # Mouse cursor appearance
    
    cursor_pointer = TailwindBuilder().cursor("pointer").build()
    assert cursor_pointer == "cursor-pointer", "Pointer cursor"
    
    cursor_not_allowed = TailwindBuilder().cursor("not-allowed").build()
    assert cursor_not_allowed == "cursor-not-allowed", "Not allowed cursor"
    
    # Custom cursor
    cursor_custom = TailwindBuilder().cursor("url(hand.cur), pointer").build()
    assert cursor_custom == "cursor-[url(hand.cur), pointer]", "Custom cursor with fallback"
    
    # === Transitions ===
    # Smooth property changes
    
    # Default transition
    transition_default = TailwindBuilder().transition().build()
    assert transition_default == "transition", "Default transition"
    
    # Transition specific property
    transition_colors = TailwindBuilder().transition("colors").build()
    assert transition_colors == "transition-colors", "Color transitions only"
    
    # Transition with duration
    transition_duration = TailwindBuilder().transition(duration=300).build()
    assert transition_duration == deduplicate_classes("transition duration-300"), "300ms transition"
    
    # Transition timing function
    transition_timing = TailwindBuilder().transition(timing="linear").build()
    assert transition_timing == deduplicate_classes("transition ease-linear"), "Linear timing"
    
    # Transition delay
    transition_delay = TailwindBuilder().transition(delay=150).build()
    assert transition_delay == deduplicate_classes("transition delay-150"), "150ms delay"
    
    # Complex transition
    transition_complex = TailwindBuilder().transition(
        "all", 
        duration="2s", 
        timing="cubic-bezier(0.4, 0, 0.2, 1)"
    ).build()
    assert transition_complex == deduplicate_classes("transition-all duration-[2s] ease-[cubic-bezier(0.4, 0, 0.2, 1)]"), "Complex transition"
    
    # === Animations ===
    # Keyframe animations
    
    animate_spin = TailwindBuilder().animate("spin").build()
    assert animate_spin == "animate-spin", "Spin animation"
    
    animate_bounce = TailwindBuilder().animate("bounce").build()
    assert animate_bounce == "animate-bounce", "Bounce animation"
    
    # Custom animation
    animate_custom = TailwindBuilder().animate("fade-in 0.5s ease-out").build()
    assert animate_custom == "animate-[fade-in 0.5s ease-out]", "Custom animation"
    
    # === Transform Utilities ===
    # 2D transformations
    
    # Base transform
    transform_base = TailwindBuilder().transform().build()
    assert transform_base == "transform", "Enable transforms"
    
    # Scale transform
    transform_scale = TailwindBuilder().transform(scale=110).build()
    assert transform_scale == deduplicate_classes("transform scale-110"), "Scale 110%"
    
    # Axis-specific scale
    transform_scale_x = TailwindBuilder().transform(scale=("x", 75)).build()
    assert transform_scale_x == deduplicate_classes("transform scale-x-75"), "Scale X-axis 75%"
    
    # Arbitrary scale
    transform_scale_arbitrary = TailwindBuilder().transform(scale=("y", "1.5")).build()
    assert transform_scale_arbitrary == deduplicate_classes("transform scale-y-[1.5]"), "Scale Y-axis 1.5x"
    
    # Rotation
    transform_rotate = TailwindBuilder().transform(rotate=45).build()
    assert transform_rotate == deduplicate_classes("transform rotate-45"), "Rotate 45 degrees"
    
    # Negative rotation
    transform_rotate_neg = TailwindBuilder().transform(rotate="-90").build()
    assert transform_rotate_neg == deduplicate_classes("transform -rotate-90"), "Rotate -90 degrees"
    
    # Arbitrary rotation
    transform_rotate_arbitrary = TailwindBuilder().transform(rotate="30deg").build()
    assert transform_rotate_arbitrary == deduplicate_classes("transform rotate-[30deg]"), "Rotate 30deg"
    
    # Translation
    transform_translate = TailwindBuilder().transform(translate=("x", 4)).build()
    assert transform_translate == deduplicate_classes("transform translate-x-4"), "Translate X by spacing 4"
    
    # Negative translation (explicit)
    transform_translate_neg = TailwindBuilder().transform(translate=("x", (4, True))).build()
    assert transform_translate_neg == deduplicate_classes("transform -translate-x-4"), "Negative X translation"
    
    # Negative translation (auto)
    transform_translate_auto_neg = TailwindBuilder().transform(translate=("y", -8)).build()
    assert transform_translate_auto_neg == deduplicate_classes("transform -translate-y-8"), "Auto negative Y translation"
    
    # Arbitrary translation
    transform_translate_percent = TailwindBuilder().transform(translate=("x", "50%")).build()
    assert transform_translate_percent == deduplicate_classes("transform translate-x-[50%]"), "Translate by percentage"
    
    # === Helper Utilities ===
    # Common patterns made easy
    
    # Container
    container_default = TailwindBuilder().container().build()
    assert container_default == "container mx-auto", "Centered container"
    
    container_no_center = TailwindBuilder().container(center=False).build()
    assert container_no_center == "container", "Container without centering"
    
    container_padding = TailwindBuilder().container(padding=4).build()
    assert container_padding == "container mx-auto p-4", "Container with padding"
    
    # Stack (vertical flex)
    stack_default = TailwindBuilder().stack().build()
    assert stack_default == "flex flex-col gap-4", "Default vertical stack"
    
    stack_custom_gap = TailwindBuilder().stack(gap=2).build()
    assert stack_custom_gap == "flex flex-col gap-2", "Stack with custom gap"
    
    # Centering utilities
    center_flex = TailwindBuilder().center().build()
    assert center_flex == "flex items-center justify-center", "Flex centering"
    
    center_grid = TailwindBuilder().center("grid").build()
    assert center_grid == "grid place-items-center", "Grid centering"
    
    center_absolute = TailwindBuilder().center("absolute").build()
    assert center_absolute == deduplicate_classes("absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"), "Absolute centering"
    
    # Prose (typography)
    prose_default = TailwindBuilder().prose().build()
    assert prose_default == "prose", "Default prose"
    
    prose_lg = TailwindBuilder().prose("lg").build()
    assert prose_lg == "prose prose-lg", "Large prose"
    
    # Screen reader utilities
    sr_only = TailwindBuilder().sr_only().build()
    assert sr_only == "sr-only", "Screen reader only"
    
    not_sr_only = TailwindBuilder().not_sr_only().build()
    assert not_sr_only == "not-sr-only", "Not screen reader only"
    
    # === Complex Examples ===
    # Real-world usage patterns
    
    # Styled card
    card = (TailwindBuilder()
        .text(size="lg", color="white")
        .bg("blue-500")
        .rounded("lg")
        .shadow("md")
        .build())
    assert card == deduplicate_classes("text-lg text-white bg-blue-500 rounded-lg shadow-md"), "Complete card styling"
    
    # === Error Handling ===
    # Validate color inputs
    
    # Invalid color name
    try:
        TailwindBuilder().bg("notacolor").build()
        assert False, "Should have raised InvalidColorError"
    except InvalidColorError:
        pass  # Expected
    
    # Invalid color shade
    try:
        TailwindBuilder().bg("blue-1000").build()
        assert False, "Should have raised InvalidColorError"
    except InvalidColorError:
        pass  # Expected
    
    return "All style tests passed!"
