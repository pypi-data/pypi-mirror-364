"""Validation functions and error handling for Tailwind utilities. Internal module - typically not imported directly unless creating custom utilities."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/validation.ipynb.

# %% auto 0
__all__ = ['VALID_SPACING_VALUES', 'VALID_SPACING_STRINGS', 'CONFLICTING_GROUPS', 'TailwindBuilderError', 'InvalidValueError',
           'InvalidColorError', 'ChainModeError', 'validate_spacing_value', 'validate_opacity_value',
           'extract_modifiers', 'extract_class_prefix', 'get_conflicting_group', 'should_replace_class',
           'test_validation_usage_examples']

# %% ../nbs/validation.ipynb 3
import re
from typing import Any, Dict, Optional, Tuple

# %% ../nbs/validation.ipynb 4
class TailwindBuilderError(Exception):
    """Base exception for TailwindBuilder errors."""
    pass

# %% ../nbs/validation.ipynb 5
class InvalidValueError(TailwindBuilderError):
    """Raised when an invalid value is provided to a utility method."""
    pass

# %% ../nbs/validation.ipynb 6
class InvalidColorError(TailwindBuilderError):
    """Raised when an invalid color value is provided."""
    pass

# %% ../nbs/validation.ipynb 7
class ChainModeError(TailwindBuilderError):
    """Raised when chain-mode specific methods are called in direct mode."""
    pass

# %% ../nbs/validation.ipynb 8
VALID_SPACING_VALUES = {  # Valid spacing values including decimals
    0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
    18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 
    56, 58, 60, 62, 64, 68, 72, 76, 80, 84, 88, 92, 96
}

# %% ../nbs/validation.ipynb 9
VALID_SPACING_STRINGS = {"px", "auto", "full"} # Valid spacing strings

# %% ../nbs/validation.ipynb 10
def validate_spacing_value(
    value: Any,  # The value to validate
    allow_negative: bool = False  # Whether to allow negative values
) -> None:  # No return value
    "Validate a spacing value."
    if isinstance(value, (int, float)):
        abs_value = abs(value) if allow_negative else value
        if abs_value not in VALID_SPACING_VALUES:
            raise InvalidValueError(
                f"Invalid spacing value: {value}. "
                f"Must be one of: {sorted(VALID_SPACING_VALUES)} or {VALID_SPACING_STRINGS}"
            )
    elif isinstance(value, str):
        if value not in VALID_SPACING_STRINGS:
            # Check if it's an arbitrary value
            if not any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                raise InvalidValueError(
                    f"Invalid spacing value: '{value}'. "
                    f"Must be one of: {sorted(VALID_SPACING_VALUES)}, {VALID_SPACING_STRINGS}, "
                    f"or an arbitrary value with units (e.g., '1.5rem', 'calc(100% - 20px)')"
                )
    else:
        raise InvalidValueError(f"Spacing value must be a number or string, got {type(value).__name__}")

# %% ../nbs/validation.ipynb 11
def validate_opacity_value(
    value: Any  # The opacity value to validate
) -> None:  # No return value
    "Validate an opacity value."
    valid_values = {0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100}
    
    if isinstance(value, (int, float)):
        if value not in valid_values and not (0 <= value <= 100):
            raise InvalidValueError(
                f"Invalid opacity value: {value}. "
                f"Must be one of: {sorted(valid_values)} or between 0-100"
            )
    else:
        raise InvalidValueError(f"Opacity value must be a number, got {type(value).__name__}")

# %% ../nbs/validation.ipynb 12
CONFLICTING_GROUPS: Dict[str, Tuple[str, ...]] = { # Utility groups that conflict with each other
    'padding': ('p', 'px', 'py', 'pt', 'pr', 'pb', 'pl'),
    'margin': ('m', 'mx', 'my', 'mt', 'mr', 'mb', 'ml'),
    'width': ('w',),
    'height': ('h',),
    'min-width': ('min-w',),
    'max-width': ('max-w',),
    'min-height': ('min-h',),
    'max-height': ('max-h',),
    'background': ('bg',),
    'text-color': ('text',),
    'border-color': ('border',),
    'border-width': ('border', 'border-t', 'border-r', 'border-b', 'border-l', 'border-x', 'border-y'),
    'display': ('block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'grid', 'hidden'),
    'position': ('static', 'fixed', 'absolute', 'relative', 'sticky'),
    'rounded': ('rounded', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'),
    'shadow': ('shadow',),
    'opacity': ('opacity',),
    'z-index': ('z',),
    'flex-direction': ('flex-row', 'flex-row-reverse', 'flex-col', 'flex-col-reverse'),
    'flex-wrap': ('flex-wrap', 'flex-wrap-reverse', 'flex-nowrap'),
    'flex-grow': ('grow', 'grow-0'),
    'flex-shrink': ('shrink', 'shrink-0'),
}

# %% ../nbs/validation.ipynb 13
def extract_modifiers(
    class_str: str  # Tailwind class string to extract modifiers from
) -> Tuple[str, str]:  # Tuple of (modifiers, base_class) where modifiers is like 'hover:dark:' or ''
    "Extract modifiers and base class from a utility class."
    parts = class_str.split(':')
    if len(parts) == 1:
        return '', class_str
    
    modifiers = ':'.join(parts[:-1]) + ':'
    base_class = parts[-1]
    return modifiers, base_class

# %% ../nbs/validation.ipynb 14
def extract_class_prefix(
    class_str: str  # Tailwind class string to extract prefix from
) -> str:  # The extracted prefix (e.g., 'p' from 'p-4', 'bg' from 'bg-blue-500')
    """Extract the prefix from a utility class.
    """
    # Remove all modifiers (hover:, sm:, etc.)
    _, base_class = extract_modifiers(class_str)
    
    # Handle arbitrary values
    if '[' in base_class:
        match = re.match(r'^([a-z-]+)-\[', base_class)
        if match:
            return match.group(1)
    
    # Special handling for compound flex utilities
    if base_class in ['flex-wrap', 'flex-wrap-reverse', 'flex-nowrap',
                      'flex-row', 'flex-row-reverse', 'flex-col', 'flex-col-reverse',
                      'grow', 'grow-0', 'shrink', 'shrink-0']:
        return base_class
    
    # Special handling for padding/margin directional variants
    if base_class.startswith(('px-', 'py-', 'pt-', 'pr-', 'pb-', 'pl-',
                             'mx-', 'my-', 'mt-', 'mr-', 'mb-', 'ml-')):
        return base_class.split('-')[0]
    
    # Extract prefix from regular classes
    if '-' in base_class:
        return base_class.split('-')[0]
    
    # Return full class for non-hyphenated utilities
    return base_class

# %% ../nbs/validation.ipynb 15
def get_conflicting_group(
    prefix: str  # The utility prefix to check for conflicts
) -> Optional[str]:  # The conflicting group name if found, None otherwise
    """Get the conflicting group for a given prefix.
    """
    for group_name, prefixes in CONFLICTING_GROUPS.items():
        if prefix in prefixes:
            return group_name
    return None

# %% ../nbs/validation.ipynb 16
def should_replace_class(
    existing_class: str,  # The existing class string in the builder
    new_class: str  # The new class string being added
) -> bool:  # True if new_class should replace existing_class, False otherwise
    """Determine if new_class should replace existing_class.
    """
    # Extract modifiers first
    existing_modifiers, existing_base = extract_modifiers(existing_class)
    new_modifiers, new_base = extract_modifiers(new_class)
    
    # Classes with different modifiers never conflict
    if existing_modifiers != new_modifiers:
        return False
    
    existing_prefix = extract_class_prefix(existing_class)
    new_prefix = extract_class_prefix(new_class)
    
    # Check if they belong to the same conflicting group
    existing_group = get_conflicting_group(existing_prefix)
    new_group = get_conflicting_group(new_prefix)
    
    if existing_group and new_group and existing_group == new_group:
        # Special handling for padding/margin groups
        if existing_group in ['padding', 'margin']:
            general_prefix = existing_group[0]  # 'p' for padding, 'm' for margin
            
            # Same prefix always replaces
            if existing_prefix == new_prefix:
                return True
                
            # General utility (p/m) only replaces other general utilities
            if new_prefix == general_prefix:
                return existing_prefix == general_prefix
                
            # Specific utilities replace other specific utilities of the same type
            # but not general utilities or other specific types
            return False
        
        # For other groups, same group means replacement
        return True
    
    # Special case for color utilities with the same prefix
    if existing_prefix == new_prefix and existing_prefix in ['bg', 'text', 'border']:
        return True
    
    return False

# %% ../nbs/validation.ipynb 25
def test_validation_usage_examples(
): # TODO: Add type hint
    """
    Test and demonstrate validation utilities for class deduplication.
    
    This function serves as both a test suite and a comprehensive usage guide
    for the validation system that powers intelligent class deduplication.
    It demonstrates:
    
    1. Extracting class prefixes from utility classes
    2. Handling modifiers (hover:, sm:, dark:, etc.)
    3. Detecting conflicting utility groups
    4. Smart replacement logic for deduplication
    5. Special handling for flex utilities
    6. Padding/margin specificity rules
    7. Value validation for spacing and opacity
    
    Each test includes clear examples to help coding assistants understand
    how the deduplication system works under the hood.
    """
    
    # === Extracting Class Prefixes ===
    # The prefix is the base utility without values or modifiers
    
    # Basic utilities
    assert extract_class_prefix('p-4') == 'p', "Extract 'p' from padding utility"
    assert extract_class_prefix('px-6') == 'px', "Extract 'px' from horizontal padding"
    assert extract_class_prefix('bg-blue-500') == 'bg', "Extract 'bg' from background color"
    
    # With modifiers (hover:, sm:, etc.)
    assert extract_class_prefix('hover:bg-blue-500') == 'bg', "Modifiers are stripped first"
    assert extract_class_prefix('sm:p-4') == 'p', "Responsive modifiers are stripped"
    assert extract_class_prefix('dark:hover:text-white') == 'text', "Multiple modifiers are handled"
    
    # Special flex utilities (treated as whole units)
    assert extract_class_prefix('flex') == 'flex', "Base flex utility"
    assert extract_class_prefix('flex-wrap') == 'flex-wrap', "Flex-wrap is its own prefix"
    assert extract_class_prefix('flex-col') == 'flex-col', "Flex direction utilities"
    assert extract_class_prefix('grow') == 'grow', "Flex grow utilities"
    assert extract_class_prefix('grow-0') == 'grow-0', "Flex grow with value"
    
    # === Class Replacement Logic ===
    # Determines when one class should replace another during deduplication
    
    # Same prefix classes replace each other
    assert should_replace_class('p-4', 'p-8') == True, "p-8 should replace p-4"
    assert should_replace_class('bg-red-500', 'bg-blue-500') == True, "Colors of same type replace"
    
    # Different modifiers never conflict
    assert should_replace_class('hover:p-4', 'p-4') == False, "Different modifiers don't conflict"
    assert should_replace_class('p-4', 'hover:p-4') == False, "Base and hover are independent"
    
    # === Flex Utility Special Rules ===
    # Flex utilities have special non-conflicting behavior
    
    # Base flex doesn't conflict with flex properties
    assert should_replace_class('flex', 'flex-wrap') == False, "flex and flex-wrap are compatible"
    assert should_replace_class('flex-wrap', 'flex') == False, "Order doesn't matter"
    
    # Same flex property group conflicts
    assert should_replace_class('flex-wrap', 'flex-nowrap') == True, "Wrap values conflict"
    assert should_replace_class('flex-col', 'flex-row') == True, "Direction values conflict"
    
    # === Padding/Margin Specificity ===
    # More specific utilities don't replace less specific ones
    
    # General padding doesn't replace specific directional padding
    assert should_replace_class('p-4', 'px-4') == False, "p-4 doesn't remove px-4"
    assert should_replace_class('px-4', 'p-4') == False, "px-4 doesn't remove p-4"
    
    # Same directional padding replaces
    assert should_replace_class('px-4', 'px-8') == True, "px-8 replaces px-4"
    assert should_replace_class('mt-2', 'mt-4') == True, "mt-4 replaces mt-2"
    
    # === Conflicting Groups ===
    # Utilities are organized into groups that conflict with each other
    
    assert get_conflicting_group('p') == 'padding', "p belongs to padding group"
    assert get_conflicting_group('flex') == 'display', "flex belongs to display group"
    assert get_conflicting_group('flex-wrap') == 'flex-wrap', "flex-wrap has its own group"
    assert get_conflicting_group('grow') == 'flex-grow', "grow belongs to flex-grow group"
    
    # === Value Validation ===
    # Ensure only valid Tailwind values are used
    
    # Valid spacing values
    try:
        validate_spacing_value(4)  # Standard spacing scale
        validate_spacing_value('auto')  # Special keyword
        validate_spacing_value('2rem')  # Arbitrary value with unit
        spacing_valid = True
    except Exception:
        spacing_valid = False
    assert spacing_valid, "Valid spacing values should pass validation"
    
    # Invalid spacing values
    try:
        validate_spacing_value(99)  # Not in Tailwind scale
        assert False, "Invalid spacing should raise error"
    except InvalidValueError:
        pass  # Expected
    
    # Valid opacity values
    try:
        validate_opacity_value(50)  # Standard opacity scale
        validate_opacity_value(75)  # Another valid opacity
        validate_opacity_value(33)  # Any value 0-100 is valid
        opacity_valid = True
    except Exception:
        opacity_valid = False
    assert opacity_valid, "Valid opacity values (0-100) should pass validation"
    
    # Invalid opacity values
    try:
        validate_opacity_value(150)  # Over 100
        assert False, "Invalid opacity should raise error"
    except InvalidValueError:
        pass  # Expected
        
    try:
        validate_opacity_value(-10)  # Negative value
        assert False, "Negative opacity should raise error"
    except InvalidValueError:
        pass  # Expected
    
    # === Modifier Extraction ===
    # Separate modifiers from base classes
    
    modifiers, base = extract_modifiers('hover:dark:bg-blue-500')
    assert modifiers == 'hover:dark:', "Extract all modifiers with colons"
    assert base == 'bg-blue-500', "Base class without modifiers"
    
    modifiers, base = extract_modifiers('p-4')
    assert modifiers == '', "No modifiers returns empty string"
    assert base == 'p-4', "Base class is unchanged"
    
    return "All validation tests passed!"
