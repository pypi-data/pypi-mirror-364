"""CLI tool for Claude Code and other coding assistants to understand and use cjm-tailwind-utils optimally"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/cli.ipynb.

# %% ../nbs/cli.ipynb 4
from __future__ import annotations
import argparse
import sys
import inspect
import importlib
from pathlib import Path
from typing import Dict, List, Any, Optional, get_type_hints
from dataclasses import dataclass

from .core import TailwindBuilder

# %% auto 0
__all__ = ['MethodInfo', 'get_all_tailwind_methods', 'get_module_methods', 'cmd_list_methods', 'cmd_module_info', 'cmd_search',
           'cmd_method_details', 'cmd_source', 'VariableInfo', 'get_all_exported_variables', 'cmd_list_variables',
           'cmd_variable_details', 'cmd_variable_source', 'TypeInfo', 'get_all_type_definitions', 'cmd_list_types',
           'cmd_type_details', 'cmd_type_source', 'ImportInfo', 'get_import_patterns', 'cmd_list_imports',
           'cmd_import_details', 'ExampleInfo', 'get_all_test_examples', 'cmd_list_examples', 'cmd_show_example',
           'cmd_validate_code', 'main']

# %% auto 0
__all__ = ['MethodInfo', 'get_all_tailwind_methods', 'get_module_methods', 'cmd_list_methods', 'cmd_module_info', 'cmd_search',
           'cmd_method_details', 'cmd_source', 'VariableInfo', 'get_all_exported_variables', 'cmd_list_variables',
           'cmd_variable_details', 'cmd_variable_source', 'TypeInfo', 'get_all_type_definitions', 'cmd_list_types',
           'cmd_type_details', 'cmd_type_source', 'ImportInfo', 'get_import_patterns', 'cmd_list_imports',
           'cmd_import_details', 'ExampleInfo', 'get_all_test_examples', 'cmd_list_examples', 'cmd_show_example',
           'cmd_validate_code', 'main']

# %% ../nbs/cli.ipynb 6
@dataclass
class MethodInfo:
    """Information about a TailwindBuilder method"""
    name: str
    module: str
    signature: str
    docstring: Optional[str]
    return_type: str
    parameters: List[Dict[str, Any]]

# %% ../nbs/cli.ipynb 7
def get_all_tailwind_methods(
) -> Dict[str, MethodInfo]:  # Dictionary mapping method names to MethodInfo objects
    "Discover all TailwindBuilder methods using introspection."
    methods = {}
    
    # Get all callable attributes from TailwindBuilder class
    for name in dir(TailwindBuilder):
        if name.startswith('_'):
            continue
            
        try:
            attr = getattr(TailwindBuilder, name)
            if not callable(attr):
                continue
        except:
            continue
        
        # Get method signature
        try:
            sig = inspect.signature(attr)
            signature_str = f"{name}{sig}"
        except (ValueError, TypeError):
            signature_str = f"{name}(...)"
        
        # Get docstring
        docstring = inspect.getdoc(attr)
        
        # Get return type from annotations
        try:
            type_hints = get_type_hints(attr)
            return_type = str(type_hints.get('return', 'Any'))
        except (NameError, TypeError):
            return_type = 'Any'
        
        # Get parameter info
        parameters = []
        try:
            for param_name, param in sig.parameters.items():
                if param_name == 'self':
                    continue
                param_info = {
                    'name': param_name,
                    'type': str(param.annotation) if param.annotation != param.empty else 'Any',
                    'default': str(param.default) if param.default != param.empty else None,
                    'required': param.default == param.empty
                }
                parameters.append(param_info)
        except:
            parameters = []
        
        # Determine module by inspecting the method's module
        module = 'core'  # Default
        try:
            if hasattr(attr, '__module__'):
                module_path = attr.__module__
                if 'cjm_tailwind_utils' in module_path:
                    module = module_path.split('.')[-1]
        except:
            pass
        
        methods[name] = MethodInfo(
            name=name,
            module=module,
            signature=signature_str,
            docstring=docstring,
            return_type=return_type,
            parameters=parameters
        )
    
    return methods

# %% ../nbs/cli.ipynb 8
def get_module_methods(
) -> Dict[str, List[str]]:  # Dictionary mapping module names to lists of method names
    "Get methods organized by module using ground truth introspection."
    # Import all modules to ensure patches are registered
    module_names = ['layout', 'style', 'variants', 'modern', 'colors']
    for module_name in module_names:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    # Get all methods and discover their actual modules
    all_methods = get_all_tailwind_methods()
    module_methods = {}
    
    # Inspect each method to find its actual module
    for method_name, method_info in all_methods.items():
        try:
            method = getattr(TailwindBuilder, method_name)
            # Get the module where the method was defined
            if hasattr(method, '__module__'):
                module_path = method.__module__
                if 'cjm_tailwind_utils' in module_path:
                    module = module_path.split('.')[-1]
                else:
                    module = 'core'
            else:
                module = 'core'
        except:
            module = 'core'
        
        if module not in module_methods:
            module_methods[module] = []
        module_methods[module].append(method_name)
    
    return module_methods

# %% ../nbs/cli.ipynb 10
def cmd_list_methods(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """List all available TailwindBuilder methods."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    
    if args.module:
        # Filter by specific module
        module_methods = get_module_methods()
        if args.module not in module_methods:
            print(f"Module '{args.module}' not found. Available modules: {', '.join(module_methods.keys())}")
            return
        
        methods_to_show = {name: info for name, info in all_methods.items() 
                          if name in module_methods[args.module]}
        print(f"Methods in {args.module} module:")
    else:
        methods_to_show = all_methods
        print("All TailwindBuilder methods:")
    
    print()
    
    # Sort methods alphabetically
    for name in sorted(methods_to_show.keys()):
        info = methods_to_show[name]
        
        if args.signatures:
            print(f"**{name}**")
            print(f"  Signature: {info.signature}")
            if info.docstring:
                # Get first line of docstring
                first_line = info.docstring.split('\n')[0].strip()
                print(f"  Description: {first_line}")
            print(f"  Returns: {info.return_type}")
            print()
        else:
            # Compact format
            first_line = ""
            if info.docstring:
                first_line = info.docstring.split('\n')[0].strip()
            print(f"{name:<20} {first_line}")
    
    if not args.signatures and methods_to_show:
        print(f"\nTotal: {len(methods_to_show)} methods")
        print("\n📍 Next steps:")
        print("  • cjm-tailwind-utils method <name>         → Get detailed info for a specific method")
        print("  • cjm-tailwind-utils list-methods --module <name>  → Filter by module")
        print("  • cjm-tailwind-utils search <keyword>      → Search across all methods")
        print("  • cjm-tailwind-utils list-imports          → See how to import and use these methods")

# %% ../nbs/cli.ipynb 11
def cmd_module_info(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show detailed information about a specific module."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    module_methods = get_module_methods()
    
    if args.name not in module_methods:
        print(f"Module '{args.name}' not found.")
        print(f"Available modules: {', '.join(sorted(module_methods.keys()))}")
        return
    
    # Get module docstring if available
    try:
        module = importlib.import_module(f'cjm_tailwind_utils.{args.name}')
        module_doc = module.__doc__ or "No description available"
    except ImportError:
        module_doc = "Core TailwindBuilder functionality"
    
    print(f"Module: {args.name}")
    print(f"Description: {module_doc}")
    print(f"Methods: {len(module_methods[args.name])}")
    print()
    
    # Show import statement
    if args.name == 'core':
        print("Import:")
        print(f"  from cjm_tailwind_utils.core import TailwindBuilder")
        print()
        print("Usage:")
        print("  tb = TailwindBuilder()")
        print("  result = tb.util('flex').build()  # Core methods available")
    else:
        print("Import:")
        print(f"  from cjm_tailwind_utils.{args.name} import *")
        print("  # This adds methods to the TailwindBuilder class via patches")
        print()
        print("Usage:")
        print("  from cjm_tailwind_utils.core import TailwindBuilder")
        print(f"  from cjm_tailwind_utils.{args.name} import *")
        print()
        print("  tb = TailwindBuilder()")
        print("  # Now you can use the added methods")
    print()
    
    # Show methods in this module
    all_methods = get_all_tailwind_methods()
    method_names = sorted(module_methods[args.name])
    
    print("Methods:")
    for method_name in method_names:
        if method_name in all_methods:
            info = all_methods[method_name]
            first_line = ""
            if info.docstring:
                first_line = info.docstring.split('\n')[0].strip()
            print(f"  {method_name:<20} {first_line}")
    
    print(f"\nUse 'cjm-tailwind-utils list-methods --module {args.name} --signatures' for detailed method information")

# %% ../nbs/cli.ipynb 12
def cmd_search(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Search for methods by keyword."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    keyword = args.keyword.lower()
    
    matches = []
    
    for name, info in all_methods.items():
        # Search in method name
        if keyword in name.lower():
            matches.append((name, info, "name"))
            continue
        
        # Search in docstring
        if info.docstring and keyword in info.docstring.lower():
            matches.append((name, info, "description"))
            continue
        
        # Search in parameter names/types
        for param in info.parameters:
            if keyword in param['name'].lower() or keyword in param['type'].lower():
                matches.append((name, info, "parameter"))
                break
    
    if not matches:
        print(f"❌ No methods found matching '{args.keyword}'")
        print("\n💡 Try:")
        print(f"  • A shorter keyword (e.g., 'flex' instead of 'flexbox')")
        print(f"  • cjm-tailwind-utils list-methods       → Browse all methods")
        print(f"  • cjm-tailwind-utils module <name>      → Explore specific modules")
        return
    
    print(f"🔍 Found {len(matches)} matches for '{args.keyword}':")
    print()
    
    # Group by match type
    for match_type in ["name", "description", "parameter"]:
        type_matches = [(name, info) for name, info, mtype in matches if mtype == match_type]
        if not type_matches:
            continue
        
        if match_type == "name":
            print("✓ Method names:")
        elif match_type == "description":
            print("✓ Descriptions:")
        else:
            print("✓ Parameters:")
        
        for name, info in sorted(type_matches):
            first_line = ""
            if info.docstring:
                first_line = info.docstring.split('\n')[0].strip()
            print(f"  {name:<20} {first_line}")
        print()
    
    print("📍 Next steps:")
    print(f"  • cjm-tailwind-utils method <name>      → Get details for any method above")
    print(f"  • cjm-tailwind-utils list-imports       → See how to import these methods")

# %% ../nbs/cli.ipynb 13
def cmd_method_details(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show detailed signature and parameter information for a specific method."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    
    if args.method not in all_methods:
        print(f"❌ Method '{args.method}' not found.")
        # Show all similar methods
        similar = [name for name in all_methods.keys() if args.method.lower() in name.lower()]
        if similar:
            print(f"\n💡 Did you mean one of these?")
            for method in similar:
                print(f"  • {method}")
            print(f"\nTry: cjm-tailwind-utils method {similar[0]}")
        else:
            print("\n💡 Try:")
            print("  • cjm-tailwind-utils list-methods       → Browse all methods")
            print(f"  • cjm-tailwind-utils search {args.method}    → Search for similar names")
        return
    
    info = all_methods[args.method]
    print(f"📋 Method: {args.method}")
    if info.docstring:
        print(f"📝 {info.docstring}")
    print(f"\n🔧 Signature: {info.signature}")
    print(f"↩️  Returns: {info.return_type}")
    print()
    
    # Show detailed parameter breakdown  
    if info.parameters:
        print("📌 Parameters:")
        for param in info.parameters:
            required_str = "REQUIRED" if param['required'] else f"optional (default: {param['default']})"
            print(f"  • {param['name']}: {param['type']}")
            print(f"    └─ {required_str}")
            print()
    else:
        print("📌 No parameters (besides self)")
        print()
    
    # Show module info
    module_methods = get_module_methods()
    found_module = 'core'  # default
    for module, methods in module_methods.items():
        if args.method in methods:
            found_module = module
            print(f"📦 Module: {module}")
            if module == 'core':
                print(f"   Import: from cjm_tailwind_utils.core import TailwindBuilder")
            else:
                print(f"   Import: from cjm_tailwind_utils.core import TailwindBuilder")
                print(f"           from cjm_tailwind_utils.{module} import *")
            break
    
    print("\n📍 Next steps:")
    print(f"  • cjm-tailwind-utils method-source {args.method}  → View implementation")
    print(f"  • cjm-tailwind-utils examples {found_module}      → See real usage examples")
    print(f"  • cjm-tailwind-utils list-imports        → See import patterns")

# %% ../nbs/cli.ipynb 14
def cmd_source(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show the full source code for a specific method."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    
    if args.method not in all_methods:
        print(f"Method '{args.method}' not found.")
        # Show all similar methods
        similar = [name for name in all_methods.keys() if args.method.lower() in name.lower()]
        if similar:
            print(f"Similar methods: {', '.join(similar)}")
        return
    
    try:
        method = getattr(TailwindBuilder, args.method)
        source_code = inspect.getsource(method)
        
        print(f"Source code for method '{args.method}':")
        print("=" * 50)
        print(source_code)
        print("=" * 50)
        
    except OSError:
        print(f"Source code not available for method '{args.method}'.")
        print("This might be a built-in method or the source file is not accessible.")
        
        # Still show the signature as fallback
        info = all_methods[args.method]
        print(f"\nSignature: {info.signature}")
        if info.docstring:
            print(f"Docstring: {info.docstring}")
    
    except Exception as e:
        print(f"Error retrieving source code: {e}")
        
        # Show method info as fallback
        info = all_methods[args.method]
        print(f"\nSignature: {info.signature}")
        if info.docstring:
            print(f"Docstring: {info.docstring}")

# %% ../nbs/cli.ipynb 15
@dataclass
class VariableInfo:
    """Information about an exported variable/constant"""
    name: str
    module: str
    type_name: str
    value: Any
    value_preview: str
    docstring: Optional[str]

# %% ../nbs/cli.ipynb 16
def get_all_exported_variables(
) -> Dict[str, VariableInfo]:  # Dictionary mapping variable names to VariableInfo objects
    "Discover all exported variables/constants using introspection."
    variables = {}
    
    # Import all modules and inspect their exports
    module_names = ['core', 'colors', 'types', 'validation']
    
    for module_name in module_names:
        try:
            module = importlib.import_module(f'cjm_tailwind_utils.{module_name}')
            
            # Get all public attributes (not starting with _)
            for name in dir(module):
                if name.startswith('_'):
                    continue
                    
                try:
                    attr = getattr(module, name)
                    
                    # Skip functions, classes, and modules
                    if (callable(attr) or 
                        inspect.isclass(attr) or 
                        inspect.ismodule(attr)):
                        continue
                    
                    # Get type information
                    type_name = type(attr).__name__
                    
                    # Create a preview of the value - NO TRUNCATION, just show full value
                    if isinstance(attr, (dict, list, tuple, set)):
                        value_preview = f"{type_name} with {len(attr)} items"
                    else:
                        value_preview = str(attr)
                    
                    # Try to get docstring if it's documented
                    docstring = None
                    if hasattr(attr, '__doc__'):
                        docstring = attr.__doc__
                    
                    variables[name] = VariableInfo(
                        name=name,
                        module=module_name,
                        type_name=type_name,
                        value=attr,
                        value_preview=value_preview,
                        docstring=docstring
                    )
                    
                except Exception:
                    # Skip attributes that can't be accessed
                    continue
                    
        except ImportError:
            continue
    
    return variables

# %% ../nbs/cli.ipynb 17
def cmd_list_variables(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """List all exported variables/constants."""
    all_variables = get_all_exported_variables()
    
    if args.module:
        # Filter by specific module
        variables_to_show = {name: info for name, info in all_variables.items() 
                           if info.module == args.module}
        if not variables_to_show:
            available_modules = sorted(set(info.module for info in all_variables.values()))
            print(f"No variables found in module '{args.module}'.")
            print(f"Available modules: {', '.join(available_modules)}")
            return
        print(f"Variables/constants in {args.module} module:")
    else:
        variables_to_show = all_variables
        print("All exported variables/constants:")
    
    print()
    
    # Group by module for better organization
    by_module = {}
    for name, info in variables_to_show.items():
        if info.module not in by_module:
            by_module[info.module] = []
        by_module[info.module].append((name, info))
    
    for module in sorted(by_module.keys()):
        if not args.module:  # Only show module headers when showing all
            print(f"--- {module} ---")
        
        for name, info in sorted(by_module[module]):
            if args.values:
                print(f"{name:<25} {info.type_name:<15} {info.value_preview}")
            else:
                print(f"{name:<25} {info.type_name}")
        
        if not args.module:
            print()
    
    if not args.values and variables_to_show:
        print(f"Total: {len(variables_to_show)} variables/constants")
        print("Use --values to see variable values")
        print("Use 'cjm-tailwind-utils variable <name>' for detailed info")

# %% ../nbs/cli.ipynb 18
def cmd_variable_details(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show detailed information about a specific variable/constant."""
    all_variables = get_all_exported_variables()
    
    if args.name not in all_variables:
        print(f"Variable '{args.name}' not found.")
        # Show similar variables
        similar = [name for name in all_variables.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar variables: {', '.join(similar)}")
        return
    
    info = all_variables[args.name]
    print(f"Variable: {args.name}")
    print(f"Module: {info.module}")
    print(f"Type: {info.type_name}")
    if info.docstring:
        print(f"Description: {info.docstring}")
    print()
    
    # Show import statement
    print("Import:")
    print(f"  from cjm_tailwind_utils.{info.module} import {args.name}")
    print()
    
    # Show value details - NO TRUNCATION
    print("Value:")
    if isinstance(info.value, dict):
        print(f"  Dictionary with {len(info.value)} items:")
        for key, value in info.value.items():
            print(f"    {key}: {value}")
            
    elif isinstance(info.value, (list, tuple)):
        print(f"  {info.type_name} with {len(info.value)} items:")
        for i, item in enumerate(info.value):
            print(f"    [{i}]: {item}")
            
    elif isinstance(info.value, set):
        print(f"  Set with {len(info.value)} items:")
        for item in sorted(info.value):
            print(f"    {item}")
            
    else:
        print(f"  {info.value}")
    
    print()
    print(f"Use 'cjm-tailwind-utils variable-source {args.name}' to see how this variable is defined")

# %% ../nbs/cli.ipynb 19
def cmd_variable_source(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show the source definition of a specific variable/constant."""
    all_variables = get_all_exported_variables()
    
    if args.name not in all_variables:
        print(f"Variable '{args.name}' not found.")
        similar = [name for name in all_variables.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar variables: {', '.join(similar)}")
        return
    
    info = all_variables[args.name]
    
    try:
        # Import the module and try to get source
        module = importlib.import_module(f'cjm_tailwind_utils.{info.module}')
        
        # Try to get source from module file
        module_file = inspect.getfile(module)
        with open(module_file, 'r') as f:
            source_lines = f.readlines()
        
        # Look for the variable definition
        found_definition = False
        definition_lines = []
        in_definition = False
        
        for i, line in enumerate(source_lines):
            # Look for variable assignment
            if f"{args.name} = " in line or f"{args.name}: " in line:
                found_definition = True
                in_definition = True
                definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                
            elif in_definition:
                # Continue if line is part of multi-line definition
                if (line.startswith(' ') or line.startswith('\t') or 
                    line.strip().startswith('"') or line.strip().startswith("'") or
                    line.strip() in ['}', ']', ')']):
                    definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                else:
                    # End of definition
                    break
        
        if found_definition:
            print(f"Source definition for '{args.name}':")
            print("=" * 50)
            for line in definition_lines:
                print(line)
            print("=" * 50)
        else:
            print(f"Could not find source definition for '{args.name}' in {module_file}")
            print(f"Value: {info.value_preview}")
            
    except Exception as e:
        print(f"Error retrieving source: {e}")
        print(f"Variable: {args.name}")
        print(f"Type: {info.type_name}")
        print(f"Value: {info.value_preview}")

# %% ../nbs/cli.ipynb 20
@dataclass
class TypeInfo:
    """Information about a type definition"""
    name: str
    module: str
    type_kind: str  # 'TypeAlias', 'Union', 'Literal', etc.
    definition: str
    docstring: Optional[str]
    actual_type: Any

# %% ../nbs/cli.ipynb 21
def get_all_type_definitions(
) -> Dict[str, TypeInfo]:  # Dictionary mapping type names to TypeInfo objects
    "Discover all type definitions using introspection."
    types_info = {}
    
    # Import types module to get type definitions
    try:
        types_module = importlib.import_module('cjm_tailwind_utils.types')
        
        # Get all public attributes from types module
        for name in dir(types_module):
            if name.startswith('_'):
                continue
                
            try:
                attr = getattr(types_module, name)
                
                # Skip imported basic types and constructs
                if (inspect.ismodule(attr) or 
                    inspect.isfunction(attr) or 
                    (inspect.isclass(attr) and not attr.__module__.startswith('cjm_tailwind_utils'))):
                    continue
                
                # Determine type kind and definition
                type_kind = 'Unknown'
                definition = str(attr)
                
                # Check for typing constructs
                type_name = type(attr).__name__
                
                if 'Union' in type_name:
                    type_kind = 'Union'
                    if hasattr(attr, '__args__'):
                        args = [str(arg) for arg in attr.__args__]
                        definition = f"Union[{', '.join(args)}]"
                elif 'Literal' in type_name:
                    type_kind = 'Literal'
                    if hasattr(attr, '__args__'):
                        values = [repr(arg) for arg in attr.__args__]
                        # NO TRUNCATION - show all values
                        definition = f"Literal[{', '.join(values)}]"
                elif hasattr(attr, '_name'):  # Type aliases
                    type_kind = 'TypeAlias'
                    definition = str(attr)
                elif inspect.isclass(attr):
                    type_kind = 'Class'
                    definition = f"class {name}"
                elif name in ['Union', 'Literal']:  # Skip these basic constructs
                    continue
                else:
                    # This is likely a type alias
                    type_kind = 'TypeAlias'
                
                # Try to get docstring
                docstring = None
                if hasattr(attr, '__doc__'):
                    docstring = attr.__doc__
                
                types_info[name] = TypeInfo(
                    name=name,
                    module='types',
                    type_kind=type_kind,
                    definition=definition,
                    docstring=docstring,
                    actual_type=attr
                )
                
            except Exception:
                # Skip attributes that can't be accessed
                continue
                
    except ImportError:
        pass
    
    # Also check other modules for type definitions and classes
    for module_name in ['colors', 'validation']:
        try:
            module = importlib.import_module(f'cjm_tailwind_utils.{module_name}')
            
            for name in dir(module):
                if (name.startswith('_') or 
                    name in types_info):  # Already found
                    continue
                    
                try:
                    attr = getattr(module, name)
                    
                    # Look for classes and type-like constructs
                    if inspect.isclass(attr) and attr.__module__.startswith('cjm_tailwind_utils'):
                        type_kind = 'Class'
                        definition = f"class {name}"
                        docstring = getattr(attr, '__doc__', None)
                        
                        types_info[name] = TypeInfo(
                            name=name,
                            module=module_name,
                            type_kind=type_kind,
                            definition=definition,
                            docstring=docstring,
                            actual_type=attr
                        )
                        
                except Exception:
                    continue
                    
        except ImportError:
            continue
    
    return types_info

# %% ../nbs/cli.ipynb 22
def cmd_list_types(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """List all type definitions."""
    all_types = get_all_type_definitions()
    
    if args.module:
        # Filter by specific module
        types_to_show = {name: info for name, info in all_types.items() 
                        if info.module == args.module}
        if not types_to_show:
            available_modules = sorted(set(info.module for info in all_types.values()))
            print(f"No types found in module '{args.module}'.")
            print(f"Available modules: {', '.join(available_modules)}")
            return
        print(f"Type definitions in {args.module} module:")
    else:
        types_to_show = all_types
        print("All type definitions:")
    
    print()
    
    # Group by module for better organization
    by_module = {}
    for name, info in types_to_show.items():
        if info.module not in by_module:
            by_module[info.module] = []
        by_module[info.module].append((name, info))
    
    for module in sorted(by_module.keys()):
        if not args.module:  # Only show module headers when showing all
            print(f"--- {module} ---")
        
        for name, info in sorted(by_module[module]):
            if args.definitions:
                print(f"{name:<25} {info.type_kind:<15} {info.definition}")
            else:
                print(f"{name:<25} {info.type_kind}")
        
        if not args.module:
            print()
    
    if not args.definitions and types_to_show:
        print(f"Total: {len(types_to_show)} type definitions")
        print("Use --definitions to see type definitions")
        print("Use 'cjm-tailwind-utils type <name>' for detailed info")

# %% ../nbs/cli.ipynb 23
def cmd_type_details(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show detailed information about a specific type definition."""
    all_types = get_all_type_definitions()
    
    if args.name not in all_types:
        print(f"Type '{args.name}' not found.")
        # Show similar types
        similar = [name for name in all_types.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar types: {', '.join(similar)}")
        return
    
    info = all_types[args.name]
    print(f"Type: {args.name}")
    print(f"Module: {info.module}")
    print(f"Kind: {info.type_kind}")
    if info.docstring:
        print(f"Description: {info.docstring}")
    print()
    
    # Show import statement
    print("Import:")
    print(f"  from cjm_tailwind_utils.{info.module} import {args.name}")
    print()
    
    # Show type definition
    print("Definition:")
    print(f"  {info.definition}")
    print()
    
    # Show expanded information for different type kinds - NO TRUNCATION
    if info.type_kind == 'Literal':
        try:
            if hasattr(info.actual_type, '__args__'):
                values = list(info.actual_type.__args__)
                print(f"Allowed values ({len(values)} total):")
                for value in values:
                    print(f"  {repr(value)}")
        except:
            pass
    
    elif info.type_kind == 'Union':
        try:
            if hasattr(info.actual_type, '__args__'):
                types = list(info.actual_type.__args__)
                print(f"Union of {len(types)} types:")
                for i, union_type in enumerate(types, 1):
                    print(f"  {i}. {union_type}")
        except:
            pass
    
    elif info.type_kind == 'TypeAlias':
        print("This is a type alias. The actual type definition may be complex.")
    
    print()
    print(f"Use 'cjm-tailwind-utils type-source {args.name}' to see how this type is defined")

# %% ../nbs/cli.ipynb 24
def cmd_type_source(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show the source definition of a specific type."""
    all_types = get_all_type_definitions()
    
    if args.name not in all_types:
        print(f"Type '{args.name}' not found.")
        similar = [name for name in all_types.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar types: {', '.join(similar)}")
        return
    
    info = all_types[args.name]
    
    try:
        # Import the module and try to get source
        module = importlib.import_module(f'cjm_tailwind_utils.{info.module}')
        
        # Try to get source from module file
        module_file = inspect.getfile(module)
        with open(module_file, 'r') as f:
            source_lines = f.readlines()
        
        # Look for the type definition
        found_definition = False
        definition_lines = []
        in_definition = False
        
        for i, line in enumerate(source_lines):
            # Look for type definition patterns
            if (f"{args.name} = " in line or 
                f"{args.name}: " in line or
                f"class {args.name}" in line):
                found_definition = True
                in_definition = True
                definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                
            elif in_definition:
                # Continue if line is part of multi-line definition
                if (line.startswith(' ') or line.startswith('\t') or 
                    line.strip().startswith('"') or line.strip().startswith("'") or
                    line.strip() in ['}', ']', ')', '|'] or
                    '|' in line or 'Union[' in line or 'Literal[' in line):
                    definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                else:
                    # End of definition
                    break
        
        if found_definition:
            print(f"Source definition for type '{args.name}':")
            print("=" * 50)
            for line in definition_lines:
                print(line)
            print("=" * 50)
        else:
            print(f"Could not find source definition for type '{args.name}' in {module_file}")
            print(f"Definition: {info.definition}")
            
    except Exception as e:
        print(f"Error retrieving source: {e}")
        print(f"Type: {args.name}")
        print(f"Kind: {info.type_kind}")
        print(f"Definition: {info.definition}")

# %% ../nbs/cli.ipynb 25
@dataclass
class ImportInfo:
    """Information about import patterns and recommendations"""
    import_statement: str
    description: str
    use_case: str
    items: List[str]
    dependencies: List[str]

# %% ../nbs/cli.ipynb 26
def get_import_patterns(
) -> Dict[str, ImportInfo]:  # Dictionary mapping pattern names to ImportInfo objects
    "Discover optimal import patterns using ground truth analysis."
    patterns = {}
    
    # Analyze what each module actually provides
    all_methods = get_all_tailwind_methods()
    all_variables = get_all_exported_variables()
    all_types = get_all_type_definitions()
    module_methods = get_module_methods()
    
    # Core import pattern - TailwindBuilder class
    patterns['core'] = ImportInfo(
        import_statement="from cjm_tailwind_utils.core import TailwindBuilder",
        description="Import the TailwindBuilder class for creating instances",
        use_case="Basic usage - create TailwindBuilder instances with tb = TailwindBuilder()",
        items=['TailwindBuilder class'],
        dependencies=[]
    )
    
    # All module pattern - convenience import with all methods
    try:
        importlib.import_module('cjm_tailwind_utils.all')
        patterns['all'] = ImportInfo(
            import_statement="from cjm_tailwind_utils.all import TailwindBuilder",
            description="Import TailwindBuilder with all methods pre-loaded",
            use_case="Recommended: Single import that includes all functionality (layout, style, variants, modern)",
            items=["TailwindBuilder class with all methods"],
            dependencies=[]
        )
    except ImportError:
        pass
    
    # Module-specific import patterns - only for modules that actually exist and have methods
    for module_name, methods in module_methods.items():
        if module_name != 'core' and methods:
            patterns[f'{module_name}_methods'] = ImportInfo(
                import_statement=f"from cjm_tailwind_utils.{module_name} import *",
                description=f"Adds {len(methods)} methods to TailwindBuilder",
                use_case=f"Import to enable {', '.join(methods[:3])}{'...' if len(methods) > 3 else ''} methods on TailwindBuilder instances",
                items=[f"{method}() method" for method in sorted(methods)],
                dependencies=['core']
            )
    
    # Types import pattern - only for types that actually exist
    type_items = [name for name, info in all_types.items() if info.module == 'types']
    if type_items:
        # Create intelligent import statement based on what actually exists
        important_types = [t for t in ['SpacingValue', 'ColorValue', 'SizeValue'] if t in type_items]
        import_list = ', '.join(important_types[:3]) if important_types else ', '.join(type_items[:3])
        
        patterns['types'] = ImportInfo(
            import_statement=f"from cjm_tailwind_utils.types import {import_list}",
            description="Type definitions for better IDE support and type checking",
            use_case="Import when you need type hints for function parameters",
            items=[f"{name} (type definition)" for name in sorted(type_items)],
            dependencies=[]
        )
    
    # Colors import pattern - only for color constants that actually exist
    color_variables = [name for name, info in all_variables.items() if info.module == 'colors']
    if color_variables:
        # Create import statement based on what actually exists
        important_colors = [c for c in ['TAILWIND_COLORS', 'SPECIAL_COLORS'] if c in color_variables]
        import_list = ', '.join(important_colors) if important_colors else ', '.join(color_variables[:2])
        
        patterns['colors'] = ImportInfo(
            import_statement=f"from cjm_tailwind_utils.colors import {import_list}",
            description="Color constants and validation utilities",
            use_case="Import when you need to work with color data directly",
            items=[f"{name} (constant)" for name in sorted(color_variables)],
            dependencies=[]
        )
    
    # Validation import pattern - only for validation items that actually exist
    validation_variables = [name for name, info in all_variables.items() if info.module == 'validation']
    validation_types = [name for name, info in all_types.items() if info.module == 'validation']
    validation_items = validation_variables + validation_types
    
    if validation_items:
        # Create import statement based on what actually exists
        funcs = [item for item in validation_items if item.startswith('validate_')]
        errors = [item for item in validation_items if item.endswith('Error')]
        import_candidates = (funcs[:1] + errors[:1])[:2]  # Take at most 2 items
        import_list = ', '.join(import_candidates) if import_candidates else validation_items[0]
        
        patterns['validation'] = ImportInfo(
            import_statement=f"from cjm_tailwind_utils.validation import {import_list}",
            description="Validation functions and error classes",
            use_case="Import when building custom utilities or handling validation",
            items=[f"{name} ({'function' if name.startswith('validate_') else 'class/constant'})" for name in sorted(validation_items)],
            dependencies=[]
        )
    
    return patterns

# %% ../nbs/cli.ipynb 27
def cmd_list_imports(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """List all recommended import patterns."""
    import_patterns = get_import_patterns()
    
    if args.use_case:
        # Filter by use case
        use_case_lower = args.use_case.lower()
        filtered_patterns = {
            name: info for name, info in import_patterns.items()
            if use_case_lower in info.use_case.lower() or use_case_lower in info.description.lower()
        }
        if not filtered_patterns:
            print(f"No import patterns found for use case '{args.use_case}'")
            print(f"Available patterns: {', '.join(import_patterns.keys())}")
            return
        patterns_to_show = filtered_patterns
        print(f"Import patterns for use case '{args.use_case}':")
    else:
        patterns_to_show = import_patterns
        print("📦 Recommended import patterns:")
        print("\n💡 Quick start: Use the 'all' pattern for everything in one import!")
    
    print()
    
    # Show the 'all' pattern first if present
    if 'all' in patterns_to_show and not args.detailed:
        info = patterns_to_show['all']
        print("⭐ RECOMMENDED:")
        print(f"  all                  {info.description}")
        print()
        print("OTHER PATTERNS:")
    
    for name, info in sorted(patterns_to_show.items()):
        if name == 'all' and not args.detailed:
            continue  # Already shown above
            
        if args.detailed:
            print(f"**{name}**")
            print(f"  Import: {info.import_statement}")
            print(f"  Description: {info.description}")
            print(f"  Use case: {info.use_case}")
            if info.dependencies:
                print(f"  Dependencies: {', '.join(info.dependencies)}")
            print(f"  Provides: {len(info.items)} items")
            print()
        else:
            print(f"  {name:<20} {info.description}")
    
    if not args.detailed and patterns_to_show:
        print(f"\n📍 Next steps:")
        print("  • cjm-tailwind-utils import all            → See the recommended import (includes everything)")
        print("  • cjm-tailwind-utils import <pattern>      → Get details for any import pattern")
        print("  • cjm-tailwind-utils examples all          → See ALL test functions from every module")
        print("  • cjm-tailwind-utils list-methods          → Browse all available methods")

# %% ../nbs/cli.ipynb 28
def cmd_import_details(
    args    # Parsed command line arguments from argparse - TODO: Add type hint
): # None
    """Show detailed information about a specific import pattern."""
    import_patterns = get_import_patterns()
    
    if args.pattern not in import_patterns:
        print(f"❌ Import pattern '{args.pattern}' not found.")
        # Show similar patterns
        similar = [name for name in import_patterns.keys() if args.pattern.lower() in name.lower()]
        if similar:
            print(f"\n💡 Did you mean: {', '.join(similar)}")
        print(f"\nAvailable patterns: {', '.join(sorted(import_patterns.keys()))}")
        print("\nTry: cjm-tailwind-utils list-imports")
        return
    
    info = import_patterns[args.pattern]
    
    # Special emphasis for the 'all' pattern
    if args.pattern == 'all':
        print("⭐ RECOMMENDED IMPORT PATTERN ⭐")
    
    print(f"\n📦 Pattern: {args.pattern}")
    print(f"📝 {info.description}")
    print()
    
    print("💻 Import Statement:")
    print(f"   {info.import_statement}")
    print()
    
    print("🎯 Use Case:")
    print(f"   {info.use_case}")
    print()
    
    if info.dependencies:
        print("🔗 Dependencies:")
        for dep in info.dependencies:
            dep_info = import_patterns.get(dep)
            if dep_info:
                print(f"   • {dep}: {dep_info.import_statement}")
            else:
                print(f"   • {dep}")
        print()
    
    print(f"📋 Provides ({len(info.items)} items):")
    # Show all items
    for item in info.items:
        print(f"   • {item}")
    
    # Show method breakdown if this provides methods
    if args.pattern.endswith('_methods'):
        module_name = args.pattern.replace('_methods', '')
        module_methods = get_module_methods()
        if module_name in module_methods:
            methods = module_methods[module_name]
            print()
            print(f"🔧 Methods added to TailwindBuilder:")
            for method in sorted(methods):
                print(f"   • tb.{method}()")
    
    # Determine which module's examples to reference
    example_module = 'all'  # default
    if args.pattern == 'core':
        example_module = 'core'
    elif args.pattern.endswith('_methods'):
        example_module = args.pattern.replace('_methods', '')
    elif args.pattern in ['types', 'colors', 'validation']:
        example_module = args.pattern
    
    print("\n📍 Next steps:")
    print(f"   • cjm-tailwind-utils examples {example_module}  → See real usage examples")
    if args.pattern == 'all':
        print("   • cjm-tailwind-utils list-methods       → Browse all available methods")
        print("   • cjm-tailwind-utils list-examples      → See all example modules")
    else:
        print("   • cjm-tailwind-utils list-imports       → See other import patterns")
        if args.pattern.endswith('_methods'):
            module_name = args.pattern.replace('_methods', '')
            print(f"   • cjm-tailwind-utils module {module_name}        → Explore the module")
        print("   • cjm-tailwind-utils examples all       → See ALL test functions from every module")

# %% ../nbs/cli.ipynb 29
@dataclass
class ExampleInfo:
    "Information about a test example function"
    
    name: str
    module: str
    function_name: str
    docstring: Optional[str]
    source: str

# %% ../nbs/cli.ipynb 30
def get_all_test_examples(
) -> Dict[str, ExampleInfo]:  # Dictionary mapping module names to ExampleInfo objects
    "Discover all test example functions following the test_<module>_usage_examples naming convention."
    examples = {}
    
    # Define the modules we know have test functions
    modules_with_tests = ['core', 'colors', 'validation', 'layout', 'variants', 'style', 'modern', 'all']
    
    for module_name in modules_with_tests:
        try:
            # Import the module
            module = importlib.import_module(f'cjm_tailwind_utils.{module_name}')
            
            # Look for the standardized test function name
            test_func_name = f'test_{module_name}_usage_examples'
            
            if hasattr(module, test_func_name):
                test_func = getattr(module, test_func_name)
                
                # Get the source code
                try:
                    source = inspect.getsource(test_func)
                except:
                    source = "Source code not available"
                
                examples[module_name] = ExampleInfo(
                    name=module_name,
                    module=module_name,
                    function_name=test_func_name,
                    docstring=inspect.getdoc(test_func),
                    source=source
                )
        except ImportError:
            continue
    
    return examples

# %% ../nbs/cli.ipynb 31
def cmd_list_examples(
    args    # Parsed command line arguments from argparse
): # None
    "List all available test example functions."
    examples = get_all_test_examples()
    
    if not examples:
        print("No test examples found.")
        return
    
    print(f"Found {len(examples)} test example modules:\n")
    
    for module_name, info in sorted(examples.items()):
        if module_name == 'all':
            print(f"  {module_name:<15} - Shows ALL individual test functions (recommended!)")
            print(f"  {'':15}   View source code from all modules in one place")
        else:
            print(f"  {module_name:<15} - {info.function_name}")
            if info.docstring:
                # Get first line of docstring
                first_line = info.docstring.split('\n')[0].strip()
                if first_line:
                    print(f"  {'':15}   {first_line}")
        print()
    
    print("\nUse 'cjm-tailwind-utils examples <module>' to see the full example code.")
    print("💡 TIP: Use 'cjm-tailwind-utils examples all' to see ALL test functions at once!")

# %% ../nbs/cli.ipynb 32
def cmd_show_example(
    args    # Parsed command line arguments from argparse
): # None
    "Show the source code of a specific test example function."
    examples = get_all_test_examples()
    
    # Special handling for 'all' - show all individual test functions
    if args.module == 'all':
        print("📚 ALL TEST EXAMPLES")
        print("=" * 80)
        print("\nShowing all individual module test functions (more useful than test_all_usage_examples):\n")
        
        # Show all test functions except 'all' itself
        modules_to_show = [m for m in sorted(examples.keys()) if m != 'all']
        
        for i, module in enumerate(modules_to_show):
            if i > 0:
                print("\n" + "=" * 80 + "\n")
            
            info = examples[module]
            print(f"📦 Module: {info.module}")
            print(f"🔧 Function: {info.function_name}")
            print("-" * 80)
            
            if info.docstring:
                print("Docstring:")
                print(info.docstring)
                print("-" * 80)
            
            print("Source Code:")
            print(info.source)
        
        print("\n" + "=" * 80)
        print("\n💡 To run a specific example:")
        print("  from cjm_tailwind_utils.<module> import test_<module>_usage_examples")
        print("  test_<module>_usage_examples()")
        return
    
    if args.module not in examples:
        print(f"No test examples found for module '{args.module}'.")
        print(f"Available modules: {', '.join(sorted(examples.keys()))}")
        return
    
    info = examples[args.module]
    
    print(f"Module: {info.module}")
    print(f"Function: {info.function_name}")
    print("=" * 80)
    
    if info.docstring:
        print("\nDocstring:")
        print("-" * 40)
        print(info.docstring)
        print("-" * 40)
    
    print("\nSource Code:")
    print("-" * 80)
    print(info.source)
    print("-" * 80)
    
    print(f"\nTo run this example, use:")
    print(f"  from cjm_tailwind_utils.{info.module} import {info.function_name}")
    print(f"  {info.function_name}()")

# %% ../nbs/cli.ipynb 34
def cmd_validate_code(
    args    # Parsed command line arguments from argparse
): # None
    """Validate Python code that uses cjm-tailwind-utils."""
    import tempfile
    import subprocess
    import os
    import sys
    import re
    
    # Read code from stdin or file
    if args.file:
        try:
            with open(args.file, 'r') as f:
                code = f.read()
        except FileNotFoundError:
            print(f"❌ Error: File '{args.file}' not found.")
            return
        except Exception as e:
            print(f"❌ Error reading file: {e}")
            return
    else:
        # Read from stdin
        if sys.stdin.isatty():
            print("💡 Enter Python code to validate (press Ctrl+D when done):")
            print("   For examples, run: cjm-tailwind-utils examples all")
            print()
        code = sys.stdin.read()
    
    if not code.strip():
        print("❌ Error: No code provided.")
        print("\n💡 Try these commands for examples:")
        print("  • cjm-tailwind-utils examples all       → See all example code")
        print("  • cjm-tailwind-utils list-methods       → Browse available methods")
        print("  • cjm-tailwind-utils list-imports       → See import patterns")
        return
    
    # Determine import mode
    if args.import_mode == 'all':
        import_statement = "from cjm_tailwind_utils.all import TailwindBuilder"
    elif args.import_mode == 'manual':
        # User provides their own imports
        import_statement = ""
    else:  # auto mode
        # Dynamically build method-to-module mapping
        # First, ensure all modules are loaded
        for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
            try:
                importlib.import_module(f'cjm_tailwind_utils.{module_name}')
            except ImportError:
                continue
        
        # Get all methods and their modules
        all_methods = get_all_tailwind_methods()
        module_methods = get_module_methods()
        
        # Create method to module mapping
        method_to_module = {}
        for module, methods in module_methods.items():
            for method in methods:
                method_to_module[method] = module
        
        # Analyze code to determine needed imports
        modules_needed = set()
        
        # Check for method calls - look for tb.method( or .method( patterns
        for method_name, module in method_to_module.items():
            # Check for various patterns where the method might be called
            patterns = [
                f'.{method_name}(',  # Most common: tb.method(
                f' {method_name}(',  # Less common: result = method(
                f'\\n{method_name}(', # Start of line
            ]
            for pattern in patterns:
                if pattern in code:
                    if module != 'core':  # Core methods are always available
                        modules_needed.add(module)
                    break
        
        # Build import statements
        import_lines = ["from cjm_tailwind_utils.core import TailwindBuilder"]
        for module in sorted(modules_needed):
            import_lines.append(f"from cjm_tailwind_utils.{module} import *")
        import_statement = '\n'.join(import_lines)
    
    # Create validation code
    validation_code = f"""
{import_statement}

# User code starts here
{code}

# Validation successful
print("\\n✅ Code validation successful!")
"""
    
    # Write to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(validation_code)
        temp_file = f.name
    
    try:
        # Execute the code
        result = subprocess.run(
            [sys.executable, temp_file],
            capture_output=True,
            text=True,
            timeout=args.timeout
        )
        
        if result.returncode == 0:
            # Success
            if args.verbose or args.show_output:
                print("📝 Output:")
                print("-" * 50)
                print(result.stdout)
                print("-" * 50)
            else:
                # Only show the success message
                if "✅ Code validation successful!" in result.stdout:
                    print("✅ Code validation successful!")
                else:
                    print("✅ Code executed successfully!")
                    if result.stdout.strip():
                        print("\n💡 Use --show-output to see the output")
        else:
            # Error
            print("❌ Code validation failed!")
            print("\n🔍 Error details:")
            print("-" * 50)
            if result.stderr:
                # Try to clean up the error message
                error_lines = result.stderr.split('\n')
                cleaned_lines = []
                for line in error_lines:
                    # Remove temp file references
                    if temp_file in line:
                        line = line.replace(temp_file, '<your-code>')
                    # Adjust line numbers
                    if 'line' in line and '<your-code>' in line:
                        # Try to adjust line number
                        match = re.search(r'line (\d+)', line)
                        if match:
                            line_no = int(match.group(1))
                            # Subtract the import lines
                            adjusted_line = line_no - len(import_statement.split('\n')) - 2
                            if adjusted_line > 0:
                                line = line.replace(f'line {line_no}', f'line {adjusted_line}')
                    cleaned_lines.append(line)
                print('\n'.join(cleaned_lines))
            print("-" * 50)
            
            # Show suggestions based on the error
            print("\n💡 Common issues:")
            if "NameError" in result.stderr and "TailwindBuilder" in result.stderr:
                print("  • Missing import. Try: --import-mode all")
                print("  • Or see: cjm-tailwind-utils list-imports")
            elif "AttributeError" in result.stderr:
                # Try to extract the method name from error
                match = re.search(r"'TailwindBuilder' object has no attribute '(\w+)'", result.stderr)
                if match:
                    missing_method = match.group(1)
                    print(f"  • Method '{missing_method}' not found on TailwindBuilder.")
                    
                    # Check if it exists in any module
                    if missing_method in method_to_module:
                        module = method_to_module[missing_method]
                        print(f"  • This method is in the '{module}' module.")
                        print(f"  • Add: from cjm_tailwind_utils.{module} import *")
                    else:
                        # Suggest similar methods
                        similar = [m for m in method_to_module.keys() if missing_method.lower() in m.lower()]
                        if similar:
                            print(f"  • Did you mean: {', '.join(similar[:3])}?")
                else:
                    print("  • Method not available. Check if you need to import the module.")
                print("  • Use: cjm-tailwind-utils list-methods")
            elif "TypeError" in result.stderr:
                print("  • Invalid arguments. Use: cjm-tailwind-utils method <method-name>")
            
            print("\n📚 For working examples:")
            print("  • cjm-tailwind-utils examples all       → See all example code")
            print("  • cjm-tailwind-utils examples core      → See basic usage")
    
    except subprocess.TimeoutExpired:
        print(f"❌ Code execution timed out after {args.timeout} seconds.")
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
    finally:
        # Clean up temp file
        try:
            os.unlink(temp_file)
        except:
            pass

# %% ../nbs/cli.ipynb 39
def main(
): # None
    """Main CLI entry point for cjm-tailwind-utils"""
    parser = argparse.ArgumentParser(
        prog='cjm-tailwind-utils',
        description='cjm-tailwind-utils: Type-safe, chainable Tailwind CSS class builder with validation, deduplication, and modern CSS support.\n\n'
                    'This library provides a fluent API for building Tailwind CSS classes programmatically in Python.\n'
                    'Key features: method chaining, automatic deduplication, arbitrary value support, and modern CSS (v4+).\n\n'
                    'This CLI tool helps you explore the library\'s API: discover methods, view examples, understand imports.\n'
                    'Perfect for coding assistants to quickly understand available functionality and usage patterns.\n\n'
                    'Quick start: Try "cjm-tailwind-utils list-imports" to see import patterns, or\n'
                    '"cjm-tailwind-utils search <keyword>" to find specific methods.\n\n'
                    'For coding assistants: Use "cjm-tailwind-utils validate-code" to test your code snippets!',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Commands (use "<command> -h" for help)')
    
    # Method commands
    list_methods_parser = subparsers.add_parser('list-methods', 
                                                 help='Show all TailwindBuilder methods → Find what you can build')
    list_methods_parser.add_argument('--module', help='Filter by module: core, layout, style, variants, modern')
    list_methods_parser.add_argument('--signatures', action='store_true', help='Include signatures and return types')
    list_methods_parser.set_defaults(func=cmd_list_methods)
    
    method_parser = subparsers.add_parser('method', 
                                          help='Get method details → See parameters and usage')
    method_parser.add_argument('method', help='Method name (e.g., p, flex, text, hover)')
    method_parser.set_defaults(func=cmd_method_details)
    
    method_source_parser = subparsers.add_parser('method-source', 
                                                  help='View method source → Understand implementation')
    method_source_parser.add_argument('method', help='Method name (e.g., p, flex, text, hover)')
    method_source_parser.set_defaults(func=cmd_source)
    
    # Variable commands
    list_vars_parser = subparsers.add_parser('list-variables', 
                                             help='Show constants/variables → See available data')
    list_vars_parser.add_argument('--module', help='Filter by module: core, colors, types, validation')
    list_vars_parser.add_argument('--values', action='store_true', help='Show actual values')
    list_vars_parser.set_defaults(func=cmd_list_variables)
    
    variable_parser = subparsers.add_parser('variable', 
                                            help='Get variable details → See value and usage')
    variable_parser.add_argument('name', help='Variable name (e.g., TAILWIND_COLORS, SPECIAL_COLORS)')
    variable_parser.set_defaults(func=cmd_variable_details)
    
    variable_source_parser = subparsers.add_parser('variable-source', 
                                                    help='View variable source → See definition')
    variable_source_parser.add_argument('name', help='Variable name')
    variable_source_parser.set_defaults(func=cmd_variable_source)
    
    # Type commands
    list_types_parser = subparsers.add_parser('list-types', 
                                              help='Show type definitions → For type hints')
    list_types_parser.add_argument('--module', help='Filter by module: types, colors, validation')
    list_types_parser.add_argument('--definitions', action='store_true', help='Show full definitions')
    list_types_parser.set_defaults(func=cmd_list_types)
    
    type_parser = subparsers.add_parser('type', 
                                        help='Get type details → See allowed values')
    type_parser.add_argument('name', help='Type name (e.g., SpacingValue, ColorValue)')
    type_parser.set_defaults(func=cmd_type_details)
    
    type_source_parser = subparsers.add_parser('type-source', 
                                               help='View type source → See definition')
    type_source_parser.add_argument('name', help='Type name')
    type_source_parser.set_defaults(func=cmd_type_source)
    
    # Import commands
    list_imports_parser = subparsers.add_parser('list-imports', 
                                                help='Show import patterns → Start here!')
    list_imports_parser.add_argument('--use-case', help='Filter by use case')
    list_imports_parser.add_argument('--detailed', action='store_true', help='Show all details')
    list_imports_parser.set_defaults(func=cmd_list_imports)
    
    import_parser = subparsers.add_parser('import', 
                                          help='Get import details → See what it provides')
    import_parser.add_argument('pattern', help='Pattern name (e.g., all, core, layout_methods)')
    import_parser.set_defaults(func=cmd_import_details)
    
    # Module command
    module_parser = subparsers.add_parser('module', 
                                          help='Explore a module → See methods and usage')
    module_parser.add_argument('name', help='Module: core, layout, style, variants, modern')
    module_parser.set_defaults(func=cmd_module_info)
    
    # Search command
    search_parser = subparsers.add_parser('search', 
                                          help='Search everything → Find by keyword')
    search_parser.add_argument('keyword', help='Search term (searches names, descriptions, parameters)')
    search_parser.set_defaults(func=cmd_search)
    
    # Example commands
    list_examples_parser = subparsers.add_parser('list-examples', 
                                                 help='Show example modules → Learn by example')
    list_examples_parser.set_defaults(func=cmd_list_examples)
    
    examples_parser = subparsers.add_parser('examples', 
                                            help='View example code → See real usage')
    examples_parser.add_argument('module', help='Module: core, colors, layout, style, variants, modern, all')
    examples_parser.set_defaults(func=cmd_show_example)
    
    # Validate-code command
    validate_parser = subparsers.add_parser('validate-code', 
                                            help='Test your code snippets → Auto-imports & helpful errors!',
                                            description='Validate Python code that uses cjm-tailwind-utils.\n\n'
                                                        'This command helps you test code snippets before using them.\n'
                                                        'It automatically detects and imports needed modules.\n\n'
                                                        'Usage:\n'
                                                        '  # From stdin (type/paste code, then Ctrl+D):\n'
                                                        '  cjm-tailwind-utils validate-code\n\n'
                                                        '  # From file:\n'
                                                        '  cjm-tailwind-utils validate-code -f example.py\n\n'
                                                        '  # Show output:\n'
                                                        '  cjm-tailwind-utils validate-code --show-output\n\n'
                                                        'For examples of valid code, use:\n'
                                                        '  cjm-tailwind-utils examples all\n'
                                                        '  cjm-tailwind-utils list-examples',
                                            formatter_class=argparse.RawDescriptionHelpFormatter)
    validate_parser.add_argument('-f', '--file', help='Read code from file instead of stdin')
    validate_parser.add_argument('--import-mode', choices=['auto', 'all', 'manual'], default='auto',
                                 help='Import mode: auto (detect needed imports), all (import everything), manual (no auto imports)')
    validate_parser.add_argument('--show-output', action='store_true', help='Show code output')
    validate_parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output (same as --show-output)')
    validate_parser.add_argument('--timeout', type=int, default=10, help='Execution timeout in seconds (default: 10)')
    validate_parser.set_defaults(func=cmd_validate_code)
    
    # Parse arguments
    args = parser.parse_args()
    
    # Execute command
    if args.command:
        args.func(args)
    else:
        parser.print_help()
