"""Core TailwindBuilder class with chainable API, deduplication, and utility methods. This is the foundation - always import this module first."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/core.ipynb.

# %% auto 0
__all__ = ['deduplicate_classes', 'TailwindBuilder', 'test_core_usage_examples']

# %% ../nbs/core.ipynb 3
from typing import Union, Optional, List, Self, Set
from functools import lru_cache
from fastcore.basics import patch

from .types import SpacingValue, SizeValue
from .validation import should_replace_class, ChainModeError

# %% ../nbs/core.ipynb 5
def _smart_split_classes(class_string: str) -> List[str]:
    """Split a class string intelligently, preserving spaces within brackets/parentheses.
    
    This function handles cases like 'supports-[(display: grid)]:grid' where spaces
    inside brackets should not cause the class to be split.
    """
    if not class_string:
        return []
    
    classes = []
    current_class = []
    bracket_depth = 0
    paren_depth = 0
    
    for char in class_string:
        if char == '[':
            bracket_depth += 1
            current_class.append(char)
        elif char == ']':
            bracket_depth -= 1
            current_class.append(char)
        elif char == '(':
            paren_depth += 1
            current_class.append(char)
        elif char == ')':
            paren_depth -= 1
            current_class.append(char)
        elif char == ' ' and bracket_depth == 0 and paren_depth == 0:
            # Only split on spaces when not inside brackets or parentheses
            if current_class:
                classes.append(''.join(current_class))
                current_class = []
        else:
            current_class.append(char)
    
    # Don't forget the last class
    if current_class:
        classes.append(''.join(current_class))
    
    return classes

# %% ../nbs/core.ipynb 6
def deduplicate_classes(
    *class_sources: Union[str, List[str], None] # Multiple sources of CSS classes (strings, lists, or None)
) -> str:  # Space-separated string of deduplicated CSS classes, sorted alphabetically
    """Deduplicate CSS classes from multiple sources.
    
    Takes multiple sources of CSS classes (strings, lists, or None values) and
    returns a single space-separated string with duplicates removed and sorted
    alphabetically for consistency.
    
    Args:
        *class_sources: Variable number of class sources, each can be:
            - A space-separated string of CSS classes
            - A list of CSS class strings
            - None (will be ignored)
    
    Returns:
        A space-separated string of unique CSS classes, sorted alphabetically
        
    Examples:
        >>> deduplicate_classes("btn btn-primary", ["btn", "btn-lg"])
        'btn btn-lg btn-primary'
        
        >>> deduplicate_classes("hidden md:block", None, ["hidden", "lg:block"])
        'hidden lg:block md:block'
    """
    all_classes = set()
    
    for source in class_sources:
        if source is None:
            continue
        elif isinstance(source, str):
            # Smart split that preserves spaces within brackets/parentheses
            classes = _smart_split_classes(source)
            all_classes.update(classes)
        elif isinstance(source, list):
            # Add all items from the list
            all_classes.update(source)
        else:
            # For any other iterable, try to add its items
            try:
                all_classes.update(source)
            except TypeError:
                # If it's not iterable, convert to string and split
                all_classes.update(_smart_split_classes(str(source)))
    
    # Return sorted for consistent output
    return " ".join(sorted(all_classes))

# %% ../nbs/core.ipynb 11
class TailwindBuilder:
    """Dynamic Tailwind CSS utility class builder with chainable fluent API.
    
    This builder provides methods for generating Tailwind utility classes with proper type hints
    and validation. It uses a chainable fluent API where methods return self for chaining.
    """
    
    def __init__(
        self,
        dedupe: bool = False      # TODO: Add description
    ):
        """Initialize builder.
        """
        self._classes: List[str] = []
        # Use a set for O(1) lookups during deduplication
        self._class_set: Set[str] = set()
        self._dedupe = dedupe
    
    def _add_class(
        self,
        class_str: str,  # Class string to add
        dedupe: bool = False # Whether to deduplicate conflicting classes
    ) -> None:  # No return value
        """Add a class string to the internal list with optional deduplication.
        
        Optimized version using a set for fast lookups and batch operations.
        """
        if not class_str:
            return
            
        if self._dedupe or dedupe:
            # Fast check for exact duplicates using set
            if class_str in self._class_set:
                return
            
            # Check for conflicting classes
            # Collect indices to remove in a single pass
            indices_to_remove = []
            for i, existing_class in enumerate(self._classes):
                if should_replace_class(existing_class, class_str):
                    indices_to_remove.append(i)
            
            # Remove in reverse order to maintain indices
            for i in reversed(indices_to_remove):
                removed_class = self._classes.pop(i)
                self._class_set.remove(removed_class)
        
        # Add the new class
        self._classes.append(class_str)
        self._class_set.add(class_str)

# %% ../nbs/core.ipynb 13
@patch
def arbitrary(
    self:TailwindBuilder,
    prefix: str,  # CSS utility prefix (e.g., 'p', 'w', 'text')
    value: str,  # Arbitrary value (e.g., '23px', '#1da1f2', 'calc(100%-1rem)')
    suffix: Optional[str] = None  # Optional suffix (e.g., for p-[20px]/50)
) -> Self:  # Returns self for chaining
    """Generate arbitrary value utility class.
    """
    class_str = f"{prefix}-[{value}]"
    if suffix:
        class_str += f"/{suffix}"
    self._add_class(class_str)
    return self

# %% ../nbs/core.ipynb 14
@patch
def util(
    self:TailwindBuilder,
    *classes: str  # Raw Tailwind utility classes to add
) -> Self:  # Returns self for chaining
    """Add raw Tailwind utility classes without validation.
    
    This method allows adding any Tailwind utility classes directly,
    useful for custom utilities, newer Tailwind features, or third-party plugins.
    """
    class_str = " ".join(classes)
    self._add_class(class_str)
    return self

# %% ../nbs/core.ipynb 16
@patch
def add_class(
    self:TailwindBuilder,
    class_str: str  # Class string to add
) -> Self:  # Returns self for chaining
    """Add arbitrary class string."""
    self._add_class(class_str)
    return self

# %% ../nbs/core.ipynb 17
@patch
def build(
    self:TailwindBuilder
) -> str:  # Final class string
    """Build and return the final class string."""
    return deduplicate_classes(" ".join(self._classes))

# %% ../nbs/core.ipynb 18
@patch
def __str__(
    self:TailwindBuilder
) -> str:  # String representation
    """String representation."""
    return self.build()

# %% ../nbs/core.ipynb 19
@patch
def __repr__(
    self:TailwindBuilder
) -> str:  # Representation
    """Representation."""
    return f"TailwindBuilder(classes={self._classes})"

# %% ../nbs/core.ipynb 20
@patch
def merge(
    self:TailwindBuilder,
    *class_strings: str,
    dedupe: bool = True  # Whether to deduplicate conflicting classes (default: True)
) -> Self:  # Returns self for chaining
    "Merge multiple class strings into the builder, with optional deduplication."
    if not class_strings:
        return self
    
    # Add all classes from all strings
    for class_string in class_strings:
        if class_string:
            for cls in class_string.split():
                if dedupe or self._dedupe:
                    self._add_class(cls, dedupe=True)
                else:
                    # If not deduping, just append directly
                    self._classes.append(cls)
                    self._class_set.add(cls)
    
    return self

# %% ../nbs/core.ipynb 22
@patch
def _spacing_class(
    self:TailwindBuilder,
    prefix: str,  # CSS class prefix (e.g., 'p', 'mx', 'gap')
    value: Union[SpacingValue, str]  # Spacing value to format
) -> str:  # Complete CSS class string
    """Build spacing utility class."""
    formatted_value = _format_spacing_value(value)
    return f"{prefix}-{formatted_value}"

# %% ../nbs/core.ipynb 23
@patch
def _size_class(
    self:TailwindBuilder,
    prefix: str,  # CSS class prefix (e.g., 'w', 'h', 'max-w')
    value: Union[SizeValue, str]  # Size value to format
) -> str:  # Complete CSS class string
    """Build size utility class."""
    if isinstance(value, str) and "/" in value:
        # Handle fractions
        return f"{prefix}-{value}"
    return f"{prefix}-{_format_spacing_value(value)}"

# %% ../nbs/core.ipynb 24
@lru_cache(maxsize=256)
def _format_spacing_value(
    value: SpacingValue  # Spacing value to format (numeric or string)
) -> str:  # Formatted string for CSS class name
    """Format spacing value for class name."""
    if isinstance(value, (int, float)):
        # Handle decimal values like 0.5, 1.5, 2.5, etc.
        return str(value)
    return str(value)

# %% ../nbs/core.ipynb 34
def test_core_usage_examples(
): # TODO: Add type hint
    """
    Test and demonstrate core TailwindBuilder functionality.
    
    This function serves as both a test suite and a comprehensive usage guide
    for the TailwindBuilder core functionality. It demonstrates:
    
    1. Arbitrary value support with square brackets
    2. Raw utility class addition
    3. Method chaining and fluent API
    4. Class merging with deduplication
    5. Builder independence and immutability
    
    Each test includes clear variable names and comments to help coding
    assistants understand the expected behavior and use cases.
    """
    
    # === Arbitrary Value Support ===
    # The arbitrary() method allows custom CSS values with Tailwind's bracket notation
    
    # Example: Custom width value
    custom_width_builder = TailwindBuilder()
    custom_width_result = custom_width_builder.arbitrary('w', '23px').build()
    assert custom_width_result == 'w-[23px]', "Arbitrary width should use bracket notation"
    
    # Example: Custom background color
    custom_bg_builder = TailwindBuilder()
    custom_bg_result = custom_bg_builder.arbitrary('bg', '#1da1f2').build()
    assert custom_bg_result == 'bg-[#1da1f2]', "Arbitrary colors should use bracket notation"
    
    # Example: Arbitrary value with opacity modifier
    opacity_builder = TailwindBuilder()
    opacity_result = opacity_builder.arbitrary('p', '20px', '50').build()
    assert opacity_result == 'p-[20px]/50', "Arbitrary values can include opacity modifiers"
    
    # === Raw Utility Classes ===
    # The util() method adds Tailwind classes without validation
    
    # Example: Single utility class
    single_util_builder = TailwindBuilder()
    single_util_result = single_util_builder.util('custom-class').build()
    assert single_util_result == 'custom-class', "Single utility class should be added as-is"
    
    # Example: Multiple utility classes at once
    multi_util_builder = TailwindBuilder()
    multi_util_result = multi_util_builder.util('flex', 'items-center').build()
    assert multi_util_result == deduplicate_classes('flex items-center'), "Multiple utilities can be added together"
    
    # === Method Chaining (Fluent API) ===
    # All methods return self, enabling elegant chaining
    
    # Example: Building a flex container
    flex_container = TailwindBuilder()
    flex_result = flex_container.util('flex').util('items-center').build()
    assert flex_result == deduplicate_classes('flex items-center'), "Methods should chain seamlessly"
    
    # === Class Merging ===
    # The merge() method combines class strings with optional deduplication
    
    # Example: Simple merge without conflicts
    merge_builder = TailwindBuilder()
    merge_result = merge_builder.merge('p-4 text-white', 'bg-blue-500').build()
    assert merge_result == deduplicate_classes('p-4 text-white bg-blue-500'), "Non-conflicting classes should all be preserved"
    
    # Example: Merge with deduplication (conflicting classes)
    dedupe_builder = TailwindBuilder()
    dedupe_result = dedupe_builder.merge('p-4', 'p-8', dedupe=True).build()
    assert dedupe_result == 'p-8', "With deduplication, later classes should override earlier ones"
    
    # Example: Merge without deduplication
    no_dedupe_builder = TailwindBuilder(dedupe=False)
    no_dedupe_result = no_dedupe_builder.merge('p-4', 'p-8', dedupe=False).build()
    assert no_dedupe_result == deduplicate_classes('p-4 p-8'), "Without deduplication, all classes should be kept"
    
    # === Deduplication with Exact Duplicates ===
    # When dedupe=True, exact duplicate classes are removed
    
    # Example: Removing exact duplicates
    exact_dupe_builder = TailwindBuilder(dedupe=True)
    exact_dupe_result = exact_dupe_builder.util('flex').util('flex').build()
    assert exact_dupe_result == 'flex', "Exact duplicates should be removed when dedupe=True"
    
    # === Builder Independence ===
    # Each TailwindBuilder instance maintains its own state
    
    # Example: Two independent builders
    builder_one = TailwindBuilder()
    builder_two = TailwindBuilder()
    
    builder_one.util('p-4')
    builder_two.util('m-4')
    
    assert builder_one.build() == 'p-4', "First builder should only have its own classes"
    assert builder_two.build() == 'm-4', "Second builder should only have its own classes"
    
    return "All core tests passed!"
