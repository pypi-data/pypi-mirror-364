"""Layout utilities for spacing (padding, margin), sizing (width, height), positioning, flexbox, and grid. Essential for component structure and spacing."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/layout.ipynb.

# %% auto 0
__all__ = ['test_layout_usage_examples']

# %% ../nbs/layout.ipynb 3
from typing import Union, Literal, Optional, Self

from .core import TailwindBuilder, patch, _spacing_class, _size_class, _format_spacing_value, deduplicate_classes
from .types import SpacingValue, SizeValue, ZIndexValue

from .validation import InvalidValueError, validate_spacing_value

# %% ../nbs/layout.ipynb 6
@patch
def p(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None  # Optional side specification
) -> Self:  # Self for chaining
    """Generate padding utility class with arbitrary value support and validation."""
    try:
        # Validate the value
        validate_spacing_value(value)
        
        prefix = f"p{side}" if side else "p"
        if isinstance(value, str) and not value in ["px", "auto", "full"]:
            # Check if it's an arbitrary value (contains units or special chars)
            if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                class_str = f"{prefix}-[{value}]"
                self._add_class(class_str)
                return self
        class_str = self._spacing_class(prefix, value)
        self._add_class(class_str)
        return self
    except InvalidValueError as e:
        raise InvalidValueError(f"Invalid padding value: {e}")

# %% ../nbs/layout.ipynb 7
@patch
def m(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None,  # Optional side specification
    negative: bool = False  # Whether to apply negative value
) -> Self:  # Self for chaining
    """Generate margin utility class with arbitrary value support, validation, and negative values.
    """
    try:
        # Check if value is already negative
        is_negative = negative
        if isinstance(value, (int, float)) and value < 0:
            is_negative = True
            value = abs(value)
        
        # Validate the value (margins can be negative)
        validate_spacing_value(value, allow_negative=True)
        
        prefix = f"m{side}" if side else "m"
        if is_negative:
            prefix = f"-{prefix}"
            
        if isinstance(value, str) and not value in ["px", "auto", "full"]:
            # Check if it's an arbitrary value
            if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                class_str = f"{prefix}-[{value}]"
                self._add_class(class_str)
                return self
        class_str = self._spacing_class(prefix, value)
        self._add_class(class_str)
        return self
    except InvalidValueError as e:
        raise InvalidValueError(f"Invalid margin value: {e}")

# %% ../nbs/layout.ipynb 8
@patch
def gap(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    axis: Optional[Literal["x", "y"]] = None  # Optional axis specification
) -> Self:  # Self for chaining
    """Generate gap utility class with arbitrary value support."""
    prefix = f"gap-{axis}" if axis else "gap"
    if isinstance(value, str) and not value in ["px", "auto", "full"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            class_str = f"{prefix}-[{value}]"
            self._add_class(class_str)
            return self
    class_str = self._spacing_class(prefix, value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 9
@patch
def space(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    axis: Literal["x", "y"]  # Axis for spacing
) -> Self:  # Self for chaining
    """Generate space between utility class with arbitrary value support."""
    prefix = f"space-{axis}"
    if isinstance(value, str) and not value in ["px", "auto", "full"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            class_str = f"{prefix}-[{value}]"
            self._add_class(class_str)
            return self
    class_str = self._spacing_class(prefix, value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 11
@patch
def w(
    self:TailwindBuilder,
    value: Union[SizeValue, str],  # Size value or arbitrary value string
    important: bool = False  # Whether to add !important modifier
) -> Self:  # Self for chaining
    """Generate width utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            cls = f"w-[{value}]"
            class_str = f"!{cls}" if important else cls
            self._add_class(class_str)
            return self
    cls = self._size_class("w", value)
    class_str = f"!{cls}" if important else cls
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 12
@patch
def h(
    self:TailwindBuilder,
    value: Union[SizeValue, str],  # Size value or arbitrary value string
    important: bool = False  # Whether to add !important modifier
) -> Self:  # Self for chaining
    """Generate height utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            cls = f"h-[{value}]"
            class_str = f"!{cls}" if important else cls
            self._add_class(class_str)
            return self
    cls = self._size_class("h", value)
    class_str = f"!{cls}" if important else cls
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 13
@patch
def size(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Self:  # Self for chaining
    """Generate size utility class (sets both width and height) with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"size-[{value}]"
            self._add_class(class_str)
            return self
    class_str = self._size_class("size", value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 14
@patch
def min_w(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Self:  # Self for chaining
    """Generate min-width utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"min-w-[{value}]"
            self._add_class(class_str)
            return self
    class_str = self._size_class("min-w", value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 15
@patch
def max_w(
    self:TailwindBuilder,
    value: Union[SizeValue, str, Literal["xs", "sm", "md", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "prose"]]  # Size value, arbitrary value, or named size
) -> Self:  # Self for chaining
    """Generate max-width utility class with arbitrary value support."""
    if value in ["xs", "sm", "md", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "prose"]:
        class_str = f"max-w-{value}"
    elif isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"max-w-[{value}]"
        else:
            class_str = self._size_class("max-w", value)
    else:
        class_str = self._size_class("max-w", value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 16
@patch
def min_h(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Self:  # Self for chaining
    """Generate min-height utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"min-h-[{value}]"
            self._add_class(class_str)
            return self
    class_str = self._size_class("min-h", value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 17
@patch
def max_h(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Self:  # Self for chaining
    """Generate max-height utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"max-h-[{value}]"
            self._add_class(class_str)
            return self
    class_str = self._size_class("max-h", value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 19
@patch
def position(
    self:TailwindBuilder,
    value: Literal["static", "fixed", "absolute", "relative", "sticky"]  # Position type
) -> Self:  # Self for chaining
    """Generate position utility class."""
    self._add_class(value)
    return self

# %% ../nbs/layout.ipynb 20
@patch
def inset(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Inset value or arbitrary value string
    side: Optional[Literal["top", "right", "bottom", "left", "x", "y"]] = None,  # Optional side specification
    negative: bool = False  # Whether to apply negative value
) -> Self:  # Self for chaining
    """Generate inset (top/right/bottom/left) utility class with arbitrary value support and negative values.
    """
    # Check if value is already negative
    is_negative = negative
    if isinstance(value, (int, float)) and value < 0:
        is_negative = True
        value = abs(value)
    
    if isinstance(value, str) and not value in ["px", "auto", "full"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            prefix = side if side else "inset"
            if is_negative:
                prefix = f"-{prefix}"
            class_str = f"{prefix}-[{value}]"
            self._add_class(class_str)
            return self
    
    if side:
        prefix = side
        if is_negative:
            prefix = f"-{prefix}"
        class_str = self._spacing_class(prefix, value)
    else:
        prefix = "inset"
        if is_negative:
            prefix = f"-{prefix}"
        class_str = self._spacing_class(prefix, value)
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 21
@patch
def z(
    self:TailwindBuilder,
    value: Union[ZIndexValue, int, str]  # Z-index value, integer, or arbitrary value string
) -> Self:  # Self for chaining
    """Generate z-index utility class with arbitrary value support."""
    if isinstance(value, str) and value not in ["auto"]:
        # It's an arbitrary value
        class_str = f"z-[{value}]"
    elif isinstance(value, int) and value not in [0, 10, 20, 30, 40, 50]:
        # Non-standard integer value
        class_str = f"z-[{value}]"
    else:
        class_str = f"z-{value}"
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 23
@patch
def display(
    self:TailwindBuilder,
    value: Literal["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"]  # Display type
) -> Self:  # Self for chaining
    """Generate display utility class."""
    self._add_class(value)
    return self

# %% ../nbs/layout.ipynb 25
@patch
def flex(self:TailwindBuilder, 
         direction: Optional[Literal["row", "row-reverse", "col", "col-reverse"]] = None,
         wrap: Optional[Literal["wrap", "wrap-reverse", "nowrap"]] = None,
         grow: Optional[Literal[0, 1]] = None,
         shrink: Optional[Literal[0, 1]] = None,
         basis: Optional[Union[SizeValue, str]] = None) -> Self:
    """Generate flex utility classes with arbitrary value support."""
    classes = ["flex"]
    if direction:
        classes.append(f"flex-{direction}")
    if wrap:
        classes.append(f"flex-{wrap}")
    if grow is not None:
        classes.append(f"grow-{grow}" if grow else "grow-0")
    if shrink is not None:
        classes.append(f"shrink-{shrink}" if shrink else "shrink-0")
    if basis is not None:
        if isinstance(basis, str) and any(unit in basis for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            classes.append(f"basis-[{basis}]")
        else:
            classes.append(f"basis-{_format_spacing_value(basis)}")
    for class_str in classes:
        self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 26
@patch
def items(
    self:TailwindBuilder,
    value: Literal["start", "end", "center", "baseline", "stretch"]  # Alignment value for flex/grid items
) -> Self:  # Self for chaining
    """Generate align-items utility class."""
    class_str = f"items-{value}"
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 27
@patch
def justify(
    self:TailwindBuilder,
    value: Literal["normal", "start", "end", "center", "between", "around", "evenly", "stretch"]  # Justify-content value
) -> Self:  # Self for chaining
    """Generate justify-content utility class."""
    class_str = f"justify-{value}"
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 28
@patch
def align(
    self:TailwindBuilder,
    value: Literal["auto", "start", "end", "center", "stretch", "baseline"]  # Align-self value
) -> Self:  # Self for chaining
    """Generate align-self utility class."""
    class_str = f"self-{value}"
    self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 30
@patch
def grid(self:TailwindBuilder, 
         cols: Optional[Union[int, Literal["none"], str]] = None,
         rows: Optional[Union[int, Literal["none"], str]] = None,
         flow: Optional[Literal["row", "col", "dense", "row-dense", "col-dense"]] = None) -> Self:
    """Generate grid utility classes with arbitrary value support."""
    classes = ["grid"]
    if cols is not None:
        if isinstance(cols, str) and cols != "none":
            # Check if it's an arbitrary value
            if "(" in cols or "px" in cols or "fr" in cols:
                classes.append(f"grid-cols-[{cols}]")
            else:
                classes.append(f"grid-cols-{cols}")
        else:
            classes.append(f"grid-cols-{cols}")
    if rows is not None:
        if isinstance(rows, str) and rows != "none":
            # Check if it's an arbitrary value
            if "(" in rows or "px" in rows or "fr" in rows:
                classes.append(f"grid-rows-[{rows}]")
            else:
                classes.append(f"grid-rows-{rows}")
        else:
            classes.append(f"grid-rows-{rows}")
    if flow:
        classes.append(f"grid-flow-{flow}")
    for class_str in classes:
        self._add_class(class_str)
    return self

# %% ../nbs/layout.ipynb 31
@patch
def col(
    self:TailwindBuilder,
    span: Union[int, Literal["auto", "full"]],  # Number of columns to span or keyword
    start: Optional[int] = None  # Starting column number
) -> Self:  # Self for chaining
    """Generate grid column utility classes."""
    if span:
        self._add_class(f"col-span-{span}")
    if start:
        self._add_class(f"col-start-{start}")
    return self

# %% ../nbs/layout.ipynb 32
@patch
def row(
    self:TailwindBuilder,
    span: Union[int, Literal["auto", "full"]],  # Number of rows to span or keyword
    start: Optional[int] = None  # Starting row number
) -> Self:  # Self for chaining
    """Generate grid row utility classes."""
    if span:
        self._add_class(f"row-span-{span}")
    if start:
        self._add_class(f"row-start-{start}")
    return self

# %% ../nbs/layout.ipynb 37
def test_layout_usage_examples(
): # TODO: Add type hint
    """
    Test and demonstrate layout utilities for spacing, sizing, positioning, flexbox, and grid.
    
    This function serves as both a test suite and a comprehensive usage guide
    for the layout utilities in cjm-tailwind-utils. It demonstrates:
    
    1. Spacing utilities (padding, margin, gap, space)
    2. Size utilities (width, height, min/max dimensions)
    3. Position utilities (position type, inset, z-index)
    4. Display utilities
    5. Flexbox utilities and parameters
    6. Grid utilities and configuration
    7. Arbitrary value support
    8. Negative value support
    9. Method chaining and fluent API
    
    Each test includes clear examples to help coding assistants understand
    proper usage of layout utilities.
    """
    
    # Import necessary for standalone usage
    from cjm_tailwind_utils.core import TailwindBuilder
    
    # === Spacing Utilities ===
    # Padding and margin with directional variants
    
    # Basic padding
    basic_padding = TailwindBuilder().p(4).build()
    assert basic_padding == "p-4", "Basic padding with spacing scale 4"
    
    # Directional padding (x-axis)
    horizontal_padding = TailwindBuilder().p(4, "x").build()
    assert horizontal_padding == "px-4", "Horizontal padding (left and right)"
    
    # Negative margin
    negative_margin = TailwindBuilder().m(4, negative=True).build()
    assert negative_margin == "-m-4", "Negative margin with spacing scale 4"
    
    # Negative directional margin
    negative_horizontal_margin = TailwindBuilder().m(4, "x", negative=True).build()
    assert negative_horizontal_margin == "-mx-4", "Negative horizontal margin"
    
    # Arbitrary spacing values
    arbitrary_padding = TailwindBuilder().p("2.5rem").build()
    assert arbitrary_padding == "p-[2.5rem]", "Arbitrary padding value with rem units"
    
    # === Gap and Space Utilities ===
    # For flexbox and grid layouts
    
    # Basic gap (all directions)
    basic_gap = TailwindBuilder().gap(4).build()
    assert basic_gap == "gap-4", "Gap between flex/grid items"
    
    # Directional gap
    horizontal_gap = TailwindBuilder().gap(4, "x").build()
    assert horizontal_gap == "gap-x-4", "Horizontal gap only"
    
    # Space between children
    vertical_space = TailwindBuilder().space(2, "y").build()
    assert vertical_space == "space-y-2", "Vertical space between children"
    
    # === Size Utilities ===
    # Width, height, and combined size
    
    # Numeric width (spacing scale)
    numeric_width = TailwindBuilder().w(24).build()
    assert numeric_width == "w-24", "Width using spacing scale (6rem)"
    
    # Special width values
    full_height = TailwindBuilder().h("full").build()
    assert full_height == "h-full", "Full height (100%)"
    
    # Combined size (width and height)
    square_size = TailwindBuilder().size(10).build()
    assert square_size == "size-10", "Square size 10 (2.5rem)"
    
    # Fraction-based width
    half_width = TailwindBuilder().w("1/2").build()
    assert half_width == "w-1/2", "Half width (50%)"
    
    # Arbitrary size values
    custom_width = TailwindBuilder().w("300px").build()
    assert custom_width == "w-[300px]", "Arbitrary pixel width"
    
    # Min/max dimensions
    min_width = TailwindBuilder().min_w("200px").build()
    assert min_width == "min-w-[200px]", "Minimum width constraint"
    
    max_width = TailwindBuilder().max_w("lg").build()
    assert max_width == "max-w-lg", "Maximum width using named size"
    
    # === Position Utilities ===
    # Positioning and z-index
    
    # Position type
    absolute_position = TailwindBuilder().position("absolute").build()
    assert absolute_position == "absolute", "Absolute positioning"
    
    # Inset (top/right/bottom/left)
    zero_inset = TailwindBuilder().inset(0).build()
    assert zero_inset == "inset-0", "Zero inset on all sides"
    
    # Directional inset
    top_inset = TailwindBuilder().inset(4, "top").build()
    assert top_inset == "top-4", "Top inset with spacing scale 4"
    
    # Negative inset
    negative_top = TailwindBuilder().inset(2, "top", negative=True).build()
    assert negative_top == "-top-2", "Negative top position"
    
    # Z-index
    z_index = TailwindBuilder().z(10).build()
    assert z_index == "z-10", "Z-index layer 10"
    
    # Arbitrary z-index
    custom_z = TailwindBuilder().z(999).build()
    assert custom_z == "z-[999]", "Arbitrary z-index value"
    
    # === Display Utilities ===
    # Control display type
    
    flex_display = TailwindBuilder().display("flex").build()
    assert flex_display == "flex", "Flex display"
    
    hidden_display = TailwindBuilder().display("hidden").build()
    assert hidden_display == "hidden", "Hidden element"
    
    # === Flexbox Utilities ===
    # Comprehensive flexbox configuration
    
    # Basic flex
    basic_flex = TailwindBuilder().flex().build()
    assert basic_flex == "flex", "Basic flex container"
    
    # Flex with direction
    flex_column = TailwindBuilder().flex(direction="col").build()
    assert flex_column == "flex flex-col", "Flex container with column direction"
    
    # Flex with wrap
    flex_wrap = TailwindBuilder().flex(wrap="wrap").build()
    assert flex_wrap == "flex flex-wrap", "Flex container with wrapping"
    
    # Flex with multiple parameters
    complex_flex = TailwindBuilder().flex(
        direction="row",
        wrap="wrap",
        grow=1,
        shrink=0,
        basis="auto"
    ).build()
    assert "flex" in complex_flex, "Complex flex contains base flex"
    assert "flex-row" in complex_flex, "Complex flex contains direction"
    assert "flex-wrap" in complex_flex, "Complex flex contains wrap"
    assert "grow" in complex_flex, "Complex flex contains grow"
    assert "shrink-0" in complex_flex, "Complex flex contains shrink"
    assert "basis-auto" in complex_flex, "Complex flex contains basis"
    
    # Flex alignment
    center_items = TailwindBuilder().items("center").build()
    assert center_items == "items-center", "Align items center"
    
    justify_between = TailwindBuilder().justify("between").build()
    assert justify_between == "justify-between", "Justify content space-between"
    
    # === Grid Utilities ===
    # CSS Grid configuration
    
    # Basic grid
    basic_grid = TailwindBuilder().grid().build()
    assert basic_grid == "grid", "Basic grid container"
    
    # Grid with columns
    three_columns = TailwindBuilder().grid(cols=3).build()
    assert three_columns == "grid grid-cols-3", "Grid with 3 columns"
    
    # Grid with custom template
    custom_grid = TailwindBuilder().grid(cols="200px 1fr 200px").build()
    assert custom_grid == deduplicate_classes("grid grid-cols-[200px 1fr 200px]"), "Grid with custom column template"
    
    # Grid item spanning
    span_two_cols = TailwindBuilder().col(2).build()
    assert span_two_cols == "col-span-2", "Span 2 columns"
    
    # Grid item positioning
    row_position = TailwindBuilder().row("full", start=2).build()
    assert row_position == deduplicate_classes("row-span-full row-start-2"), "Full row span starting at row 2"
    
    # === Complex Layout Examples ===
    # Real-world layout patterns
    
    # Card layout
    card_layout = (TailwindBuilder()
        .p(6)
        .m(4)
        .max_w("sm")
        .position("relative")
        .build())
    assert "p-6" in card_layout, "Card has padding"
    assert "m-4" in card_layout, "Card has margin"
    assert "max-w-sm" in card_layout, "Card has max width"
    assert "relative" in card_layout, "Card has relative position"
    
    # Flex container with gap
    flex_container = (TailwindBuilder()
        .flex()
        .gap(4)
        .items("center")
        .justify("between")
        .p(4)
        .build())
    assert "flex" in flex_container, "Container is flex"
    assert "gap-4" in flex_container, "Container has gap"
    assert "items-center" in flex_container, "Container centers items"
    assert "justify-between" in flex_container, "Container justifies between"
    assert "p-4" in flex_container, "Container has padding"
    
    # === Flex/Flex-wrap Compatibility Test ===
    # Ensure flex and flex-wrap don't conflict (bug regression test)
    
    test_cases = [
        # Test that flex and flex-wrap coexist
        (lambda: TailwindBuilder().flex().util("flex-wrap"), ["flex", "flex-wrap"]),
        (lambda: TailwindBuilder().util("flex").util("flex-wrap"), ["flex", "flex-wrap"]),
        (lambda: TailwindBuilder().flex(wrap="wrap"), ["flex", "flex-wrap"]),
        (lambda: TailwindBuilder().display("flex").util("flex-wrap"), ["flex", "flex-wrap"]),
    ]
    
    for chain_fn, expected in test_cases:
        result = chain_fn().build()
        result_classes = result.split()
        for expected_class in expected:
            assert expected_class in result_classes, f"Expected '{expected_class}' in '{result}'"
    
    return "All layout tests passed!"
